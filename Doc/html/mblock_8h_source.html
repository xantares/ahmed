<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AHMED: mblock.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">AHMED
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">mblock.h</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00006"></a>00006 <span class="preprocessor">#ifndef MBLOCK_H</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor">#define MBLOCK_H</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;blas.h&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;cmplx.h&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;preserveVec.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;<a class="code" href="cluster_8h.html" title="Include file for the class cluster.">cluster.h</a>&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;basmod.h&quot;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>mblock
<a name="l00019"></a>00019 {
<a name="l00020"></a>00020   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classblcluster.html" title="in this class the block structure of the H-matrix is stored">blcluster</a>;
<a name="l00021"></a>00021   <span class="keyword">friend</span> <span class="keywordtype">void</span> copymbl_(mblock&lt;double&gt;*, mblock&lt;float&gt;*);
<a name="l00022"></a>00022   <span class="keyword">friend</span> <span class="keywordtype">void</span> copymbl_(mblock&lt;dcomp&gt;*, mblock&lt;scomp&gt;*);
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="keyword">protected</span>:
<a name="l00025"></a>00025   T *<a class="code" href="classblcluster.html#ad4b1910a034cd61a7da077881bae1e87" title="returns the pointer to the data of the corresponding block in A">data</a>;                <span class="comment">// if low-rank-repr. UV^H (twice MAX_RANK columns)</span>
<a name="l00026"></a>00026   <span class="keywordtype">unsigned</span> <a class="code" href="classblcluster.html#ac3f85b495bb2fdee9978e20d2748c700" title="dimensions of this block">n1</a>, n2;        <span class="comment">// n1 number of rows, n2 number of columns</span>
<a name="l00027"></a>00027   <span class="keywordtype">unsigned</span> bl_rank;       <span class="comment">// the rank of this block</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029   <span class="keyword">struct </span>st_info {
<a name="l00030"></a>00030     <span class="keywordtype">unsigned</span> is_LrM : 1;        <span class="comment">// low rank representation ? else dense</span>
<a name="l00031"></a>00031     <span class="keywordtype">unsigned</span> is_HeM : 1;        <span class="comment">// for dense matrices: is hermitian ?</span>
<a name="l00032"></a>00032     <span class="keywordtype">unsigned</span> is_SyM : 1;        <span class="comment">// for dense matrices: is symmetric ?</span>
<a name="l00033"></a>00033     <span class="keywordtype">unsigned</span> is_LtM : 1;        <span class="comment">// for dense matrices: is lower triangular ?</span>
<a name="l00034"></a>00034     <span class="keywordtype">unsigned</span> is_UtM : 1;        <span class="comment">// for dense matrices: is upper triangular ?</span>
<a name="l00035"></a>00035   } info;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037   <span class="comment">// a low-rank matrix U V^H is stored columnwise : (U,V)</span>
<a name="l00038"></a>00038   <span class="comment">// a dense matrix is stored column by column</span>
<a name="l00039"></a>00039   <span class="comment">// a dense symmetric/hermitian matrix is stored as an upper triangular matrix</span>
<a name="l00040"></a>00040   <span class="comment">// an upper triangular matrix is stored columnwise (a11,a12,a22,...)</span>
<a name="l00041"></a>00041   <span class="comment">// a lower triangular matrix is stored columnwise (a11,a21,a31,...)</span>
<a name="l00042"></a>00042   <span class="comment">//         on the diagonal of it is a permutation P of the rows of L defined</span>
<a name="l00043"></a>00043   <span class="comment">//         by (Pl)_{L_{ii}} = l_i</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   <span class="comment">// add low-rank matrix to this low-rank matrix with truncation</span>
<a name="l00046"></a>00046   <span class="keywordtype">void</span> addtrll(<span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU, T* V, <span class="keywordtype">unsigned</span> ldV,
<a name="l00047"></a>00047                <span class="keywordtype">double</span> delta, <span class="keywordtype">unsigned</span> kgoal, contLowLevel&lt;T&gt;* haarInfo=NULL,
<a name="l00048"></a>00048                T* X=NULL, <span class="keywordtype">unsigned</span> ldX=0, T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="comment">// append low-rank matrix to this low-rank matrix</span>
<a name="l00051"></a>00051   <span class="keywordtype">void</span> append(<span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU, T* V, <span class="keywordtype">unsigned</span> ldV);
<a name="l00052"></a>00052 
<a name="l00053"></a>00053   <span class="comment">// add low-rank matrix to this low-rank matrix with truncation</span>
<a name="l00054"></a>00054   <span class="comment">// returns remainder</span>
<a name="l00055"></a>00055   <span class="keywordtype">void</span> addtrll_rmnd(<span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>,
<a name="l00056"></a>00056                     <span class="keywordtype">double</span>, <span class="keywordtype">unsigned</span>, <span class="keywordtype">unsigned</span>&amp;, T*&amp;, T*&amp;);
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <span class="comment">// compute singular values of this low-rank matrix</span>
<a name="l00059"></a>00059   <span class="keywordtype">void</span> get_svals_LrM(<span class="keywordtype">double</span>*) <span class="keyword">const</span>;
<a name="l00060"></a>00060   <span class="keywordtype">void</span> get_svals_LrM(<span class="keywordtype">float</span>*) <span class="keyword">const</span>;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="comment">// unify two low-rank matrices</span>
<a name="l00063"></a>00063   <span class="keywordtype">void</span> unify_cols_LrMLrM(<span class="keywordtype">double</span>, <span class="keywordtype">unsigned</span>, <span class="keyword">const</span> mblock&amp;, <span class="keyword">const</span> mblock&amp;,
<a name="l00064"></a>00064                          contLowLevel&lt;T&gt;* haarInfo=NULL, T* X=NULL, <span class="keywordtype">unsigned</span> ldX=0,
<a name="l00065"></a>00065                          T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0);
<a name="l00066"></a>00066   <span class="keywordtype">void</span> unify_rows_LrMLrM(<span class="keywordtype">double</span>, <span class="keywordtype">unsigned</span>, <span class="keyword">const</span> mblock&amp;, <span class="keyword">const</span> mblock&amp;,
<a name="l00067"></a>00067                          contLowLevel&lt;T&gt;* haarInfo=NULL, T* X=NULL, <span class="keywordtype">unsigned</span> ldX=0,
<a name="l00068"></a>00068                          T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0);
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="comment">// *************************************************************************</span>
<a name="l00071"></a>00071   <span class="comment">// PostScript output for low-rank and dense matrices</span>
<a name="l00072"></a>00072   <span class="comment">//</span>
<a name="l00073"></a>00073   <span class="keywordtype">void</span> psout_LrM(std::ostream&amp;, <span class="keywordtype">unsigned</span>, <span class="keywordtype">unsigned</span>, <span class="keywordtype">unsigned</span>, <span class="keywordtype">bool</span>,
<a name="l00074"></a>00074                  <span class="keywordtype">unsigned</span> level=NULL, <a class="code" href="classcluster.html" title="the basis class for storing clusters of degrees of freedom">cluster</a>* cl=NULL,
<a name="l00075"></a>00075                  <span class="keywordtype">void</span> (*f)(<a class="code" href="classcluster.html" title="the basis class for storing clusters of degrees of freedom">cluster</a>* cl, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lvl,
<a name="l00076"></a>00076                            <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> basis)=NULL) <span class="keyword">const</span>;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078   <span class="keywordtype">void</span> psout_GeM(std::ostream&amp;, <span class="keywordtype">unsigned</span>, <span class="keywordtype">unsigned</span>, <span class="keywordtype">unsigned</span>, <span class="keywordtype">bool</span>) <span class="keyword">const</span>;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">// *************************************************************************</span>
<a name="l00081"></a>00081   <span class="comment">// multiplication routines</span>
<a name="l00082"></a>00082   <span class="comment">//</span>
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 
<a name="l00087"></a>00087   <span class="comment">// multiply dense by vector: y += d A x  (A is a dense matrix)</span>
<a name="l00088"></a>00088   <span class="keywordtype">void</span> mltaGeMVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00089"></a>00089     assert(isGeM());
<a name="l00090"></a>00090     blas::gemva(n1, n2, d, data, x, y);
<a name="l00091"></a>00091   }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="comment">// multiply dense by dense: Y += d A X  (A is a dense matrix)</span>
<a name="l00094"></a>00094   <span class="keywordtype">void</span> mltaGeMGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00095"></a>00095                      T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00096"></a>00096     assert(isGeM());
<a name="l00097"></a>00097     blas::gemma(n1, n2, p, d, data, n1, X, ldX, Y, ldY);
<a name="l00098"></a>00098   }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   <span class="comment">// multiply vector by herm transposed dense: y += A^H x  (A is a dense matrix)</span>
<a name="l00101"></a>00101   <span class="keywordtype">void</span> mltaGeMhVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00102"></a>00102     assert(isGeM());
<a name="l00103"></a>00103     blas::gemhva(n1, n2, d, data, x, y);
<a name="l00104"></a>00104   }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   <span class="comment">// multiply dense by herm. transposed dense: Y += d A^H X  (A is a dense matrix)</span>
<a name="l00107"></a>00107   <span class="keywordtype">void</span> mltaGeMhGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00108"></a>00108                       T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00109"></a>00109     assert(isGeM());
<a name="l00110"></a>00110     blas::gemhma(n1, n2, p, d, data, n1, X, ldX, Y, ldY);
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="comment">// multiply vector by transposed dense: y += A^T x  (A is a dense matrix)</span>
<a name="l00114"></a>00114   <span class="keywordtype">void</span> mltaGeMtVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00115"></a>00115     assert(isGeM());
<a name="l00116"></a>00116     blas::gemtva(n1, n2, d, data, x, y);
<a name="l00117"></a>00117   }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   <span class="comment">// multiply dense by transposed dense: Y += d A^T X  (A is a dense matrix)</span>
<a name="l00120"></a>00120   <span class="keywordtype">void</span> mltaGeMtGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00121"></a>00121                       T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00122"></a>00122     assert(isGeM());
<a name="l00123"></a>00123     blas::gemtma(n1, n2, p, d, data, n1, X, ldX, Y, ldY);
<a name="l00124"></a>00124   }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <span class="comment">// multiply hermitian packed by vector: y += d A x (A is herm. dense)</span>
<a name="l00127"></a>00127   <span class="keywordtype">void</span> mltaHeMVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00128"></a>00128     assert(isGeM() &amp;&amp; isHeM() &amp;&amp; n1==n2);
<a name="l00129"></a>00129     blas::hemva(n1, d, data, x, y);
<a name="l00130"></a>00130   }  
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   <span class="comment">// multiply hermitian packed by dense: Y += d A X (A is herm. dense)</span>
<a name="l00133"></a>00133   <span class="keywordtype">void</span> mltaHeMGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00134"></a>00134                         T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00135"></a>00135     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaHeMVec(d, X+ldX*l, Y+ldY*l);
<a name="l00136"></a>00136   }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="comment">// multiply sym packed by vector: y += d A x (A is sym. dense)</span>
<a name="l00139"></a>00139   <span class="keywordtype">void</span> mltaSyMVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00140"></a>00140     assert(isGeM() &amp;&amp; isSyM() &amp;&amp; n1==n2);
<a name="l00141"></a>00141     blas::symva(n1, d, data, x, y);
<a name="l00142"></a>00142   }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="comment">// multiply sym packed by dense: Y += d A X (A is sym. dense)</span>
<a name="l00145"></a>00145   <span class="keywordtype">void</span> mltaSyMGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00146"></a>00146                         T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00147"></a>00147     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaSyMVec(d, X+ldX*l, Y+ldY*l);
<a name="l00148"></a>00148   }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150   <span class="comment">// multiply transposed of herm. packed by vector: y += d A^T x (A is herm. dense)</span>
<a name="l00151"></a>00151   <span class="keywordtype">void</span> mltaHeMtVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00152"></a>00152     assert(isGeM() &amp;&amp; isHeM() &amp;&amp; n1==n2);
<a name="l00153"></a>00153     blas::conj(n1, x);
<a name="l00154"></a>00154     blas::conj(n1, y);
<a name="l00155"></a>00155     mltaHeMVec(conj(d), x, y);
<a name="l00156"></a>00156     blas::conj(n1, x);
<a name="l00157"></a>00157     blas::conj(n1, y);
<a name="l00158"></a>00158   }  
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="comment">// multiply transposed of herm packed by dense: Y += d A^T X (A is herm. dense)</span>
<a name="l00161"></a>00161   <span class="keywordtype">void</span> mltaHeMtGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00162"></a>00162                         T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00163"></a>00163     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaHeMtVec(d, X+ldX*l, Y+ldY*l);
<a name="l00164"></a>00164   }
<a name="l00165"></a>00165   
<a name="l00166"></a>00166   <span class="comment">// multiply herm transp of sym. packed by vector: y += d A^H x (A is sym. dense)</span>
<a name="l00167"></a>00167   <span class="keywordtype">void</span> mltaSyMhVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00168"></a>00168     assert(isGeM() &amp;&amp; isSyM() &amp;&amp; n1==n2);
<a name="l00169"></a>00169     blas::conj(n1, x);
<a name="l00170"></a>00170     blas::conj(n1, y);
<a name="l00171"></a>00171     mltaSyMVec(conj(d), x, y);
<a name="l00172"></a>00172     blas::conj(n1, x);
<a name="l00173"></a>00173     blas::conj(n1, y);
<a name="l00174"></a>00174   }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176   <span class="comment">// multiply herm trans of sym packed by dense: y += d A^H x (A is sym. dense)</span>
<a name="l00177"></a>00177   <span class="keywordtype">void</span> mltaSyMhGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00178"></a>00178                    T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00179"></a>00179     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaSyMhVec(d, X+ldX*l, Y+ldY*l);
<a name="l00180"></a>00180   }
<a name="l00181"></a>00181   
<a name="l00182"></a>00182   
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="comment">// multiply lower triangular by vector: y += d PL x</span>
<a name="l00185"></a>00185   <span class="keywordtype">void</span> mltaLtMVec(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">// multiply lower triangular by dense: Y += d PL X</span>
<a name="l00188"></a>00188   <span class="keywordtype">void</span> mltaLtMGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00189"></a>00189                         T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00190"></a>00190     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaLtMVec(d, X+ldX*l, Y+ldY*l);
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">// multiply upper triangular by vector: y += d A x (A is utr)</span>
<a name="l00194"></a>00194   <span class="keywordtype">void</span> mltaUtMVec(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="comment">// multiply upper triangular by dense: Y += d A X (A is utr)</span>
<a name="l00197"></a>00197   <span class="keywordtype">void</span> mltaUtMGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00198"></a>00198                         T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00199"></a>00199     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaUtMVec(d, X+ldX*l, Y+ldY*l);
<a name="l00200"></a>00200   }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202   <span class="comment">// multiply herm transp of lower triangular by vector: y += d (PL)^H x = d L^H P^{-1} x</span>
<a name="l00203"></a>00203   <span class="keywordtype">void</span> mltaLtMhVec(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <span class="comment">// multiply herm transp of lower triangular by dense: Y += d (PL)^H X = d L^H P^{-1} X</span>
<a name="l00206"></a>00206   <span class="keywordtype">void</span> mltaLtMhGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00207"></a>00207                    T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00208"></a>00208     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaLtMhVec(d, X+ldX*l, Y+ldY*l);
<a name="l00209"></a>00209   }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   <span class="comment">// multiply herm transp of upper triangular by vector: y += d A^H x (A is utr)</span>
<a name="l00212"></a>00212   <span class="keywordtype">void</span> mltaUtMhVec(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <span class="comment">// multiply herm transposed of upper triang by dense: Y += d A^H X (A is utr)</span>
<a name="l00215"></a>00215   <span class="keywordtype">void</span> mltaUtMhGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00216"></a>00216                    T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00217"></a>00217     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaUtMhVec(d, X+ldX*l, Y+ldY*l);
<a name="l00218"></a>00218   }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <span class="comment">// multiply transposed of lower triang by vector: y += d (PL)^T x = d L^T P^{-1} x</span>
<a name="l00221"></a>00221   <span class="keywordtype">void</span> mltaLtMtVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00222"></a>00222     assert(isGeM() &amp;&amp; isLtM() &amp;&amp; n1==n2);
<a name="l00223"></a>00223     blas::conj(n1, x);
<a name="l00224"></a>00224     blas::conj(n1, y);
<a name="l00225"></a>00225     mltaLtMhVec(conj(d), x, y);
<a name="l00226"></a>00226     blas::conj(n1, x);
<a name="l00227"></a>00227     blas::conj(n1, y);
<a name="l00228"></a>00228   }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <span class="comment">// multiply transposed of  lower triang by dense: Y += d (PL)^T X = d L^T P^{-1} X</span>
<a name="l00231"></a>00231   <span class="keywordtype">void</span> mltaLtMtGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00232"></a>00232                    T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00233"></a>00233     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaLtMtVec(d, X+ldX*l, Y+ldY*l);
<a name="l00234"></a>00234   }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236   
<a name="l00237"></a>00237   <span class="comment">// multiply transposed of upper triangular by vector: y += d A^T x (A is utr)</span>
<a name="l00238"></a>00238   <span class="keywordtype">void</span> mltaUtMtVec(T d, T* x, T* y)<span class="keyword"> const </span>{
<a name="l00239"></a>00239     assert(isGeM() &amp;&amp; isUtM() &amp;&amp; n1==n2);
<a name="l00240"></a>00240     blas::conj(n1, x);
<a name="l00241"></a>00241     blas::conj(n1, y);
<a name="l00242"></a>00242     mltaUtMhVec(conj(d), x, y);
<a name="l00243"></a>00243     blas::conj(n1, x);
<a name="l00244"></a>00244     blas::conj(n1, y);
<a name="l00245"></a>00245   }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="comment">// multiply transposed of upper triangular by dense: Y += d A^T X (A is utr)</span>
<a name="l00248"></a>00248   <span class="keywordtype">void</span> mltaUtMtGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l00249"></a>00249                    T* Y, <span class="keywordtype">unsigned</span> ldY)<span class="keyword"> const </span>{
<a name="l00250"></a>00250     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; ++l) mltaUtMtVec(d, X+ldX*l, Y+ldY*l);
<a name="l00251"></a>00251   }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="comment">// *************************************************************************</span>
<a name="l00257"></a>00257   <span class="comment">// PUBLIC routines</span>
<a name="l00258"></a>00258   <span class="comment">//</span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="keyword">public</span>:
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   <span class="comment">// Konstruktor</span>
<a name="l00263"></a>00263   mblock(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n) : n1(m), n2(n) {
<a name="l00264"></a>00264     bl_rank = info.is_HeM = info.is_SyM = info.is_LtM = info.is_UtM = 0;
<a name="l00265"></a>00265     info.is_LrM = 1;
<a name="l00266"></a>00266     data = NULL;
<a name="l00267"></a>00267   }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="comment">// Destruktor</span>
<a name="l00270"></a>00270   ~mblock() {
<a name="l00271"></a>00271     <span class="keyword">delete</span>[] data;
<a name="l00272"></a>00272   }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="comment">// number of values in data</span>
<a name="l00275"></a>00275   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nvals()<span class="keyword"> const </span>{
<a name="l00276"></a>00276     <span class="keywordflow">if</span> (isGeM()) {
<a name="l00277"></a>00277       <span class="keywordflow">if</span> (isHeM() || isSyM() || isLtM() || isUtM()) <span class="keywordflow">return</span> n1*(n1+1)/2;
<a name="l00278"></a>00278       <span class="keywordflow">else</span> <span class="keywordflow">return</span> n1*n2;
<a name="l00279"></a>00279     } <span class="keywordflow">else</span> <span class="keywordflow">return</span> (n1+n2)*bl_rank;
<a name="l00280"></a>00280   };
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   <span class="comment">// return size of this mblock</span>
<a name="l00283"></a>00283   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size()<span class="keyword"> const </span>{
<a name="l00284"></a>00284     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T)*nvals() + <span class="keyword">sizeof</span>(mblock&lt;T&gt;);
<a name="l00285"></a>00285   };
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="comment">// *************************************************************************</span>
<a name="l00288"></a>00288   <span class="comment">// set/read attributes</span>
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="keywordtype">unsigned</span> getn1() {
<a name="l00291"></a>00291     <span class="keywordflow">return</span> n1;
<a name="l00292"></a>00292   }
<a name="l00293"></a>00293   <span class="keywordtype">unsigned</span> getn2() {
<a name="l00294"></a>00294     <span class="keywordflow">return</span> n2;
<a name="l00295"></a>00295   }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   <span class="keywordtype">bool</span> isLrM()<span class="keyword"> const </span>{
<a name="l00298"></a>00298     <span class="keywordflow">return</span> info.is_LrM;
<a name="l00299"></a>00299   }
<a name="l00300"></a>00300   <span class="keywordtype">bool</span> isGeM()<span class="keyword"> const </span>{
<a name="l00301"></a>00301     <span class="keywordflow">return</span> !isLrM();
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303   <span class="keywordtype">bool</span> isHeM()<span class="keyword"> const </span>{
<a name="l00304"></a>00304     assert(isGeM());
<a name="l00305"></a>00305     <span class="keywordflow">return</span> info.is_HeM;
<a name="l00306"></a>00306   }
<a name="l00307"></a>00307   <span class="keywordtype">bool</span> isSyM()<span class="keyword"> const </span>{
<a name="l00308"></a>00308     assert(isGeM());
<a name="l00309"></a>00309     <span class="keywordflow">return</span> info.is_SyM;
<a name="l00310"></a>00310   }
<a name="l00311"></a>00311   <span class="keywordtype">bool</span> isLtM()<span class="keyword"> const </span>{
<a name="l00312"></a>00312     assert(isGeM());
<a name="l00313"></a>00313     <span class="keywordflow">return</span> info.is_LtM;
<a name="l00314"></a>00314   }
<a name="l00315"></a>00315   <span class="keywordtype">bool</span> isUtM()<span class="keyword"> const </span>{
<a name="l00316"></a>00316     assert(isGeM());
<a name="l00317"></a>00317     <span class="keywordflow">return</span> info.is_UtM;
<a name="l00318"></a>00318   }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="keywordtype">unsigned</span> rank()<span class="keyword"> const </span>{
<a name="l00321"></a>00321     assert(isLrM());
<a name="l00322"></a>00322     <span class="keywordflow">return</span> bl_rank;
<a name="l00323"></a>00323   }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="keywordtype">void</span> freedata() {
<a name="l00326"></a>00326     <span class="keyword">delete</span>[] data;
<a name="l00327"></a>00327     data = NULL;
<a name="l00328"></a>00328     info.is_LrM = 1;
<a name="l00329"></a>00329     bl_rank = 0;
<a name="l00330"></a>00330   }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   T* getdata()<span class="keyword"> const </span>{
<a name="l00333"></a>00333     <span class="keywordflow">return</span> data;
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   <span class="keywordtype">void</span> setrank(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> k) {
<a name="l00337"></a>00337     <span class="keyword">delete</span>[] data;
<a name="l00338"></a>00338     bl_rank = k;
<a name="l00339"></a>00339     info.is_LrM = 1;
<a name="l00340"></a>00340     <span class="keywordflow">if</span> (k) {
<a name="l00341"></a>00341       data = <span class="keyword">new</span> T[k*(n1+n2)];
<a name="l00342"></a>00342       assert(data!=NULL);
<a name="l00343"></a>00343     } <span class="keywordflow">else</span> data = NULL;
<a name="l00344"></a>00344   }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <span class="keywordtype">void</span> setGeM() {
<a name="l00347"></a>00347     <span class="keyword">delete</span>[] data;
<a name="l00348"></a>00348     info.is_LrM = info.is_HeM = info.is_SyM = info.is_LtM = info.is_UtM = 0;
<a name="l00349"></a>00349     data = <span class="keyword">new</span> T[n1*n2];
<a name="l00350"></a>00350     assert(data!=NULL);
<a name="l00351"></a>00351   }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="keywordtype">void</span> setHeM() {
<a name="l00354"></a>00354     assert(n1==n2);
<a name="l00355"></a>00355     <span class="keyword">delete</span>[] data;
<a name="l00356"></a>00356     info.is_LrM = info.is_SyM = info.is_UtM = info.is_LtM = 0;
<a name="l00357"></a>00357     info.is_HeM = 1;
<a name="l00358"></a>00358     data = <span class="keyword">new</span> T[n1*(n1+1)/2];
<a name="l00359"></a>00359     assert(data!=NULL);
<a name="l00360"></a>00360   }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="keywordtype">void</span> setSyM() {
<a name="l00363"></a>00363     assert(n1==n2);
<a name="l00364"></a>00364     <span class="keyword">delete</span>[] data;
<a name="l00365"></a>00365     info.is_LrM = info.is_HeM = info.is_UtM = info.is_LtM = 0;
<a name="l00366"></a>00366     info.is_SyM = 1;
<a name="l00367"></a>00367     data = <span class="keyword">new</span> T[n1*(n1+1)/2];
<a name="l00368"></a>00368     assert(data!=NULL);
<a name="l00369"></a>00369   }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="keywordtype">void</span> setLtM() {
<a name="l00372"></a>00372     assert(n1==n2);
<a name="l00373"></a>00373     <span class="keyword">delete</span>[] data;
<a name="l00374"></a>00374     info.is_LrM = info.is_HeM = info.is_SyM = info.is_UtM = 0;
<a name="l00375"></a>00375     info.is_LtM = 1;
<a name="l00376"></a>00376     data = <span class="keyword">new</span> T[n1*(n1+1)/2];
<a name="l00377"></a>00377     assert(data!=NULL);
<a name="l00378"></a>00378   }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="keywordtype">void</span> setUtM() {
<a name="l00381"></a>00381     assert(n1==n2);
<a name="l00382"></a>00382     <span class="keyword">delete</span>[] data;
<a name="l00383"></a>00383     info.is_LrM = info.is_HeM = info.is_SyM = info.is_LtM = 0;
<a name="l00384"></a>00384     info.is_UtM = 1;
<a name="l00385"></a>00385     data = <span class="keyword">new</span> T[n1*(n1+1)/2];
<a name="l00386"></a>00386     assert(data!=NULL);
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="keywordtype">void</span> get_prop(<span class="keywordtype">unsigned</span>* inf) {
<a name="l00390"></a>00390     <span class="keywordflow">if</span> ((inf[1] = isLrM())) inf[0] = bl_rank;
<a name="l00391"></a>00391     <span class="keywordflow">else</span> {
<a name="l00392"></a>00392       inf[2] = isHeM();
<a name="l00393"></a>00393       inf[3] = isLtM();
<a name="l00394"></a>00394       inf[4] = isUtM();
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396   }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="comment">// *************************************************************************</span>
<a name="l00400"></a>00400   <span class="comment">// Initialization routines</span>
<a name="l00401"></a>00401   <span class="comment">//</span>
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="comment">// init with 0</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="keywordtype">void</span> init0_GeM(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n) {
<a name="l00406"></a>00406     n1 = m;
<a name="l00407"></a>00407     n2 = n;
<a name="l00408"></a>00408     setGeM();
<a name="l00409"></a>00409     blas::setzero(n1*n2, data);
<a name="l00410"></a>00410   }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   <span class="keywordtype">void</span> init0_HeM(<span class="keywordtype">unsigned</span> n) {
<a name="l00413"></a>00413     n1 = n2 = n;
<a name="l00414"></a>00414     setHeM();
<a name="l00415"></a>00415     blas::setzero(n1*(n1+1)/2, data);
<a name="l00416"></a>00416   }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   <span class="keywordtype">void</span> init0_SyM(<span class="keywordtype">unsigned</span> n) {
<a name="l00419"></a>00419     n1 = n2 = n;
<a name="l00420"></a>00420     setSyM();
<a name="l00421"></a>00421     blas::setzero(n1*(n1+1)/2, data);
<a name="l00422"></a>00422   }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="keywordtype">void</span> init0_UtM(<span class="keywordtype">unsigned</span> n) {
<a name="l00425"></a>00425     n1 = n2 = n;
<a name="l00426"></a>00426     setUtM();
<a name="l00427"></a>00427     blas::setzero(n1*(n1+1)/2, data);
<a name="l00428"></a>00428   }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430   <span class="keywordtype">void</span> init0_LtM(<span class="keywordtype">unsigned</span> n) {
<a name="l00431"></a>00431     n1 = n2 = n;
<a name="l00432"></a>00432     setLtM();
<a name="l00433"></a>00433     blas::fill0_ltr(n, data);
<a name="l00434"></a>00434   }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436   <span class="comment">// init with identity</span>
<a name="l00437"></a>00437   <span class="keywordtype">void</span> initId_GeM(<span class="keywordtype">unsigned</span> n) {
<a name="l00438"></a>00438     n1 = n2 = n;
<a name="l00439"></a>00439     setGeM();
<a name="l00440"></a>00440     blas::fillId(n, data);
<a name="l00441"></a>00441   }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="keywordtype">void</span> initId_HeM(<span class="keywordtype">unsigned</span> n) {
<a name="l00444"></a>00444     n1 = n2 = n;
<a name="l00445"></a>00445     setHeM();
<a name="l00446"></a>00446     blas::fillId_utr(n, data);
<a name="l00447"></a>00447   }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   <span class="keywordtype">void</span> initId_SyM(<span class="keywordtype">unsigned</span> n) {
<a name="l00450"></a>00450     n1 = n2 = n;
<a name="l00451"></a>00451     setSyM();
<a name="l00452"></a>00452     blas::fillId_utr(n, data);
<a name="l00453"></a>00453   }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <span class="keywordtype">void</span> initId_LtM(<span class="keywordtype">unsigned</span> n) {
<a name="l00456"></a>00456     n1 = n2 = n;
<a name="l00457"></a>00457     setLtM();
<a name="l00458"></a>00458     blas::fillId_ltr(n, data);
<a name="l00459"></a>00459   }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="keywordtype">void</span> initId_UtM(<span class="keywordtype">unsigned</span> n) {
<a name="l00462"></a>00462     n1 = n2 = n;
<a name="l00463"></a>00463     setUtM();
<a name="l00464"></a>00464     blas::fillId_utr(n, data);
<a name="l00465"></a>00465   }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="comment">// *************************************************************************</span>
<a name="l00468"></a>00468   <span class="comment">// Addition routines</span>
<a name="l00469"></a>00469   <span class="comment">//</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <span class="comment">// add dns to dns</span>
<a name="l00472"></a>00472   <span class="keywordtype">void</span> addGeM_toGeM(T* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA) {
<a name="l00473"></a>00473     assert(ldA&gt;=n1 &amp;&amp; isGeM());
<a name="l00474"></a>00474     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j) blas::add(n1, A+j*ldA, data+j*n1);
<a name="l00475"></a>00475   }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <span class="keywordtype">void</span> addHeM_toHeM(T* <span class="keyword">const</span> A) {
<a name="l00478"></a>00478     assert(isGeM() &amp;&amp; (isHeM() || isSyM()) );
<a name="l00479"></a>00479     blas::axpy(n1*(n1+1)/2, (T) 1.0, A, data);
<a name="l00480"></a>00480   }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="keywordtype">void</span> addGeM_toHeM(T* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <span class="comment">// add lwr to dns</span>
<a name="l00485"></a>00485   <span class="keywordtype">void</span> addLrM_toGeM(<span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU,
<a name="l00486"></a>00486                       T* V, <span class="keywordtype">unsigned</span> ldV) {
<a name="l00487"></a>00487     assert(isGeM());
<a name="l00488"></a>00488     <span class="keywordflow">if</span> (k&gt;0) blas::gemmha(n1, k, n2, U, ldU, V, ldV, data, n1);
<a name="l00489"></a>00489   }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   <span class="comment">// add lwr to herm. dns</span>
<a name="l00492"></a>00492   <span class="keywordtype">void</span> addLrM_toHeM(<span class="keywordtype">unsigned</span> mult, <span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU,
<a name="l00493"></a>00493                            T* V, <span class="keywordtype">unsigned</span> ldV);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="comment">// add lwr to utr. dns</span>
<a name="l00496"></a>00496   <span class="keywordtype">void</span> addLrM_toUtM(<span class="keywordtype">unsigned</span> mult, <span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU,
<a name="l00497"></a>00497                          T* V, <span class="keywordtype">unsigned</span> ldV);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <span class="comment">// add lwr to mblock and truncate to min(eps, kgoal)</span>
<a name="l00500"></a>00500   <span class="keywordtype">void</span> addLrM(<span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU, T* V, <span class="keywordtype">unsigned</span> ldV,
<a name="l00501"></a>00501               <span class="keywordtype">double</span> eps, <span class="keywordtype">unsigned</span> kgoal, contLowLevel&lt;T&gt;* haarInfo=NULL, T* X=NULL,
<a name="l00502"></a>00502               <span class="keywordtype">unsigned</span> ldX=0, T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="comment">// add lwr to mblock and truncate to min(eps, kgoal)</span>
<a name="l00505"></a>00505   <span class="keywordtype">void</span> addLrM_Exact(<span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU, T* V, <span class="keywordtype">unsigned</span> ldV);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="comment">// add lwr to mblock and truncate to min(eps, kgoal), returns remainder</span>
<a name="l00508"></a>00508   <span class="keywordtype">void</span> addLrM_rmnd(<span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU, T* V,
<a name="l00509"></a>00509                    <span class="keywordtype">unsigned</span> ldV, <span class="keywordtype">double</span> eps, <span class="keywordtype">unsigned</span> kgoal,
<a name="l00510"></a>00510                    <span class="keywordtype">unsigned</span>&amp; kR, T* &amp;UR, T* &amp;VR);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512   <span class="comment">// add dns to mblock and truncate to min(eps, MAX_RANK)</span>
<a name="l00513"></a>00513   <span class="keywordtype">void</span> addGeM(T* A, <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span> eps, <span class="keywordtype">unsigned</span> rankmax,
<a name="l00514"></a>00514               contLowLevel&lt;T&gt;* haarInfo=NULL, T* X=NULL, <span class="keywordtype">unsigned</span> ldX=0,
<a name="l00515"></a>00515               T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517   <span class="keywordtype">void</span> unify_rows(<span class="keywordtype">double</span>, <span class="keywordtype">unsigned</span>, <span class="keyword">const</span> mblock&amp;, <span class="keyword">const</span> mblock&amp;,
<a name="l00518"></a>00518                   contLowLevel&lt;T&gt;* haarInfo=NULL, T* X=NULL, <span class="keywordtype">unsigned</span> ldX=0,
<a name="l00519"></a>00519                   T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0);
<a name="l00520"></a>00520   <span class="keywordtype">void</span> unify_cols(<span class="keywordtype">double</span>, <span class="keywordtype">unsigned</span>, <span class="keyword">const</span> mblock&amp;, <span class="keyword">const</span> mblock&amp;,
<a name="l00521"></a>00521                   contLowLevel&lt;T&gt;* haarInfo=NULL, T* X=NULL, <span class="keywordtype">unsigned</span> ldX=0,
<a name="l00522"></a>00522                   T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524   <span class="keywordtype">void</span> addMbl(<span class="keywordtype">double</span> eps, <span class="keywordtype">unsigned</span> rankmax, mblock* mbl, contLowLevel&lt;T&gt;* haarInfo=NULL,
<a name="l00525"></a>00525               T* X=NULL, <span class="keywordtype">unsigned</span> ldX=0, T* Y_=NULL, <span class="keywordtype">unsigned</span> ldY_=0) {
<a name="l00526"></a>00526     <span class="keywordflow">if</span> (mbl-&gt;isLrM()) addLrM(mbl-&gt;rank(), mbl-&gt;data, mbl-&gt;n1,
<a name="l00527"></a>00527                              mbl-&gt;data+mbl-&gt;rank()*mbl-&gt;n1, mbl-&gt;n2,
<a name="l00528"></a>00528                              eps, rankmax, haarInfo, X, ldX, Y_, ldY_);
<a name="l00529"></a>00529     <span class="keywordflow">else</span> {
<a name="l00530"></a>00530       <span class="comment">// if (mbl-&gt;isUtM()) add_utr(mbl-&gt;data, mbl-&gt;n1);</span>
<a name="l00531"></a>00531       <span class="comment">//      else if (mbl-&gt;isLtM()) add_ltr(mbl-&gt;data, mbl-&gt;n1);</span>
<a name="l00532"></a>00532       <span class="keywordflow">if</span> (mbl-&gt;isHeM()|| mbl-&gt;isSyM()) addHeM_toHeM(mbl-&gt;data);
<a name="l00533"></a>00533       <span class="keywordflow">else</span> addGeM(mbl-&gt;data, mbl-&gt;n1, eps, rankmax, haarInfo, X, ldX, Y_, ldY_);
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535   }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537   <span class="keywordtype">void</span> add_dbl_Id() {
<a name="l00538"></a>00538     assert(!isLrM() &amp;&amp; !isUtM() &amp;&amp; !isLtM());
<a name="l00539"></a>00539     <span class="keywordflow">if</span> (isHeM() || isSyM())
<a name="l00540"></a>00540       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) data[i*(i+3)/2] += (T) 1.0;
<a name="l00541"></a>00541     <span class="keywordflow">else</span>
<a name="l00542"></a>00542       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) data[i*(n1+1)] += (T) 1.0;
<a name="l00543"></a>00543   }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="comment">// *************************************************************************</span>
<a name="l00546"></a>00546   <span class="comment">// mutiply mblock or its transposed by vector</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="keywordtype">bool</span> mltaVec(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   <span class="keywordtype">bool</span> mltaGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX, T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="keywordtype">bool</span> mltahVec(T d, T* x, T* y) <span class="keyword">const</span>;  
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   <span class="keywordtype">bool</span> mltahGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX, T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   <span class="keywordtype">bool</span> mltatVec(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559   <span class="keywordtype">bool</span> mltatGeM(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX, T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   <span class="comment">// multiply upper triangular by transposed upper triangular Y += d UU^H</span>
<a name="l00562"></a>00562   <span class="keywordtype">void</span> mltaUtMUtMh_toHeM(T d, T* U) {
<a name="l00563"></a>00563     assert(isHeM());
<a name="l00564"></a>00564     blas::putrmmh(d, n1, U, data);
<a name="l00565"></a>00565   }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="comment">// multiply transposed upper triangular by upper triangular Y += d U^HU</span>
<a name="l00568"></a>00568   <span class="keywordtype">void</span> mltaUtMhUtM_toHeM(T d, T* U) {
<a name="l00569"></a>00569     assert(isHeM());
<a name="l00570"></a>00570     blas::putrmhm(d, n1, U, data);
<a name="l00571"></a>00571   }  
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="comment">// multiply upper triangular by lower triangular Y += d UL</span>
<a name="l00574"></a>00574   <span class="keywordtype">void</span> mltaUtMLtM(T d, T* U, T* L) {
<a name="l00575"></a>00575     assert(n1==n2);
<a name="l00576"></a>00576     blas::putrltrmm(d, n1, U, L, data);
<a name="l00577"></a>00577   }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="comment">// multiply mbl by transposed upper (packed) triangular Y += d AU^H</span>
<a name="l00580"></a>00580   <span class="keywordtype">void</span> mltaMblUtM(T d, mblock* mbl, T* U, <span class="keywordtype">double</span> eps, <span class="keywordtype">unsigned</span> rankmax) {
<a name="l00581"></a>00581     assert(n1==mbl-&gt;n1 &amp;&amp; n2==mbl-&gt;n2);
<a name="l00582"></a>00582     T* tmp;
<a name="l00583"></a>00583     <span class="keywordflow">if</span> (mbl-&gt;isGeM()) {
<a name="l00584"></a>00584       tmp = <span class="keyword">new</span> T[n1*n2];
<a name="l00585"></a>00585       blas::setzero(n1*n2, tmp);
<a name="l00586"></a>00586       blas::geputrmmh(d, n1, n2, mbl-&gt;getdata(), U, tmp);
<a name="l00587"></a>00587       addGeM(tmp, n1, eps, rankmax);
<a name="l00588"></a>00588     } <span class="keywordflow">else</span> {
<a name="l00589"></a>00589       tmp = <span class="keyword">new</span> T[n2*mbl-&gt;rank()];
<a name="l00590"></a>00590       blas::setzero(n2*mbl-&gt;rank(), tmp);
<a name="l00591"></a>00591       blas::putrgemm(d, n2, U, mbl-&gt;rank(),
<a name="l00592"></a>00592                      mbl-&gt;getdata()+n1*mbl-&gt;rank(), tmp);
<a name="l00593"></a>00593       addLrM(mbl-&gt;rank(), mbl-&gt;getdata(), n1, tmp, n2, eps, rankmax);
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595     <span class="keyword">delete</span> [] tmp;
<a name="l00596"></a>00596   }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="comment">// *************************************************************************</span>
<a name="l00600"></a>00600   <span class="comment">// Inversion routines</span>
<a name="l00601"></a>00601   <span class="comment">//</span>
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   <span class="keywordtype">void</span> invertGeM(T* dataC) {
<a name="l00604"></a>00604     assert(isGeM() &amp;&amp; n1==n2);
<a name="l00605"></a>00605     blas::copy(n1*n1, data, dataC);
<a name="l00606"></a>00606     lapack::geinv(n1, dataC);
<a name="l00607"></a>00607   }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="keywordtype">void</span> invertHeM(T* dataC) {
<a name="l00610"></a>00610     assert(isGeM() &amp;&amp; isHeM() &amp;&amp; n1==n2);
<a name="l00611"></a>00611     blas::copy(n1*(n1+1)/2, data, dataC);
<a name="l00612"></a>00612     lapack::geinv_herm(n1, dataC);
<a name="l00613"></a>00613   }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="keywordtype">void</span> invertSyM(T* dataC) {
<a name="l00616"></a>00616     assert(isGeM() &amp;&amp; isSyM() &amp;&amp; n1==n2);
<a name="l00617"></a>00617     blas::copy(n1*(n1+1)/2, data, dataC);
<a name="l00618"></a>00618     lapack::geinv_sym(n1, dataC);
<a name="l00619"></a>00619   }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <span class="keywordtype">int</span> decomp_Cholesky() {
<a name="l00622"></a>00622     assert(isGeM() &amp;&amp; isHeM() &amp;&amp; n1==n2);
<a name="l00623"></a>00623     <span class="keywordtype">int</span> inf = lapack::pptrf(n1, data);
<a name="l00624"></a>00624     info.is_LtM = info.is_HeM = 0;
<a name="l00625"></a>00625     info.is_UtM = 1;
<a name="l00626"></a>00626     <span class="keywordflow">return</span> inf;
<a name="l00627"></a>00627   }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="keywordtype">int</span> decomp_LU(mblock*, mblock*); <span class="comment">// generates LU decomp., destroys data</span>
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <span class="keywordtype">int</span> decomp_UhDU(<span class="keywordtype">int</span>* piv) { <span class="comment">// generates U^H D U decomp. of herm, destroys data</span>
<a name="l00632"></a>00632     assert(isGeM() &amp;&amp; isHeM() &amp;&amp; n1==n2);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="comment">// copy columnwise packed matrix (data) to lower triang. part of tmp</span>
<a name="l00635"></a>00635     T* tmp = <span class="keyword">new</span> T[n1*n1];
<a name="l00636"></a>00636     <span class="keywordtype">unsigned</span> idx1, idx2=0;
<a name="l00637"></a>00637     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) {
<a name="l00638"></a>00638       idx1 = i;
<a name="l00639"></a>00639       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;=i; ++j) {
<a name="l00640"></a>00640         tmp[idx1] = data[idx2++];
<a name="l00641"></a>00641         idx1 += n1;
<a name="l00642"></a>00642       }
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644 
<a name="l00645"></a>00645     <span class="keywordtype">int</span> lwork = -1;
<a name="l00646"></a>00646     T* work, optlwork;
<a name="l00647"></a>00647     lapack::hetrf(n1, tmp, piv, &amp;optlwork, lwork); <span class="comment">// calculate optimal lwork</span>
<a name="l00648"></a>00648     lwork = (int) Re(optlwork);
<a name="l00649"></a>00649     work = <span class="keyword">new</span> T[lwork];
<a name="l00650"></a>00650     <span class="keywordtype">int</span> inf = lapack::hetrf(n1, tmp, piv, work, lwork);
<a name="l00651"></a>00651     <span class="keyword">delete</span>[] work;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653     <span class="comment">// write back lower triangular part of tmp to data</span>
<a name="l00654"></a>00654     idx2 = 0;
<a name="l00655"></a>00655     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) {
<a name="l00656"></a>00656       idx1 = i;
<a name="l00657"></a>00657       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;=i; ++j) {
<a name="l00658"></a>00658         data[idx2++] = tmp[idx1];
<a name="l00659"></a>00659         idx1 += n1;
<a name="l00660"></a>00660       }
<a name="l00661"></a>00661     }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="keyword">delete</span>[] tmp;
<a name="l00664"></a>00664     <span class="keywordflow">return</span> inf;
<a name="l00665"></a>00665   }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667   <span class="comment">// *************************************************************************</span>
<a name="l00668"></a>00668   <span class="comment">// forward/backward substitution</span>
<a name="l00669"></a>00669   <span class="comment">//</span>
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="comment">// solves PL X = B for X, L is unit lower triangular, X is stored in B</span>
<a name="l00672"></a>00672   <span class="keywordtype">void</span> ltr_solve(<span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   <span class="comment">// solves (PL)^H X = B for X, L is unit lower triangular, X is stored in B</span>
<a name="l00675"></a>00675   <span class="keywordtype">void</span> ltrh_solve(<span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="comment">/* solves X (PL)^H = B for X, L is unit lower triangular, X is stored in B</span>
<a name="l00678"></a>00678 <span class="comment">  void ltrh_solve_left(unsigned, T*, unsigned) const;</span>
<a name="l00679"></a>00679 <span class="comment">  */</span>
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="comment">// solves U X = B for X</span>
<a name="l00682"></a>00682   <span class="comment">// U is upper triangular, X is stored in B</span>
<a name="l00683"></a>00683   <span class="keywordtype">void</span> utr_solve(<span class="keywordtype">unsigned</span> m, T* B, <span class="keywordtype">unsigned</span> ldB)<span class="keyword"> const </span>{
<a name="l00684"></a>00684     assert(isGeM() &amp;&amp; isUtM());
<a name="l00685"></a>00685     lapack::utrs(n1, data, m, B, ldB);
<a name="l00686"></a>00686   }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688   <span class="comment">// solves U^H X = B for X, U is upper triangular, X is stored in B</span>
<a name="l00689"></a>00689   <span class="keywordtype">void</span> utrh_solve(<span class="keywordtype">unsigned</span> m, T* B, <span class="keywordtype">unsigned</span> ldB)<span class="keyword"> const </span>{
<a name="l00690"></a>00690     assert(isGeM() &amp;&amp; isUtM());
<a name="l00691"></a>00691     lapack::utrhs(n1, data, m, B, ldB);
<a name="l00692"></a>00692   }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="comment">// solves X U = B for X, U is upper triangular, X is stored in B</span>
<a name="l00695"></a>00695   <span class="keywordtype">void</span> utr_solve_left(<span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   <span class="comment">// *************************************************************************</span>
<a name="l00699"></a>00699   <span class="comment">// Misc routines</span>
<a name="l00700"></a>00700   <span class="comment">//</span>
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   <span class="comment">// Frobenius norm</span>
<a name="l00703"></a>00703   <span class="keywordtype">double</span> nrmF2() <span class="keyword">const</span>;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="comment">// truncate this block to absolute accuracy eps</span>
<a name="l00706"></a>00706   <span class="keywordtype">void</span> trunc_abs(<span class="keywordtype">double</span>);
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   <span class="comment">// truncate this block to given rank</span>
<a name="l00709"></a>00709   <span class="keywordtype">void</span> trunc_rank(<span class="keywordtype">unsigned</span>);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711   <span class="keywordtype">void</span> outp(std::ostream&amp; os)<span class="keyword"> const </span>{
<a name="l00712"></a>00712     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) {
<a name="l00713"></a>00713       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j) os &lt;&lt; data[i+j*n1] &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l00714"></a>00714       os &lt;&lt; std::endl;
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716   }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="keywordtype">void</span> psout(std::ostream&amp; os, <span class="keywordtype">unsigned</span> nmax, <span class="keywordtype">unsigned</span> b1, <span class="keywordtype">unsigned</span> b2,
<a name="l00719"></a>00719              <span class="keywordtype">bool</span> refl, <span class="keywordtype">unsigned</span> level=0, <a class="code" href="classcluster.html" title="the basis class for storing clusters of degrees of freedom">cluster</a>* cl1=NULL,
<a name="l00720"></a>00720              <span class="keywordtype">void</span> (*f)(<a class="code" href="classcluster.html" title="the basis class for storing clusters of degrees of freedom">cluster</a>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>, <span class="keywordtype">double</span>*,
<a name="l00721"></a>00721                        <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span>)=NULL)<span class="keyword"> const </span>{
<a name="l00722"></a>00722     <span class="keywordflow">if</span> (isLrM()) psout_LrM(os, nmax, b1, b2, refl, level, cl1, f);
<a name="l00723"></a>00723     <span class="keywordflow">else</span> psout_GeM(os, nmax, b1, b2, refl);
<a name="l00724"></a>00724   }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726   <span class="keywordtype">void</span> save(std::ofstream&amp; os) {
<a name="l00727"></a>00727     <span class="comment">// 0 isLrM, 1 isGeM, 2 isLtM, 3 isUtM, 4 dense</span>
<a name="l00728"></a>00728     os.write((<span class="keywordtype">char</span>*) &amp;n1, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00729"></a>00729     os.write((<span class="keywordtype">char</span>*) &amp;n2, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00730"></a>00730     <span class="keywordtype">unsigned</span> status, rankt;
<a name="l00731"></a>00731     <span class="keywordflow">if</span> (isLrM()) {
<a name="l00732"></a>00732       status = 0;
<a name="l00733"></a>00733       os.write((<span class="keywordtype">char</span>*) &amp;status, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00734"></a>00734       rankt = rank();
<a name="l00735"></a>00735       os.write((<span class="keywordtype">char</span>*) &amp;rankt, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00736"></a>00736       <span class="keywordflow">if</span> (rankt&gt;0)
<a name="l00737"></a>00737         os.write((<span class="keywordtype">char</span>*) data, rankt*(n1+n2)*<span class="keyword">sizeof</span>(T));
<a name="l00738"></a>00738     } <span class="keywordflow">else</span> { <span class="comment">// mbl is dense</span>
<a name="l00739"></a>00739       assert(isGeM());
<a name="l00740"></a>00740       <span class="keywordflow">if</span> (isHeM()) {
<a name="l00741"></a>00741         status = 1;
<a name="l00742"></a>00742         os.write((<span class="keywordtype">char</span>*) &amp;status, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00743"></a>00743         os.write((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00744"></a>00744       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isLtM()) {
<a name="l00745"></a>00745         status = 2;
<a name="l00746"></a>00746         os.write((<span class="keywordtype">char</span>*) &amp;status, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00747"></a>00747         os.write((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00748"></a>00748       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isUtM()) {
<a name="l00749"></a>00749         status = 3;
<a name="l00750"></a>00750         os.write((<span class="keywordtype">char</span>*) &amp;status, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00751"></a>00751         os.write((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00752"></a>00752       } <span class="keywordflow">if</span> (isSyM()) {
<a name="l00753"></a>00753         status = 5;
<a name="l00754"></a>00754         os.write((<span class="keywordtype">char</span>*) &amp;status, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00755"></a>00755         os.write((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00756"></a>00756       }<span class="keywordflow">else</span> {
<a name="l00757"></a>00757         status = 4;
<a name="l00758"></a>00758         os.write((<span class="keywordtype">char</span>*) &amp;status, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00759"></a>00759         os.write((<span class="keywordtype">char</span>*) data, n1*n2*<span class="keyword">sizeof</span>(T));
<a name="l00760"></a>00760       }
<a name="l00761"></a>00761     }
<a name="l00762"></a>00762   }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764   <span class="keywordtype">void</span> load(std::ifstream&amp; is) {
<a name="l00765"></a>00765     <span class="comment">// 0 isLrM, 1 isGeM, 2 isLtM, 3 isUtM, 4 dense</span>
<a name="l00766"></a>00766     <span class="keywordtype">unsigned</span> status, rank;
<a name="l00767"></a>00767     is.read((<span class="keywordtype">char</span>*) &amp;n1, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00768"></a>00768     is.read((<span class="keywordtype">char</span>*) &amp;n2, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00769"></a>00769     is.read((<span class="keywordtype">char</span>*) &amp;status, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00770"></a>00770     <span class="keywordflow">if</span> (status == 0) {
<a name="l00771"></a>00771       is.read((<span class="keywordtype">char</span>*) &amp;rank, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));
<a name="l00772"></a>00772       setrank(rank);
<a name="l00773"></a>00773       is.read((<span class="keywordtype">char</span>*) data, rank*(n1+n2)*<span class="keyword">sizeof</span>(T));
<a name="l00774"></a>00774     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == 1) {
<a name="l00775"></a>00775       setHeM();
<a name="l00776"></a>00776       is.read((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00777"></a>00777     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == 2) {
<a name="l00778"></a>00778       setLtM();
<a name="l00779"></a>00779       is.read((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00780"></a>00780     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == 3) {
<a name="l00781"></a>00781       setUtM();
<a name="l00782"></a>00782       is.read((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00783"></a>00783     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == 4) {
<a name="l00784"></a>00784       setGeM();
<a name="l00785"></a>00785       is.read((<span class="keywordtype">char</span>*) data, n1*n2*<span class="keyword">sizeof</span>(T));
<a name="l00786"></a>00786     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == 5) {
<a name="l00787"></a>00787       setSyM();
<a name="l00788"></a>00788       is.read((<span class="keywordtype">char</span>*) data, n1*(n1+1)/2*<span class="keyword">sizeof</span>(T));
<a name="l00789"></a>00789     }<span class="keywordflow">else</span> {
<a name="l00790"></a>00790       std::cerr&lt;&lt;<span class="stringliteral">&quot;Error while loading mbls&quot;</span>&lt;&lt;std::endl;
<a name="l00791"></a>00791       exit(1);
<a name="l00792"></a>00792     }
<a name="l00793"></a>00793   }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   <span class="comment">// copy mblock</span>
<a name="l00796"></a>00796   <span class="keywordtype">void</span> copy(mblock&amp;);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="comment">// copy transposed of off-diagonal mblocks</span>
<a name="l00799"></a>00799   <span class="keywordtype">void</span> copyH(mblock&amp;);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   <span class="comment">// copy low-rank matrix to this block</span>
<a name="l00802"></a>00802   <span class="keywordtype">void</span> cpyLrM(<span class="keywordtype">unsigned</span> k, T* U, T* V) {
<a name="l00803"></a>00803     setrank(k);
<a name="l00804"></a>00804     <span class="keywordflow">if</span> (k&gt;0) {
<a name="l00805"></a>00805       blas::copy(k*n1, U, data);
<a name="l00806"></a>00806       blas::copy(k*n2, V, data+k*n1);
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808   }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="comment">// copy low-rank matrix to this block with recompression</span>
<a name="l00811"></a>00811   <span class="keywordtype">void</span> cpyLrM_cmpr(<span class="keywordtype">unsigned</span> k, T* U, <span class="keywordtype">unsigned</span> ldU, T* V, <span class="keywordtype">unsigned</span> ldV,
<a name="l00812"></a>00812                    <span class="keywordtype">double</span> eps, <span class="keywordtype">unsigned</span> rankmax) {
<a name="l00813"></a>00813     freedata();
<a name="l00814"></a>00814     addtrll(k, U, ldU, V, ldV, eps, rankmax);
<a name="l00815"></a>00815   }
<a name="l00816"></a>00816 
<a name="l00817"></a>00817   <span class="keywordtype">void</span> cpyGeM(T* A) {
<a name="l00818"></a>00818     setGeM();
<a name="l00819"></a>00819     blas::copy(n1*n2, A, data);
<a name="l00820"></a>00820   }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822   <span class="keywordtype">void</span> cpyHeM(T* A) {
<a name="l00823"></a>00823     setHeM();
<a name="l00824"></a>00824     blas::copy(n1*(n1+1)/2, A, data);
<a name="l00825"></a>00825   }
<a name="l00826"></a>00826 
<a name="l00827"></a>00827   <span class="keywordtype">void</span> cpySyM(T* A) {
<a name="l00828"></a>00828     setSyM();
<a name="l00829"></a>00829     blas::copy(n1*(n1+1)/2, A, data);
<a name="l00830"></a>00830   }
<a name="l00831"></a>00831 
<a name="l00832"></a>00832   <span class="keywordtype">void</span> cpyUtM(T* A) {
<a name="l00833"></a>00833     setUtM();
<a name="l00834"></a>00834     blas::copy(n1*(n1+1)/2, A, data);
<a name="l00835"></a>00835   }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   <span class="keywordtype">void</span> cpyLtM(T* A) {
<a name="l00838"></a>00838     setLtM();
<a name="l00839"></a>00839     blas::copy(n1*(n1+1)/2, A, data);
<a name="l00840"></a>00840   }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   <span class="keywordtype">void</span> cpy_mbl(<span class="keywordtype">unsigned</span> inf[5], T* A) {
<a name="l00843"></a>00843     <span class="keywordflow">if</span> (inf[1]) cpyLrM(inf[0], A, A+inf[0]*n1);
<a name="l00844"></a>00844     <span class="keywordflow">else</span> {
<a name="l00845"></a>00845       <span class="keywordflow">if</span> (inf[2]) cpyHeM(A);
<a name="l00846"></a>00846       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inf[3]) cpyLtM(A);
<a name="l00847"></a>00847       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inf[4]) cpyUtM(A);
<a name="l00848"></a>00848       <span class="keywordflow">else</span> cpyGeM(A);
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850   }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="keywordtype">void</span> convLrM_toGeM();  <span class="comment">// internal conversion</span>
<a name="l00853"></a>00853   <span class="keywordtype">void</span> convLrM_toGeM(<span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>);
<a name="l00854"></a>00854   <span class="keywordtype">void</span> convGeM_toLrM(<span class="keywordtype">double</span>);   <span class="comment">// internal conversion</span>
<a name="l00855"></a>00855 
<a name="l00856"></a>00856   <span class="keywordtype">void</span> convHeM_toGeM(T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l00857"></a>00857   <span class="keywordtype">void</span> convSyM_toGeM(T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l00858"></a>00858   <span class="keywordtype">void</span> convLrM_toGeM(T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l00859"></a>00859   <span class="keywordtype">void</span> convGeM_toGeM(T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;  <span class="comment">// different leading dim</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861   <span class="comment">// compute minimum diagonal entry of upper triangular matrix</span>
<a name="l00862"></a>00862   T get_min_dentr() <span class="keyword">const</span>;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864   <span class="comment">// compute row/column norms of block</span>
<a name="l00865"></a>00865   <span class="keywordtype">void</span> rownrms2(T* sum)
<a name="l00866"></a>00866   {
<a name="l00867"></a>00867     <span class="keywordflow">if</span> (isGeM()) {
<a name="l00868"></a>00868       assert(!isHeM() &amp;&amp; !isSyM() &amp;&amp; !isLtM() &amp;&amp; !isUtM());
<a name="l00869"></a>00869       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l00870"></a>00870         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) sum[i] += abs2(data[i+j*n1]);
<a name="l00871"></a>00871     } <span class="keywordflow">else</span> {
<a name="l00872"></a>00872 
<a name="l00873"></a>00873       T* skpV = <span class="keyword">new</span> T[bl_rank*(bl_rank+1)/2];
<a name="l00874"></a>00874       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00875"></a>00875         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1)
<a name="l00876"></a>00876           skpV[UTR(l1, l2)] = blas::scpr(n2, data+bl_rank*n1 + l2*n2,
<a name="l00877"></a>00877                                          data+bl_rank*n1 + l1*n2);
<a name="l00878"></a>00878       }
<a name="l00879"></a>00879 
<a name="l00880"></a>00880       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00881"></a>00881         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1) {
<a name="l00882"></a>00882           <span class="keyword">const</span> T e = skpV[UTR(l1, l2)];
<a name="l00883"></a>00883           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i)
<a name="l00884"></a>00884             sum[i] += Re(data[i+l1*n1]*conj(data[i+l2*n1])*e);
<a name="l00885"></a>00885         }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=l2+1; l1&lt;bl_rank; ++l1) {
<a name="l00888"></a>00888           <span class="keyword">const</span> T e = skpV[UTR(l2, l1)];
<a name="l00889"></a>00889           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i)
<a name="l00890"></a>00890             sum[i] += Re(data[i+l1*n1]*conj(data[i+l2*n1])*e);
<a name="l00891"></a>00891         }
<a name="l00892"></a>00892       }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894       <span class="keyword">delete</span> [] skpV;
<a name="l00895"></a>00895     }
<a name="l00896"></a>00896   }
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   <span class="keywordtype">void</span> colnrms2(T* sum)
<a name="l00899"></a>00899   {
<a name="l00900"></a>00900     <span class="keywordflow">if</span> (isGeM()) {
<a name="l00901"></a>00901       assert(!isHeM() &amp;&amp; !isSyM() &amp;&amp;!isLtM() &amp;&amp; !isUtM());
<a name="l00902"></a>00902       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l00903"></a>00903         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) sum[j] += abs2(data[i+j*n1]);
<a name="l00904"></a>00904     } <span class="keywordflow">else</span> {
<a name="l00905"></a>00905       T* skpU = <span class="keyword">new</span> T[bl_rank*(bl_rank+1)/2];
<a name="l00906"></a>00906       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00907"></a>00907         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1)
<a name="l00908"></a>00908           skpU[UTR(l1, l2)] = blas::scpr(n1, data + l2*n1, data + l1*n1);
<a name="l00909"></a>00909       }
<a name="l00910"></a>00910 
<a name="l00911"></a>00911       T* <span class="keyword">const</span> V = data + bl_rank*n1;
<a name="l00912"></a>00912       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00913"></a>00913         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1) {
<a name="l00914"></a>00914           <span class="keyword">const</span> T e = skpU[UTR(l1, l2)];
<a name="l00915"></a>00915           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l00916"></a>00916             sum[j] += Re(V[j+l1*n2]*conj(V[j+l2*n2])*e);
<a name="l00917"></a>00917         }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=l2+1; l1&lt;bl_rank; ++l1) {
<a name="l00920"></a>00920           <span class="keyword">const</span> T e = skpU[UTR(l2, l1)];
<a name="l00921"></a>00921           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l00922"></a>00922             sum[j] += Re(V[j+l1*n2]*conj(V[j+l2*n2])*e);
<a name="l00923"></a>00923         }
<a name="l00924"></a>00924       }
<a name="l00925"></a>00925       <span class="keyword">delete</span> [] skpU;
<a name="l00926"></a>00926     }
<a name="l00927"></a>00927   }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929  <span class="keywordtype">void</span> symnrms2(T* sum1, T* sum2)
<a name="l00930"></a>00930   {
<a name="l00931"></a>00931     <span class="keywordflow">if</span> (isGeM()) {
<a name="l00932"></a>00932       <span class="keywordflow">if</span> (isHeM()||isSyM()) {
<a name="l00933"></a>00933         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j) {
<a name="l00934"></a>00934           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;j; ++i) {
<a name="l00935"></a>00935             <span class="keyword">const</span> T e = abs2(data[UTR(i, j)]);
<a name="l00936"></a>00936             sum2[i] += e;
<a name="l00937"></a>00937             sum2[j] += e;
<a name="l00938"></a>00938           }
<a name="l00939"></a>00939           sum2[j] += abs2(data[UTR(j, j)]);
<a name="l00940"></a>00940         }
<a name="l00941"></a>00941       } <span class="keywordflow">else</span> {
<a name="l00942"></a>00942         assert(!isLtM() &amp;&amp; !isUtM());
<a name="l00943"></a>00943         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l00944"></a>00944           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) {
<a name="l00945"></a>00945             <span class="keyword">const</span> T d = abs2(data[i+j*n1]);
<a name="l00946"></a>00946             sum2[j] += d;
<a name="l00947"></a>00947             sum1[i] += d;
<a name="l00948"></a>00948           }
<a name="l00949"></a>00949       }
<a name="l00950"></a>00950     } <span class="keywordflow">else</span> {
<a name="l00951"></a>00951       T* skp = <span class="keyword">new</span> T[bl_rank*(bl_rank+1)/2];
<a name="l00952"></a>00952       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00953"></a>00953         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1)
<a name="l00954"></a>00954           skp[UTR(l1, l2)] = blas::scpr(n1, data + l2*n1, data + l1*n1);
<a name="l00955"></a>00955       }
<a name="l00956"></a>00956       
<a name="l00957"></a>00957       T* <span class="keyword">const</span> V = data+bl_rank*n1;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00960"></a>00960         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1) {
<a name="l00961"></a>00961           <span class="keyword">const</span> T e = skp[UTR(l1, l2)];
<a name="l00962"></a>00962           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l00963"></a>00963             sum2[j] += Re(V[j+l1*n2]*conj(V[j+l2*n2])*e);
<a name="l00964"></a>00964        }
<a name="l00965"></a>00965         
<a name="l00966"></a>00966         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=l2+1; l1&lt;bl_rank; ++l1) {
<a name="l00967"></a>00967           <span class="keyword">const</span> T e = skp[UTR(l2, l1)];
<a name="l00968"></a>00968           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l00969"></a>00969             sum2[j] += Re(V[j+l1*n2]*conj(V[j+l2*n2])*e);
<a name="l00970"></a>00970         }
<a name="l00971"></a>00971       }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00974"></a>00974         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1)
<a name="l00975"></a>00975           skp[UTR(l1, l2)] = blas::scpr(n2, V + l2*n2, V + l1*n2);
<a name="l00976"></a>00976       }
<a name="l00977"></a>00977       
<a name="l00978"></a>00978       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2=0; l2&lt;bl_rank; ++l2) {
<a name="l00979"></a>00979         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=0; l1&lt;=l2; ++l1) {
<a name="l00980"></a>00980           <span class="keyword">const</span> T e = skp[UTR(l1, l2)];
<a name="l00981"></a>00981           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i)
<a name="l00982"></a>00982             sum1[i] += Re(data[i+l1*n1]*conj(data[i+l2*n1])*e);
<a name="l00983"></a>00983         }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l1=l2+1; l1&lt;bl_rank; ++l1) {
<a name="l00986"></a>00986           <span class="keyword">const</span> T e = skp[UTR(l2, l1)];
<a name="l00987"></a>00987           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i)
<a name="l00988"></a>00988             sum1[i] += Re(data[i+l1*n1]*conj(data[i+l2*n1])*e);
<a name="l00989"></a>00989         }
<a name="l00990"></a>00990       }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992       <span class="keyword">delete</span> [] skp;
<a name="l00993"></a>00993     }
<a name="l00994"></a>00994   }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 
<a name="l00997"></a>00997   <span class="keywordtype">void</span> diag_sym(T* diag)
<a name="l00998"></a>00998   {
<a name="l00999"></a>00999     assert(isGeM() &amp;&amp; (isHeM()||isSyM()) );
<a name="l01000"></a>01000     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j) diag[j] = data[UTR(j, j)];
<a name="l01001"></a>01001   }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003   <span class="keywordtype">void</span> scale_cols(T* D)
<a name="l01004"></a>01004   {
<a name="l01005"></a>01005     <span class="keywordflow">if</span> (isGeM()) {
<a name="l01006"></a>01006       assert(!isHeM() &amp;&amp; !isSyM() &amp;&amp; !isLtM() &amp;&amp; !isUtM());
<a name="l01007"></a>01007       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j) blas::scal(n1, D[j], data+j*n1);
<a name="l01008"></a>01008     } <span class="keywordflow">else</span> {
<a name="l01009"></a>01009       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;bl_rank; ++l)
<a name="l01010"></a>01010         blas::scal(n2, data+bl_rank*n1+l*n2, D);
<a name="l01011"></a>01011     }
<a name="l01012"></a>01012   }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014   <span class="keywordtype">void</span> scale_rows(T* D)
<a name="l01015"></a>01015   {
<a name="l01016"></a>01016     <span class="keywordflow">if</span> (isGeM()) {
<a name="l01017"></a>01017       assert(!isHeM() &amp;&amp; !isSyM() &amp;&amp; !isLtM() &amp;&amp; !isUtM());
<a name="l01018"></a>01018       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l01019"></a>01019         blas::scal(n1, data+j*n1, D);
<a name="l01020"></a>01020     } <span class="keywordflow">else</span> {
<a name="l01021"></a>01021       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;bl_rank; ++l)
<a name="l01022"></a>01022         blas::scal(n1, data+l*n1, D);
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024   }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026   <span class="comment">// A -&gt; D_1 A D_2</span>
<a name="l01027"></a>01027   <span class="keywordtype">void</span> scale_sym(T* D1, T* D2)
<a name="l01028"></a>01028   {
<a name="l01029"></a>01029     <span class="keywordflow">if</span> (isGeM()) {
<a name="l01030"></a>01030       <span class="keywordflow">if</span> (isHeM() || isSyM() ) {
<a name="l01031"></a>01031         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l01032"></a>01032           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) data[UTR(i, j)] *= D1[i]*D2[j];
<a name="l01033"></a>01033       } <span class="keywordflow">else</span> {
<a name="l01034"></a>01034         assert(!isLtM() &amp;&amp; !isUtM());
<a name="l01035"></a>01035         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n2; ++j)
<a name="l01036"></a>01036           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n1; ++i) data[i+j*n1] *= D1[i]*D2[j];
<a name="l01037"></a>01037       }
<a name="l01038"></a>01038     } <span class="keywordflow">else</span> {
<a name="l01039"></a>01039       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;bl_rank; ++l)
<a name="l01040"></a>01040         blas::scal(n1, data+l*n1, D1);
<a name="l01041"></a>01041       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;bl_rank; ++l)
<a name="l01042"></a>01042         blas::scal(n2, data+bl_rank*n1+l*n2, D2);
<a name="l01043"></a>01043     }
<a name="l01044"></a>01044   }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046 
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <span class="keyword">private</span>:
<a name="l01049"></a>01049   <span class="keywordtype">void</span> copy_(mblock&lt;T&gt;&amp;);
<a name="l01050"></a>01050   <span class="keywordtype">void</span> copyH_(mblock&lt;T&gt;&amp;);
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <span class="keywordtype">void</span> initrnd_(mblock&lt;T&gt;&amp;);
<a name="l01053"></a>01053 
<a name="l01054"></a>01054   <span class="comment">// multiply lwr by vector y += d U V^H x, returns 1 if y has changed</span>
<a name="l01055"></a>01055   <span class="keywordtype">bool</span> mltaLrMVec_(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057   <span class="comment">// multiply herm transposed lwr by vector y += d V U^H x, returns 1 if y changed</span>
<a name="l01058"></a>01058   <span class="keywordtype">bool</span> mltaLrMhVec_(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l01059"></a>01059 
<a name="l01060"></a>01060  <span class="comment">// multiply transposed lwr by vector y += d (U V^H)^T x, returns 1 if y changed</span>
<a name="l01061"></a>01061   <span class="keywordtype">bool</span> mltaLrMtVec_(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063   <span class="comment">// multiply lwr by dense Y += d U V^H X, returns 1 if X has changed</span>
<a name="l01064"></a>01064   <span class="keywordtype">bool</span> mltaLrMGeM_(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l01065"></a>01065                       T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="comment">// multiply transposed lwr by vector Y += d V U^H X, returns 1 if X changed</span>
<a name="l01068"></a>01068   <span class="keywordtype">bool</span> mltaLrMhGeM_(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l01069"></a>01069                        T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l01070"></a>01070 
<a name="l01071"></a>01071   <span class="comment">// multiply herm. transposed lwr by vector Y += d (U V^H)^T X, returns 1 if X changed</span>
<a name="l01072"></a>01072   <span class="keywordtype">bool</span> mltaLrMtGeM_(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l01073"></a>01073                     T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l01074"></a>01074 
<a name="l01075"></a>01075   <span class="keywordtype">bool</span> mltaVec_(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l01076"></a>01076   <span class="keywordtype">bool</span> mltaGeM_(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l01077"></a>01077                   T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l01078"></a>01078   <span class="keywordtype">bool</span> mltahVec_(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l01079"></a>01079   <span class="keywordtype">bool</span> mltahGeM_(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l01080"></a>01080                    T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l01081"></a>01081   <span class="keywordtype">bool</span> mltatVec_(T d, T* x, T* y) <span class="keyword">const</span>;
<a name="l01082"></a>01082   <span class="keywordtype">bool</span> mltatGeM_(T d, <span class="keywordtype">unsigned</span> p, T* X, <span class="keywordtype">unsigned</span> ldX,
<a name="l01083"></a>01083                    T* Y, <span class="keywordtype">unsigned</span> ldY) <span class="keyword">const</span>;
<a name="l01084"></a>01084   <span class="keywordtype">double</span> nrmF2_() <span class="keyword">const</span>;
<a name="l01085"></a>01085   <span class="keywordtype">void</span> ltrh_solve_left_(<span class="keywordtype">unsigned</span>, T*, <span class="keywordtype">unsigned</span>) <span class="keyword">const</span>;
<a name="l01086"></a>01086 };
<a name="l01087"></a>01087 
<a name="l01088"></a>01088 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l01089"></a>01089 <span class="keywordtype">void</span> mblock&lt;T&gt;::psout_GeM(std::ostream&amp; os, <span class="keywordtype">unsigned</span> nmax,
<a name="l01090"></a>01090                           <span class="keywordtype">unsigned</span> b1, <span class="keywordtype">unsigned</span> b2, <span class="keywordtype">bool</span> refl)<span class="keyword"> const</span>
<a name="l01091"></a>01091 <span class="keyword"></span>{
<a name="l01092"></a>01092   assert(isGeM());
<a name="l01093"></a>01093 
<a name="l01094"></a>01094   <span class="keywordtype">double</span> no2, mo1, mo2;
<a name="l01095"></a>01095   mo1 = nmax-b1;
<a name="l01096"></a>01096 
<a name="l01097"></a>01097   <span class="keywordflow">if</span> (refl) {
<a name="l01098"></a>01098     no2 = b2+n1;
<a name="l01099"></a>01099     mo2 = mo1-n2;
<a name="l01100"></a>01100   } <span class="keywordflow">else</span> {
<a name="l01101"></a>01101     no2 = b2+n2;
<a name="l01102"></a>01102     mo2 = mo1-n1;
<a name="l01103"></a>01103   }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   os &lt;&lt; <span class="stringliteral">&quot;0.1 setlinewidth&quot;</span> &lt;&lt; std::endl;
<a name="l01106"></a>01106   os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; m&quot;</span> &lt;&lt; std::endl;
<a name="l01107"></a>01107   <span class="keywordflow">if</span> ((!(isHeM()||isSyM()) || refl) &amp;&amp; !isUtM())
<a name="l01108"></a>01108     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01109"></a>01109   os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01110"></a>01110   <span class="keywordflow">if</span> ((!(isHeM()||isSyM()) || !refl) &amp;&amp; !isLtM())
<a name="l01111"></a>01111     os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01112"></a>01112   os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01113"></a>01113   <span class="keywordflow">if</span> (refl) os &lt;&lt; <span class="stringliteral">&quot;flr&quot;</span>;
<a name="l01114"></a>01114   <span class="keywordflow">else</span> os &lt;&lt; <span class="stringliteral">&quot;fr&quot;</span>;
<a name="l01115"></a>01115   os &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;cs&quot;</span> &lt;&lt; std::endl;
<a name="l01116"></a>01116 
<a name="l01117"></a>01117   os &lt;&lt; <span class="stringliteral">&quot;bl&quot;</span> &lt;&lt; std::endl;
<a name="l01118"></a>01118   os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; m&quot;</span> &lt;&lt; std::endl;
<a name="l01119"></a>01119   <span class="keywordflow">if</span> (!(isHeM()||isSyM()) &amp;&amp; !isUtM()) {
<a name="l01120"></a>01120     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01121"></a>01121     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01122"></a>01122   }
<a name="l01123"></a>01123   <span class="keywordflow">if</span> (!isLtM()) os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01124"></a>01124   os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01125"></a>01125   os &lt;&lt; <span class="stringliteral">&quot;cs&quot;</span> &lt;&lt; std::endl;
<a name="l01126"></a>01126 }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l01131"></a>01131 <span class="keywordtype">void</span> mblock&lt;T&gt;::psout_LrM(std::ostream&amp; os, <span class="keywordtype">unsigned</span> nmax, <span class="keywordtype">unsigned</span> b1,
<a name="l01132"></a>01132                           <span class="keywordtype">unsigned</span> b2, <span class="keywordtype">bool</span> refl, <span class="keywordtype">unsigned</span> level, <a class="code" href="classcluster.html" title="the basis class for storing clusters of degrees of freedom">cluster</a>* cl1,
<a name="l01133"></a>01133                           <span class="keywordtype">void</span> (*f)(<a class="code" href="classcluster.html" title="the basis class for storing clusters of degrees of freedom">cluster</a>* cl, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lvl,
<a name="l01134"></a>01134                                     <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> basis))<span class="keyword"> const</span>
<a name="l01135"></a>01135 <span class="keyword"></span>{
<a name="l01136"></a>01136   assert(isLrM());
<a name="l01137"></a>01137   <span class="keywordtype">double</span> mo1 = nmax-b1, no2, mo2;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139   <span class="keywordflow">if</span> (refl) {
<a name="l01140"></a>01140     no2 = b2+n1;
<a name="l01141"></a>01141     mo2 = mo1-n2;
<a name="l01142"></a>01142   } <span class="keywordflow">else</span> {
<a name="l01143"></a>01143     no2 = b2+n2;
<a name="l01144"></a>01144     mo2 = mo1-n1;
<a name="l01145"></a>01145   }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> k = rank();
<a name="l01148"></a>01148   <span class="keywordtype">unsigned</span> cols = 0;
<a name="l01149"></a>01149   <span class="keywordtype">double</span>* val = NULL;
<a name="l01150"></a>01150   <span class="keywordtype">double</span>* basis = NULL;
<a name="l01151"></a>01151   <span class="keywordflow">if</span> (f!=NULL) {
<a name="l01152"></a>01152     cols = pow2(level);
<a name="l01153"></a>01153     val = <span class="keyword">new</span> <span class="keywordtype">double</span>[2*cols*cl1-&gt;size()];
<a name="l01154"></a>01154     f(cl1, level, val, basis);
<a name="l01155"></a>01155   }
<a name="l01156"></a>01156   <span class="comment">// parameter to adjust</span>
<a name="l01157"></a>01157   <span class="keyword">const</span> <span class="keywordtype">double</span> scal = 0.4/cols;
<a name="l01158"></a>01158   <span class="keyword">const</span> <span class="keywordtype">double</span> scalf = 0.3;
<a name="l01159"></a>01159   <span class="keyword">const</span> <span class="keywordtype">double</span> max_jump = 0.5;
<a name="l01160"></a>01160 
<a name="l01161"></a>01161   <span class="keywordflow">if</span> (k) {
<a name="l01162"></a>01162     os &lt;&lt; <span class="stringliteral">&quot;0.1 setlinewidth&quot;</span> &lt;&lt; std::endl;
<a name="l01163"></a>01163     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; m&quot;</span> &lt;&lt; std::endl;
<a name="l01164"></a>01164     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01165"></a>01165     os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01166"></a>01166     os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01167"></a>01167     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01168"></a>01168     <span class="keywordtype">unsigned</span> t;
<a name="l01169"></a>01169     <span class="keywordflow">if</span> (refl) {
<a name="l01170"></a>01170       t = n2;
<a name="l01171"></a>01171       os &lt;&lt; <span class="stringliteral">&quot;flg&quot;</span>;
<a name="l01172"></a>01172     } <span class="keywordflow">else</span> {
<a name="l01173"></a>01173       t = n1;
<a name="l01174"></a>01174       os &lt;&lt; <span class="stringliteral">&quot;fg&quot;</span>;
<a name="l01175"></a>01175     }
<a name="l01176"></a>01176     os &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;cs&quot;</span> &lt;&lt; std::endl;
<a name="l01177"></a>01177     <span class="keywordflow">if</span> (f!=NULL) {
<a name="l01178"></a>01178       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;cols; i++) {
<a name="l01179"></a>01179         os &lt;&lt; <span class="stringliteral">&quot;0.7 setgray&quot;</span> &lt;&lt; std::endl;
<a name="l01180"></a>01180         os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1-(i+1)*scal*t &lt;&lt; <span class="stringliteral">&quot; m&quot;</span> &lt;&lt; std::endl;
<a name="l01181"></a>01181         os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1-(i+1)*scal*t &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01182"></a>01182         os &lt;&lt; <span class="stringliteral">&quot;stroke&quot;</span> &lt;&lt; std::endl;
<a name="l01183"></a>01183         os &lt;&lt; <span class="stringliteral">&quot;fblue&quot;</span> &lt;&lt;std::endl;
<a name="l01184"></a>01184         os &lt;&lt; <span class="stringliteral">&quot;0.8 setlinewidth&quot;</span> &lt;&lt; std::endl;
<a name="l01185"></a>01185         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;cl1-&gt;size()-1; j++) {
<a name="l01186"></a>01186           <span class="keywordflow">if</span> (val[j+i*cl1-&gt;size()]!=0 &amp;&amp; val[j+1+i*cl1-&gt;size()]!=0 &amp;&amp;
<a name="l01187"></a>01187               std::abs(val[j+i*cl1-&gt;size()]-val[j+1+i*cl1-&gt;size()])&lt;max_jump) {
<a name="l01188"></a>01188             os &lt;&lt; b2+j+1 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1-((i+1)-val[j+i*cl1-&gt;size()]*scalf)*t*scal
<a name="l01189"></a>01189             &lt;&lt; <span class="stringliteral">&quot; m&quot;</span> &lt;&lt;std::endl;
<a name="l01190"></a>01190             os &lt;&lt; b2+j+2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1-((i+1)-val[j+1+i*cl1-&gt;size()]*scalf)*t*scal
<a name="l01191"></a>01191             &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt;std::endl;
<a name="l01192"></a>01192             os &lt;&lt; <span class="stringliteral">&quot;stroke&quot;</span> &lt;&lt; std::endl;
<a name="l01193"></a>01193           }
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195         os &lt;&lt; <span class="stringliteral">&quot;0.1 setlinewidth&quot;</span> &lt;&lt; std::endl;
<a name="l01196"></a>01196       }
<a name="l01197"></a>01197     }
<a name="l01198"></a>01198     os &lt;&lt; <span class="stringliteral">&quot;0 setgray&quot;</span> &lt;&lt; std::endl;
<a name="l01199"></a>01199     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; m&quot;</span> &lt;&lt; std::endl;
<a name="l01200"></a>01200     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01201"></a>01201     os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo1 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01202"></a>01202     os &lt;&lt; no2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01203"></a>01203     os &lt;&lt; b2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2 &lt;&lt; <span class="stringliteral">&quot; l&quot;</span> &lt;&lt; std::endl;
<a name="l01204"></a>01204     os &lt;&lt; <span class="stringliteral">&quot;cs&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;hf &quot;</span> &lt;&lt; 0.5*MIN(n1,n2) &lt;&lt; <span class="stringliteral">&quot; sf&quot;</span> &lt;&lt; std::endl;
<a name="l01205"></a>01205     <span class="comment">//os &lt;&lt; &quot;cs&quot; &lt;&lt; std::endl &lt;&lt; &quot;hf &quot; &lt;&lt; 0.3*MIN(n1,n2) &lt;&lt; &quot; sf&quot; &lt;&lt; std::endl;</span>
<a name="l01206"></a>01206     os &lt;&lt; b2+0.1*n2 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; mo2+0.1*n1 &lt;&lt; <span class="stringliteral">&quot; m (&quot;</span>
<a name="l01207"></a>01207     &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <span class="stringliteral">&quot;) show&quot;</span> &lt;&lt; std::endl;
<a name="l01208"></a>01208   }
<a name="l01209"></a>01209   <span class="keyword">delete</span> [] val;
<a name="l01210"></a>01210 }
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 <span class="preprocessor">#endif  // MBLOCK_H</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 11 2012 16:50:22 for AHMED by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
