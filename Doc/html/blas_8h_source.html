<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AHMED: blas.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">AHMED
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">blas.h</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef BLAS_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define BLAS_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;cmplx.h&quot;</span>    <span class="comment">// Complex arthimetic</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#define SIGN(a) ((a) &gt;= 0 ? 1.0 : -1.0)</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#define SQR(a) ((a)*(a))                             // Quadrat von a</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">double</span> abs2(<span class="keywordtype">double</span> a)
<a name="l00011"></a>00011 {
<a name="l00012"></a>00012   <span class="keywordflow">return</span> SQR(a);
<a name="l00013"></a>00013 }
<a name="l00014"></a>00014 <span class="keyword">inline</span> <span class="keywordtype">double</span> abs2(<span class="keywordtype">float</span> a)
<a name="l00015"></a>00015 {
<a name="l00016"></a>00016   <span class="keywordflow">return</span> SQR(a);
<a name="l00017"></a>00017 }
<a name="l00018"></a>00018 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">double</span> abs(<span class="keywordtype">double</span> a)
<a name="l00020"></a>00020 {
<a name="l00021"></a>00021   <span class="keywordflow">return</span> fabs(a);
<a name="l00022"></a>00022 }
<a name="l00023"></a>00023 <span class="keyword">inline</span> <span class="keywordtype">float</span> abs(<span class="keywordtype">float</span> a)
<a name="l00024"></a>00024 {
<a name="l00025"></a>00025   <span class="keywordflow">return</span> fabsf(a);
<a name="l00026"></a>00026 }
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifndef MIN</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#ifndef MAX</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> LTR(<span class="keywordtype">unsigned</span> i, <span class="keywordtype">unsigned</span> j, <span class="keywordtype">unsigned</span> n)
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038   <span class="keywordflow">return</span> ((2*n-j-1)*j)/2+i;
<a name="l00039"></a>00039 }
<a name="l00040"></a>00040 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> UTR(<span class="keywordtype">unsigned</span> i, <span class="keywordtype">unsigned</span> j)
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042   <span class="keywordflow">return</span> (j*(j+1))/2+i;
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> GE(<span class="keywordtype">unsigned</span> i, <span class="keywordtype">unsigned</span> j, <span class="keywordtype">unsigned</span> n)
<a name="l00045"></a>00045 {
<a name="l00046"></a>00046   <span class="keywordflow">return</span> i+j*n;
<a name="l00047"></a>00047 }
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keyword">const</span> <span class="keywordtype">double</span> D_ZERO =  0.0;
<a name="l00050"></a>00050 <span class="keyword">const</span> <span class="keywordtype">double</span> D_ONE  =  1.0;
<a name="l00051"></a>00051 <span class="keyword">const</span> <span class="keywordtype">double</span> D_MONE = -1.0;
<a name="l00052"></a>00052 <span class="keyword">const</span> <span class="keywordtype">float</span> S_ZERO  =  0.0;
<a name="l00053"></a>00053 <span class="keyword">const</span> <span class="keywordtype">float</span> S_ONE   =  1.0;
<a name="l00054"></a>00054 <span class="keyword">const</span> <span class="keywordtype">float</span> S_MONE  = -1.0;
<a name="l00055"></a>00055 <span class="keyword">const</span> scomp C_ZERO  = 0.0;
<a name="l00056"></a>00056 <span class="keyword">const</span> scomp C_ONE   = 1.0;
<a name="l00057"></a>00057 <span class="keyword">const</span> scomp C_MONE  = -1.0;
<a name="l00058"></a>00058 <span class="keyword">const</span> dcomp Z_ZERO  = 0.0;
<a name="l00059"></a>00059 <span class="keyword">const</span> dcomp Z_ONE   = 1.0;
<a name="l00060"></a>00060 <span class="keyword">const</span> dcomp Z_MONE  = -1.0;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">const</span> <span class="keywordtype">double</span> D_PREC = 1e-16;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> N_ONE = 1;
<a name="l00065"></a>00065 <span class="keyword">const</span> <span class="keywordtype">int</span> N_MONE = -1;
<a name="l00066"></a>00066 <span class="keyword">const</span> <span class="keywordtype">char</span> JOB_STR[] = <span class="stringliteral">&quot;NTOSVULCRAF&quot;</span>;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/*</span>
<a name="l00070"></a>00070 <span class="comment">  #ifdef WIN32</span>
<a name="l00071"></a>00071 <span class="comment">  #define dcopy_ dcopy</span>
<a name="l00072"></a>00072 <span class="comment">  #define dnrm2_ dnrm2</span>
<a name="l00073"></a>00073 <span class="comment">  #define dgemv_ dgemv</span>
<a name="l00074"></a>00074 <span class="comment">  #define dspmv_ dspmv</span>
<a name="l00075"></a>00075 <span class="comment">  #define dtpmv_ dtpmv</span>
<a name="l00076"></a>00076 <span class="comment">  #define dgemm_ dgemm</span>
<a name="l00077"></a>00077 <span class="comment">  #define daxpy_ daxpy</span>
<a name="l00078"></a>00078 <span class="comment">  #define ddot_ ddot</span>
<a name="l00079"></a>00079 <span class="comment">  #define dscal_ dscal</span>
<a name="l00080"></a>00080 <span class="comment">  #define dgesvd_ dgesvd</span>
<a name="l00081"></a>00081 <span class="comment">  #define dgeqrf_ dgeqrf</span>
<a name="l00082"></a>00082 <span class="comment">  #define dormqr_ dormqr</span>
<a name="l00083"></a>00083 <span class="comment">  #define dorgqr_ dorgqr</span>
<a name="l00084"></a>00084 <span class="comment">  #define dgetri_ dgetri</span>
<a name="l00085"></a>00085 <span class="comment">  #define dgetrf_ dgetrf</span>
<a name="l00086"></a>00086 <span class="comment">  #define dsptri_ dsptri</span>
<a name="l00087"></a>00087 <span class="comment">  #define dsptrf_ dsptrf</span>
<a name="l00088"></a>00088 <span class="comment">  #define dtptrs_ dtptrs</span>
<a name="l00089"></a>00089 <span class="comment">  #define dpptrf_ dpptrf</span>
<a name="l00090"></a>00090 <span class="comment">  #define dsytrf_ dsytrf</span>
<a name="l00091"></a>00091 <span class="comment">  #define scopy_ scopy</span>
<a name="l00092"></a>00092 <span class="comment">  #define snrm2_ snrm2</span>
<a name="l00093"></a>00093 <span class="comment">  #define sgemv_ sgemv</span>
<a name="l00094"></a>00094 <span class="comment">  #define sspmv_ sspmv</span>
<a name="l00095"></a>00095 <span class="comment">  #define stpmv_ stpmv</span>
<a name="l00096"></a>00096 <span class="comment">  #define sgemm_ sgemm</span>
<a name="l00097"></a>00097 <span class="comment">  #define saxpy_ saxpy</span>
<a name="l00098"></a>00098 <span class="comment">  #define sdot_ sdot</span>
<a name="l00099"></a>00099 <span class="comment">  #define sscal_ sscal</span>
<a name="l00100"></a>00100 <span class="comment">  #define sgesvd_ sgesvd</span>
<a name="l00101"></a>00101 <span class="comment">  #define sgeqrf_ sgeqrf</span>
<a name="l00102"></a>00102 <span class="comment">  #define sormqr_ sormqr</span>
<a name="l00103"></a>00103 <span class="comment">  #define sorgqr_ sorgqr</span>
<a name="l00104"></a>00104 <span class="comment">  #define sgetri_ sgetri</span>
<a name="l00105"></a>00105 <span class="comment">  #define sgetrf_ sgetrf</span>
<a name="l00106"></a>00106 <span class="comment">  #define ssptri_ ssptri</span>
<a name="l00107"></a>00107 <span class="comment">  #define ssptrf_ ssptrf</span>
<a name="l00108"></a>00108 <span class="comment">  #define stptrs_ stptrs</span>
<a name="l00109"></a>00109 <span class="comment">  #define spptrf_ spptrf</span>
<a name="l00110"></a>00110 <span class="comment">  #define ssytrf_ ssytrf</span>
<a name="l00111"></a>00111 <span class="comment">  #define ccopy_ ccopy</span>
<a name="l00112"></a>00112 <span class="comment">  #define scnrm2_ scnrm2</span>
<a name="l00113"></a>00113 <span class="comment">  #define cgemv_ cgemv</span>
<a name="l00114"></a>00114 <span class="comment">  #define chpmv_ chpmv</span>
<a name="l00115"></a>00115 <span class="comment">  #define ctpmv_ ctpmv</span>
<a name="l00116"></a>00116 <span class="comment">  #define cgemm_ cgemm</span>
<a name="l00117"></a>00117 <span class="comment">  #define caxpy_ caxpy</span>
<a name="l00118"></a>00118 <span class="comment">  #define cdotc_ cdotc</span>
<a name="l00119"></a>00119 <span class="comment">  #define cdotu_ cdotu</span>
<a name="l00120"></a>00120 <span class="comment">  #define cscal_ cscal</span>
<a name="l00121"></a>00121 <span class="comment">  #define cspmv_ cspmv</span>
<a name="l00122"></a>00122 <span class="comment">  #define cgesvd_ cgesvd</span>
<a name="l00123"></a>00123 <span class="comment">  #define cgeqrf_ cgeqrf</span>
<a name="l00124"></a>00124 <span class="comment">  #define cunmqr_ cunmqr</span>
<a name="l00125"></a>00125 <span class="comment">  #define cungqr_ cungqr</span>
<a name="l00126"></a>00126 <span class="comment">  #define cgetri_ cgetri</span>
<a name="l00127"></a>00127 <span class="comment">  #define cgetrf_ cgetrf</span>
<a name="l00128"></a>00128 <span class="comment">  #define chetrf_ chetrf</span>
<a name="l00129"></a>00129 <span class="comment">  #define chptri_ chptri</span>
<a name="l00130"></a>00130 <span class="comment">  #define chptrf_ chptrf</span>
<a name="l00131"></a>00131 <span class="comment">  #define csptri_ csptri</span>
<a name="l00132"></a>00132 <span class="comment">  #define csptrf_ csptrf</span>
<a name="l00133"></a>00133 <span class="comment">  #define ctptrs_ ctptrs</span>
<a name="l00134"></a>00134 <span class="comment">  #define cpptrf_ cpptr</span>
<a name="l00135"></a>00135 <span class="comment">  #define csytrf_ csytrf</span>
<a name="l00136"></a>00136 <span class="comment">  #define zcopy_ zcopy</span>
<a name="l00137"></a>00137 <span class="comment">  #define dznrm2_ dznrm2</span>
<a name="l00138"></a>00138 <span class="comment">  #define zgemv_ zgemv</span>
<a name="l00139"></a>00139 <span class="comment">  #define zhpmv_ zhpmv</span>
<a name="l00140"></a>00140 <span class="comment">  #define ztpmv_ ztpmv</span>
<a name="l00141"></a>00141 <span class="comment">  #define zgemm_ zgemm</span>
<a name="l00142"></a>00142 <span class="comment">  #define zaxpy_ zaxpy</span>
<a name="l00143"></a>00143 <span class="comment">  #define zdotc_ zdotc</span>
<a name="l00144"></a>00144 <span class="comment">  #define zdotu_ zdotu</span>
<a name="l00145"></a>00145 <span class="comment">  #define zscal_ zscal</span>
<a name="l00146"></a>00146 <span class="comment">  #define zgesvd_ zgesvd</span>
<a name="l00147"></a>00147 <span class="comment">  #define zgeqrf_ zgeqrf</span>
<a name="l00148"></a>00148 <span class="comment">  #define zunmqr_ zunmqr</span>
<a name="l00149"></a>00149 <span class="comment">  #define zungqr_ zungqr</span>
<a name="l00150"></a>00150 <span class="comment">  #define zgetri_ zgetri</span>
<a name="l00151"></a>00151 <span class="comment">  #define zgetrf_ zgetrf</span>
<a name="l00152"></a>00152 <span class="comment">  #define zhetrf_ zhetrf</span>
<a name="l00153"></a>00153 <span class="comment">  #define zhptri_ zhptri</span>
<a name="l00154"></a>00154 <span class="comment">  #define zhptrf_ zhptrf</span>
<a name="l00155"></a>00155 <span class="comment">  #define zsptri_ zsptri</span>
<a name="l00156"></a>00156 <span class="comment">  #define zsptrf_ zsptrf</span>
<a name="l00157"></a>00157 <span class="comment">  #define ztptrs_ ztptrs</span>
<a name="l00158"></a>00158 <span class="comment">  #define zpptrf_ zpptrf</span>
<a name="l00159"></a>00159 <span class="comment">  #define zspmv_ zspmv</span>
<a name="l00160"></a>00160 <span class="comment">  #define zsytrf_ zsytrf</span>
<a name="l00161"></a>00161 <span class="comment">  #endif</span>
<a name="l00162"></a>00162 <span class="comment">*/</span>
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00166"></a>00166   <span class="comment">/******************************************************************/</span>
<a name="l00167"></a>00167   <span class="comment">//double precision real</span>
<a name="l00168"></a>00168   <span class="comment">/******************************************************************/</span>
<a name="l00169"></a>00169   <span class="keywordtype">unsigned</span> idamax_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00170"></a>00170   <span class="keywordtype">void</span> dcopy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00171"></a>00171               <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00172"></a>00172   <span class="keywordtype">void</span> daxpy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00173"></a>00173               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00174"></a>00174   <span class="keywordtype">void</span> dscal_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00175"></a>00175               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00176"></a>00176   <span class="keywordtype">double</span> ddot_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00177"></a>00177                <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00178"></a>00178   <span class="keywordtype">double</span> dnrm2_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   <span class="keywordtype">void</span> dgtsv_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00181"></a>00181               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00182"></a>00182               <span class="keyword">const</span> <span class="keywordtype">int</span>*);
<a name="l00183"></a>00183   <span class="keywordtype">void</span> dgemm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00184"></a>00184               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00185"></a>00185               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*,
<a name="l00186"></a>00186               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00187"></a>00187   <span class="keywordtype">void</span> dger_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00188"></a>00188              <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00189"></a>00189              <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00190"></a>00190   <span class="keywordtype">void</span> dgemv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00191"></a>00191               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00192"></a>00192               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00193"></a>00193   <span class="keywordtype">void</span> dorgqr_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00194"></a>00194                <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*,
<a name="l00195"></a>00195                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00196"></a>00196   <span class="keywordtype">void</span> dormqr_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00197"></a>00197                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*,
<a name="l00198"></a>00198                <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00199"></a>00199                <span class="keywordtype">int</span>*);
<a name="l00200"></a>00200   <span class="keywordtype">void</span> dsyev_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*,
<a name="l00201"></a>00201               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00202"></a>00202   <span class="keywordtype">void</span> dgeqrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00203"></a>00203                <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00204"></a>00204   <span class="keywordtype">void</span> dgeqp3_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00205"></a>00205                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00206"></a>00206                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00207"></a>00207   <span class="keywordtype">void</span> dgeqp3trunc_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00208"></a>00208                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, 
<a name="l00209"></a>00209                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00210"></a>00210                     <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00211"></a>00211   <span class="keywordtype">void</span> dgeqpf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00212"></a>00212                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00213"></a>00213                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00214"></a>00214   <span class="keywordtype">void</span> dgesvd_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00215"></a>00215                <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00216"></a>00216                <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00217"></a>00217   <span class="keywordtype">void</span> dgetrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00218"></a>00218                <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00219"></a>00219   <span class="keywordtype">void</span> dgetrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*,
<a name="l00220"></a>00220                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00221"></a>00221                <span class="keywordtype">int</span>*);
<a name="l00222"></a>00222   <span class="keywordtype">void</span> dgetri_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*,
<a name="l00223"></a>00223                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00224"></a>00224   <span class="keywordtype">void</span> dspmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00225"></a>00225               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00226"></a>00226               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00227"></a>00227   <span class="keywordtype">void</span> dsptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00228"></a>00228   <span class="keywordtype">void</span> dsptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">int</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">int</span>*);
<a name="l00229"></a>00229   <span class="keywordtype">void</span> dpotrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00230"></a>00230                <span class="keywordtype">int</span>*);
<a name="l00231"></a>00231   <span class="keywordtype">void</span> dpotri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00232"></a>00232                <span class="keywordtype">int</span>*);
<a name="l00233"></a>00233   <span class="keywordtype">void</span> dpptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">int</span>*);
<a name="l00234"></a>00234   <span class="keywordtype">void</span> dpptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">int</span>*);
<a name="l00235"></a>00235   <span class="keywordtype">void</span> dtptrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00236"></a>00236                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*,
<a name="l00237"></a>00237                <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00238"></a>00238                <span class="keywordtype">int</span>*);
<a name="l00239"></a>00239   <span class="keywordtype">void</span> dtpsv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00240"></a>00240               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00241"></a>00241   <span class="keywordtype">void</span> dtrtrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00242"></a>00242                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00243"></a>00243                <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00244"></a>00244   <span class="keywordtype">void</span> dtrsm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00245"></a>00245               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00246"></a>00246               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00247"></a>00247   <span class="keywordtype">void</span> dtpmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00248"></a>00248               <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00249"></a>00249   <span class="keywordtype">void</span> dlacpy_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00250"></a>00250                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00251"></a>00251   <span class="keywordtype">void</span> dlaset_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00252"></a>00252                <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00253"></a>00253   <span class="keywordtype">void</span> dtrmm_(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l00254"></a>00254               <span class="keywordtype">unsigned</span> *, <span class="keywordtype">unsigned</span> *, <span class="keyword">const</span> <span class="keywordtype">double</span> *, <span class="keywordtype">double</span> *, <span class="keywordtype">unsigned</span> *,
<a name="l00255"></a>00255               <span class="keywordtype">double</span> *, <span class="keywordtype">unsigned</span> *);
<a name="l00256"></a>00256   <span class="keywordtype">void</span> dswap_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*,
<a name="l00257"></a>00257               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00258"></a>00258   <span class="keywordtype">void</span> dsytrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00259"></a>00259                <span class="keywordtype">int</span>*, <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00260"></a>00260   <span class="keywordtype">void</span> dlarfg_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00261"></a>00261                <span class="keyword">const</span> <span class="keywordtype">double</span>*);
<a name="l00262"></a>00262   <span class="keywordtype">void</span> dlarfb_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00263"></a>00263                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00264"></a>00264                <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l00265"></a>00265                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00266"></a>00266                <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268   <span class="comment">/******************************************************************/</span>
<a name="l00269"></a>00269   <span class="comment">//single precision real</span>
<a name="l00270"></a>00270   <span class="comment">/******************************************************************/</span>
<a name="l00271"></a>00271   <span class="keywordtype">unsigned</span> isamax_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00272"></a>00272   <span class="keywordtype">void</span> scopy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00273"></a>00273               <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00274"></a>00274   <span class="keywordtype">void</span> saxpy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00275"></a>00275               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00276"></a>00276   <span class="keywordtype">void</span> sscal_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00277"></a>00277               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00278"></a>00278   <span class="keywordtype">float</span> sdot_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00279"></a>00279               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00280"></a>00280   <span class="keywordtype">float</span> snrm2_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   <span class="keywordtype">void</span> sgtsv_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00283"></a>00283               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00284"></a>00284               <span class="keyword">const</span> <span class="keywordtype">int</span>*);
<a name="l00285"></a>00285   <span class="keywordtype">void</span> sgemm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00286"></a>00286               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00287"></a>00287               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*,
<a name="l00288"></a>00288               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00289"></a>00289   <span class="keywordtype">void</span> sger_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00290"></a>00290              <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00291"></a>00291              <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00292"></a>00292   <span class="keywordtype">void</span> sgemv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00293"></a>00293               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00294"></a>00294               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00295"></a>00295   <span class="keywordtype">void</span> sorgqr_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00296"></a>00296                <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*,
<a name="l00297"></a>00297                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00298"></a>00298   <span class="keywordtype">void</span> sormqr_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00299"></a>00299                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*,
<a name="l00300"></a>00300                <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00301"></a>00301                <span class="keywordtype">int</span>*);
<a name="l00302"></a>00302   <span class="keywordtype">void</span> ssyev_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*,
<a name="l00303"></a>00303               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00304"></a>00304   <span class="keywordtype">void</span> stpsv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00305"></a>00305               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00306"></a>00306   <span class="keywordtype">void</span> sgeqrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00307"></a>00307                <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00308"></a>00308   <span class="keywordtype">void</span> sgesvd_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00309"></a>00309                <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00310"></a>00310                <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00311"></a>00311   <span class="keywordtype">void</span> sgetrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00312"></a>00312                <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00313"></a>00313   <span class="keywordtype">void</span> sgetri_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*,
<a name="l00314"></a>00314                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00315"></a>00315   <span class="keywordtype">void</span> sspmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00316"></a>00316               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00317"></a>00317               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00318"></a>00318   <span class="keywordtype">void</span> strsm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00319"></a>00319               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00320"></a>00320               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00321"></a>00321   <span class="keywordtype">void</span> ssptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00322"></a>00322   <span class="keywordtype">void</span> ssptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*);
<a name="l00323"></a>00323   <span class="keywordtype">void</span> spotrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00324"></a>00324                <span class="keywordtype">int</span>*);
<a name="l00325"></a>00325   <span class="keywordtype">void</span> spotri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00326"></a>00326                <span class="keywordtype">int</span>*);
<a name="l00327"></a>00327   <span class="keywordtype">void</span> spptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*);
<a name="l00328"></a>00328   <span class="keywordtype">void</span> spptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*);
<a name="l00329"></a>00329   <span class="keywordtype">void</span> stptrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00330"></a>00330                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00331"></a>00331   <span class="keywordtype">void</span> strtrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00332"></a>00332                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00333"></a>00333                <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00334"></a>00334   <span class="keywordtype">void</span> stpmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00335"></a>00335               <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00336"></a>00336   <span class="keywordtype">void</span> slacpy_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00337"></a>00337                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00338"></a>00338   <span class="keywordtype">void</span> sswap_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*,
<a name="l00339"></a>00339               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00340"></a>00340   <span class="keywordtype">void</span> ssytrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00341"></a>00341                <span class="keywordtype">int</span>*, <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00342"></a>00342   <span class="keywordtype">void</span> slarfg_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00343"></a>00343                <span class="keyword">const</span> <span class="keywordtype">float</span>*);
<a name="l00344"></a>00344   <span class="keywordtype">void</span> slarfb_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00345"></a>00345                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00346"></a>00346                <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*,
<a name="l00347"></a>00347                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00348"></a>00348                <span class="keyword">const</span> <span class="keywordtype">float</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="comment">/******************************************************************/</span>
<a name="l00351"></a>00351   <span class="comment">//single precision complex</span>
<a name="l00352"></a>00352   <span class="comment">/******************************************************************/</span>
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   <span class="keywordtype">void</span> ccopy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00355"></a>00355               scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00356"></a>00356   <span class="keywordtype">void</span> caxpy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*,
<a name="l00357"></a>00357               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00358"></a>00358   <span class="keywordtype">void</span> cscal_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*,
<a name="l00359"></a>00359               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00360"></a>00360 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>  <span class="keywordtype">void</span> cdotc_(scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00362"></a>00362               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00363"></a>00363   <span class="keywordtype">void</span> cdotu_(scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00364"></a>00364               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00365"></a>00365 <span class="preprocessor">#else</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>  scomp cdotc_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00367"></a>00367               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00368"></a>00368   scomp cdotu_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00369"></a>00369               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00370"></a>00370 <span class="preprocessor">#endif</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span>
<a name="l00372"></a>00372   <span class="keywordtype">float</span> scnrm2_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp* <span class="keyword">const</span>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374   <span class="keywordtype">void</span> cgtsv_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*,
<a name="l00375"></a>00375               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00376"></a>00376               <span class="keyword">const</span> <span class="keywordtype">int</span>*);
<a name="l00377"></a>00377   <span class="keywordtype">void</span> cgemm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00378"></a>00378               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00379"></a>00379               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, scomp*,
<a name="l00380"></a>00380               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00381"></a>00381   <span class="keywordtype">void</span> cgerc_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*,
<a name="l00382"></a>00382               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*,
<a name="l00383"></a>00383               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00384"></a>00384   <span class="keywordtype">void</span> cgemv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*,
<a name="l00385"></a>00385               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00386"></a>00386               <span class="keyword">const</span> scomp*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00387"></a>00387   <span class="keywordtype">void</span> cungqr_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00388"></a>00388                scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, scomp*,
<a name="l00389"></a>00389                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00390"></a>00390   <span class="keywordtype">void</span> cunmqr_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00391"></a>00391                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*,
<a name="l00392"></a>00392                scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00393"></a>00393                <span class="keywordtype">int</span>*);
<a name="l00394"></a>00394   <span class="keywordtype">void</span> cheev_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*,
<a name="l00395"></a>00395               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*);
<a name="l00396"></a>00396   <span class="keywordtype">void</span> ctpsv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00397"></a>00397               <span class="keyword">const</span> scomp*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00398"></a>00398   <span class="keywordtype">void</span> ctrsm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00399"></a>00399               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*,
<a name="l00400"></a>00400               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00401"></a>00401   <span class="keywordtype">void</span> cgeqrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00402"></a>00402                scomp*, scomp*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00403"></a>00403   <span class="keywordtype">void</span> cgesvd_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00404"></a>00404                scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00405"></a>00405                scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">float</span>*, <span class="keywordtype">int</span>*);
<a name="l00406"></a>00406   <span class="keywordtype">void</span> cgetrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00407"></a>00407                <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00408"></a>00408   <span class="keywordtype">void</span> cgetri_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">unsigned</span>*, scomp*,
<a name="l00409"></a>00409                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00410"></a>00410   <span class="keywordtype">void</span> chetrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00411"></a>00411                <span class="keywordtype">int</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00412"></a>00412   <span class="keywordtype">void</span> chpmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*,
<a name="l00413"></a>00413               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00414"></a>00414               <span class="keyword">const</span> scomp*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00415"></a>00415   <span class="keywordtype">void</span> chptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keywordtype">int</span>*, scomp*, <span class="keywordtype">int</span>*);
<a name="l00416"></a>00416   <span class="keywordtype">void</span> chptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00417"></a>00417   <span class="keywordtype">void</span> csptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00418"></a>00418   <span class="keywordtype">void</span> csptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keywordtype">int</span>*, scomp*, <span class="keywordtype">int</span>*);
<a name="l00419"></a>00419   <span class="keywordtype">void</span> cpotrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00420"></a>00420                <span class="keywordtype">int</span>*);
<a name="l00421"></a>00421   <span class="keywordtype">void</span> cpotri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00422"></a>00422                <span class="keywordtype">int</span>*);
<a name="l00423"></a>00423   <span class="keywordtype">void</span> cpptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keywordtype">int</span>*);
<a name="l00424"></a>00424   <span class="keywordtype">void</span> cpptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keywordtype">int</span>*);
<a name="l00425"></a>00425   <span class="keywordtype">void</span> cspmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*,
<a name="l00426"></a>00426               <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00427"></a>00427               <span class="keyword">const</span> scomp*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00428"></a>00428   <span class="keywordtype">void</span> cswap_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*,
<a name="l00429"></a>00429               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00430"></a>00430   <span class="keywordtype">void</span> csytrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00431"></a>00431                <span class="keywordtype">int</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00432"></a>00432   <span class="keywordtype">void</span> ctptrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00433"></a>00433                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00434"></a>00434   <span class="keywordtype">void</span> ctrtrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00435"></a>00435                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00436"></a>00436                scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00437"></a>00437   <span class="keywordtype">void</span> ctpmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00438"></a>00438               <span class="keyword">const</span> scomp*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00439"></a>00439   <span class="keywordtype">void</span> clacpy_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*,
<a name="l00440"></a>00440                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00441"></a>00441  
<a name="l00442"></a>00442   <span class="keywordtype">void</span> clarfg_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00443"></a>00443                <span class="keyword">const</span> scomp*);
<a name="l00444"></a>00444   <span class="keywordtype">void</span> clarfb_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00445"></a>00445                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00446"></a>00446                <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*,
<a name="l00447"></a>00447                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00448"></a>00448                <span class="keyword">const</span> scomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00449"></a>00449 
<a name="l00450"></a>00450   <span class="comment">/******************************************************************/</span>
<a name="l00451"></a>00451   <span class="comment">//double precision complex</span>
<a name="l00452"></a>00452   <span class="comment">/******************************************************************/</span>
<a name="l00453"></a>00453   <span class="keywordtype">void</span> zcopy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00454"></a>00454               dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00455"></a>00455   <span class="keywordtype">void</span> zaxpy_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*,
<a name="l00456"></a>00456               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00457"></a>00457   <span class="keywordtype">void</span> zscal_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*,
<a name="l00458"></a>00458               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00459"></a>00459 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>  <span class="keywordtype">void</span> zdotc_(dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00461"></a>00461               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00462"></a>00462   <span class="keywordtype">void</span> zdotu_(dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00463"></a>00463               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00464"></a>00464 <span class="preprocessor">#else</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span>  dcomp zdotc_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00466"></a>00466               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00467"></a>00467   dcomp zdotu_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00468"></a>00468               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00469"></a>00469 <span class="preprocessor">#endif</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span>
<a name="l00471"></a>00471   <span class="keywordtype">double</span> dznrm2_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp* <span class="keyword">const</span>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   <span class="keywordtype">void</span> zgtsv_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*,
<a name="l00474"></a>00474               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00475"></a>00475               <span class="keyword">const</span> <span class="keywordtype">int</span>*);
<a name="l00476"></a>00476   <span class="keywordtype">void</span> zgemm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00477"></a>00477               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00478"></a>00478               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, dcomp*,
<a name="l00479"></a>00479               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00480"></a>00480   <span class="keywordtype">void</span> zgerc_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*,
<a name="l00481"></a>00481               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*,
<a name="l00482"></a>00482               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00483"></a>00483   <span class="keywordtype">void</span> zgemv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*,
<a name="l00484"></a>00484               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00485"></a>00485               <span class="keyword">const</span> dcomp*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00486"></a>00486   <span class="keywordtype">void</span> zungqr_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00487"></a>00487                dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, dcomp*,
<a name="l00488"></a>00488                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00489"></a>00489   <span class="keywordtype">void</span> zunmqr_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00490"></a>00490                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*,
<a name="l00491"></a>00491                dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00492"></a>00492                <span class="keywordtype">int</span>*);
<a name="l00493"></a>00493   <span class="keywordtype">void</span> zheev_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*,
<a name="l00494"></a>00494               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, <span class="keywordtype">int</span>*);
<a name="l00495"></a>00495   <span class="keywordtype">void</span> ztpsv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00496"></a>00496               <span class="keyword">const</span> dcomp*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00497"></a>00497   <span class="keywordtype">void</span> zgeqrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00498"></a>00498                dcomp*, dcomp*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00499"></a>00499   <span class="keywordtype">void</span> zgesvd_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00500"></a>00500                dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00501"></a>00501                dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">double</span>*,
<a name="l00502"></a>00502                <span class="keywordtype">int</span>*);
<a name="l00503"></a>00503   <span class="keywordtype">void</span> zgetrf_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00504"></a>00504                <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00505"></a>00505   <span class="keywordtype">void</span> zgetri_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">unsigned</span>*, dcomp*,
<a name="l00506"></a>00506                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00507"></a>00507   <span class="keywordtype">void</span> zhetrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00508"></a>00508                <span class="keywordtype">int</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00509"></a>00509   <span class="keywordtype">void</span> zhpmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*,
<a name="l00510"></a>00510               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00511"></a>00511               <span class="keyword">const</span> dcomp*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00512"></a>00512   <span class="keywordtype">void</span> zhptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keywordtype">int</span>*, dcomp*, <span class="keywordtype">int</span>*);
<a name="l00513"></a>00513   <span class="keywordtype">void</span> zhptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00514"></a>00514   <span class="keywordtype">void</span> ztrsm_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00515"></a>00515               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*,
<a name="l00516"></a>00516               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00517"></a>00517   <span class="keywordtype">void</span> zsptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00518"></a>00518   <span class="keywordtype">void</span> zsptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keywordtype">int</span>*, dcomp*, <span class="keywordtype">int</span>*);
<a name="l00519"></a>00519   <span class="keywordtype">void</span> zpotrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00520"></a>00520                <span class="keywordtype">int</span>*);
<a name="l00521"></a>00521   <span class="keywordtype">void</span> zpotri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00522"></a>00522                <span class="keywordtype">int</span>*);
<a name="l00523"></a>00523   <span class="keywordtype">void</span> zpptrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keywordtype">int</span>*);
<a name="l00524"></a>00524   <span class="keywordtype">void</span> zpptri_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keywordtype">int</span>*);
<a name="l00525"></a>00525   <span class="keywordtype">void</span> zspmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*,
<a name="l00526"></a>00526               <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00527"></a>00527               <span class="keyword">const</span> dcomp*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00528"></a>00528   <span class="keywordtype">void</span> zswap_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*,
<a name="l00529"></a>00529               <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00530"></a>00530   <span class="keywordtype">void</span> zsytrf_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00531"></a>00531                <span class="keywordtype">int</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>*);
<a name="l00532"></a>00532   <span class="keywordtype">void</span> ztptrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00533"></a>00533                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00534"></a>00534   <span class="keywordtype">void</span> ztrtrs_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00535"></a>00535                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00536"></a>00536                dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keywordtype">int</span>*);
<a name="l00537"></a>00537   <span class="keywordtype">void</span> ztpmv_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00538"></a>00538               <span class="keyword">const</span> dcomp*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00539"></a>00539   <span class="keywordtype">void</span> zlacpy_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*,
<a name="l00540"></a>00540                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <span class="keywordtype">void</span> zlarfg_(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00543"></a>00543                <span class="keyword">const</span> dcomp*);
<a name="l00544"></a>00544   <span class="keywordtype">void</span> zlarfb_(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*,
<a name="l00545"></a>00545                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00546"></a>00546                <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*,
<a name="l00547"></a>00547                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*, <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*,
<a name="l00548"></a>00548                <span class="keyword">const</span> dcomp*, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>*);
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="keyword">namespace </span>blas
<a name="l00553"></a>00553 {
<a name="l00554"></a>00554 <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* v) {}
<a name="l00555"></a>00555 <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* v) {}
<a name="l00556"></a>00556 <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, dcomp* v)
<a name="l00557"></a>00557 {
<a name="l00558"></a>00558   <span class="keywordflow">while</span>(n--) ::conj(v++);  
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, scomp* v)
<a name="l00561"></a>00561 {
<a name="l00562"></a>00562   <span class="keywordflow">while</span>(n--) ::conj(v++); 
<a name="l00563"></a>00563 }
<a name="l00564"></a>00564  <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* v, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; inc) {}
<a name="l00565"></a>00565  <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* v, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; inc) {}
<a name="l00566"></a>00566  <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, dcomp* v, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; inc)
<a name="l00567"></a>00567 {
<a name="l00568"></a>00568   <span class="keywordflow">while</span>(n--) ::conj(v), v += inc;
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570  <span class="keyword">inline</span> <span class="keywordtype">void</span> conj(<span class="keywordtype">unsigned</span> n, scomp* v, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; inc)
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572   <span class="keywordflow">while</span>(n--) ::conj(v), v += inc;
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* x, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incx,
<a name="l00576"></a>00576                  <span class="keywordtype">double</span>* y, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incy )
<a name="l00577"></a>00577 {
<a name="l00578"></a>00578   dswap_(&amp;n, x, &amp;incx, y, &amp;incy);
<a name="l00579"></a>00579 }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* x, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incx,
<a name="l00582"></a>00582                  <span class="keywordtype">float</span>* y, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incy )
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584   sswap_(&amp;n, x, &amp;incx, y, &amp;incy);
<a name="l00585"></a>00585 }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* x, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incx,
<a name="l00588"></a>00588                  scomp* y, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incy )
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590   cswap_(&amp;n, x, &amp;incx, y, &amp;incy);
<a name="l00591"></a>00591 }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* x, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incx,
<a name="l00594"></a>00594                  dcomp* y, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incy )
<a name="l00595"></a>00595 {
<a name="l00596"></a>00596   zswap_(&amp;n, x, &amp;incx, y, &amp;incy);
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="keyword">inline</span> <span class="keywordtype">void</span> laset(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> a,
<a name="l00601"></a>00601                   <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> ldA)
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603   dlaset_(JOB_STR, &amp;m, &amp;n, &amp;a, &amp;b, A, &amp;ldA);
<a name="l00604"></a>00604 }
<a name="l00605"></a>00605 <span class="keyword">inline</span> <span class="keywordtype">void</span> lasetu(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> a,
<a name="l00606"></a>00606                    <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> ldA)
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608   dlaset_(JOB_STR+5, &amp;m, &amp;n, &amp;a, &amp;b, A, &amp;ldA);
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 <span class="keyword">inline</span> <span class="keywordtype">void</span> lasetl(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> a,
<a name="l00611"></a>00611                    <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> ldA)
<a name="l00612"></a>00612 {
<a name="l00613"></a>00613   dlaset_(JOB_STR+6, &amp;m, &amp;n, &amp;a, &amp;b, A, &amp;ldA);
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> maxi(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* <span class="keyword">const</span> v)
<a name="l00617"></a>00617 {
<a name="l00618"></a>00618   <span class="keywordflow">return</span> idamax_(&amp;n, v, &amp;N_ONE);
<a name="l00619"></a>00619 }
<a name="l00620"></a>00620 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> maxi(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* <span class="keyword">const</span> v)
<a name="l00621"></a>00621 {
<a name="l00622"></a>00622   <span class="keywordflow">return</span> isamax_(&amp;n, v, &amp;N_ONE);
<a name="l00623"></a>00623 }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="keyword">inline</span> <span class="keywordtype">void</span> load(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> e, <span class="keywordtype">double</span>* <span class="keyword">const</span> v)
<a name="l00626"></a>00626 {
<a name="l00627"></a>00627   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) v[i] = e;
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 <span class="keyword">inline</span> <span class="keywordtype">void</span> load(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> e, <span class="keywordtype">float</span>* <span class="keyword">const</span> v)
<a name="l00630"></a>00630 {
<a name="l00631"></a>00631   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) v[i] = e;
<a name="l00632"></a>00632 }
<a name="l00633"></a>00633 <span class="keyword">inline</span> <span class="keywordtype">void</span> load(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp e, scomp* <span class="keyword">const</span> v)
<a name="l00634"></a>00634 {
<a name="l00635"></a>00635   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) v[i] = e;
<a name="l00636"></a>00636 }
<a name="l00637"></a>00637 <span class="keyword">inline</span> <span class="keywordtype">void</span> load(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp e, dcomp* <span class="keyword">const</span> v)
<a name="l00638"></a>00638 {
<a name="l00639"></a>00639   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) v[i] = e;
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="keyword">inline</span> <span class="keywordtype">void</span> setzero(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">unsigned</span>* <span class="keyword">const</span> v)
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) v[i] = 0;
<a name="l00645"></a>00645 }
<a name="l00646"></a>00646 <span class="keyword">inline</span> <span class="keywordtype">void</span> setzero(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* <span class="keyword">const</span> v)
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648   load(n, D_ZERO, v);
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 <span class="keyword">inline</span> <span class="keywordtype">void</span> setzero(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* <span class="keyword">const</span> v)
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652   load(n, S_ZERO, v);
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 <span class="keyword">inline</span> <span class="keywordtype">void</span> setzero(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* <span class="keyword">const</span> v)
<a name="l00655"></a>00655 {
<a name="l00656"></a>00656   load(n, C_ZERO, v);
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 <span class="keyword">inline</span> <span class="keywordtype">void</span> setzero(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* <span class="keyword">const</span> v)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660   load(n, Z_ZERO, v);
<a name="l00661"></a>00661 }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="keyword">inline</span> <span class="keywordtype">double</span> nrm2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v)
<a name="l00664"></a>00664 {
<a name="l00665"></a>00665   <span class="keywordflow">return</span> dnrm2_(&amp;n, v, &amp;N_ONE);
<a name="l00666"></a>00666 }
<a name="l00667"></a>00667 <span class="keyword">inline</span> <span class="keywordtype">float</span> nrm2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v)
<a name="l00668"></a>00668 {
<a name="l00669"></a>00669   <span class="keywordflow">return</span> snrm2_(&amp;n, v, &amp;N_ONE);
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 <span class="keyword">inline</span> <span class="keywordtype">float</span> nrm2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* <span class="keyword">const</span> v)
<a name="l00672"></a>00672 {
<a name="l00673"></a>00673   <span class="keywordflow">return</span> scnrm2_(&amp;n, v, &amp;N_ONE);
<a name="l00674"></a>00674 }
<a name="l00675"></a>00675 <span class="keyword">inline</span> <span class="keywordtype">double</span> nrm2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> v)
<a name="l00676"></a>00676 {
<a name="l00677"></a>00677   <span class="keywordflow">return</span> dznrm2_(&amp;n, v, &amp;N_ONE);
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="keyword">inline</span> <span class="keywordtype">double</span> diff2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* x, <span class="keywordtype">double</span>* y)
<a name="l00681"></a>00681 {
<a name="l00682"></a>00682   <span class="keywordtype">double</span> s = 0.0;
<a name="l00683"></a>00683   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) s += SQR(x[i]-y[i]);
<a name="l00684"></a>00684   <span class="keywordflow">return</span> sqrt(s);
<a name="l00685"></a>00685 }
<a name="l00686"></a>00686 <span class="keyword">inline</span> <span class="keywordtype">float</span> diff2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* x, <span class="keywordtype">float</span>* y)
<a name="l00687"></a>00687 {
<a name="l00688"></a>00688   <span class="keywordtype">float</span> s = 0.0;
<a name="l00689"></a>00689   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) s += SQR(x[i]-y[i]);
<a name="l00690"></a>00690   <span class="keywordflow">return</span> sqrtf(s);
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 <span class="keyword">inline</span> <span class="keywordtype">double</span> diff2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* x, dcomp* y)
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694   <span class="keywordtype">double</span> s = 0.0;
<a name="l00695"></a>00695   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) s += abs2(x[i]-y[i]);
<a name="l00696"></a>00696   <span class="keywordflow">return</span> sqrt(s);
<a name="l00697"></a>00697 }
<a name="l00698"></a>00698 <span class="keyword">inline</span> <span class="keywordtype">float</span> diff2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* x, scomp* y)
<a name="l00699"></a>00699 {
<a name="l00700"></a>00700   <span class="keywordtype">float</span> s = 0.0;
<a name="l00701"></a>00701   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) s += abs2(x[i]-y[i]);
<a name="l00702"></a>00702   <span class="keywordflow">return</span> sqrtf(s);
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="comment">//computes ||a1 - a2||^2 in euclidean norm</span>
<a name="l00706"></a>00706 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00707"></a>00707 <span class="keywordtype">double</span> dst2(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> T *a1, <span class="keyword">const</span> T *a2)
<a name="l00708"></a>00708 {
<a name="l00709"></a>00709   <span class="keywordtype">double</span> nrm2( 0.);
<a name="l00710"></a>00710   <span class="keywordflow">while</span>(n--)
<a name="l00711"></a>00711     nrm2 += abs2(*a1++ - *a2++);
<a name="l00712"></a>00712   
<a name="l00713"></a>00713   <span class="keywordflow">return</span> nrm2;
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> orig, <span class="keywordtype">double</span>* dest)
<a name="l00717"></a>00717 {
<a name="l00718"></a>00718   dcopy_(&amp;n, orig, &amp;N_ONE, dest, &amp;N_ONE);
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> orig, <span class="keywordtype">float</span>* dest)
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722   scopy_(&amp;n, orig, &amp;N_ONE, dest, &amp;N_ONE);
<a name="l00723"></a>00723 }
<a name="l00724"></a>00724 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* <span class="keyword">const</span> orig, scomp* dest)
<a name="l00725"></a>00725 {
<a name="l00726"></a>00726   ccopy_(&amp;n, orig, &amp;N_ONE, dest, &amp;N_ONE);
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> orig, dcomp* dest)
<a name="l00729"></a>00729 {
<a name="l00730"></a>00730   zcopy_(&amp;n, orig, &amp;N_ONE, dest, &amp;N_ONE);
<a name="l00731"></a>00731 }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 
<a name="l00734"></a>00734 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l00735"></a>00735                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00736"></a>00736 {
<a name="l00737"></a>00737   dlacpy_(JOB_STR, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l00740"></a>00740                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00741"></a>00741 {
<a name="l00742"></a>00742   slacpy_(JOB_STR, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l00745"></a>00745                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00746"></a>00746 {
<a name="l00747"></a>00747   clacpy_(JOB_STR, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00748"></a>00748 }
<a name="l00749"></a>00749 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l00750"></a>00750                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752   zlacpy_(JOB_STR, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00753"></a>00753 }
<a name="l00754"></a>00754 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpyu(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l00755"></a>00755                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00756"></a>00756 {
<a name="l00757"></a>00757   dlacpy_(JOB_STR+5, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00758"></a>00758 }
<a name="l00759"></a>00759 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpyu(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l00760"></a>00760                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00761"></a>00761 {
<a name="l00762"></a>00762   slacpy_(JOB_STR+5, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00763"></a>00763 }
<a name="l00764"></a>00764 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpyu(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l00765"></a>00765                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00766"></a>00766 {
<a name="l00767"></a>00767   clacpy_(JOB_STR+5, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 <span class="keyword">inline</span> <span class="keywordtype">void</span> lacpyu(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l00770"></a>00770                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l00771"></a>00771 {
<a name="l00772"></a>00772   zlacpy_(JOB_STR+5, &amp;m, &amp;n, A, &amp;ldA, B, &amp;ldB);
<a name="l00773"></a>00773 }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* orig, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> inco,
<a name="l00777"></a>00777                  <span class="keywordtype">double</span>* dest, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incd)
<a name="l00778"></a>00778 {
<a name="l00779"></a>00779   dcopy_(&amp;n, orig, &amp;inco, dest, &amp;incd);
<a name="l00780"></a>00780 }
<a name="l00781"></a>00781 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* orig, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> inco,
<a name="l00782"></a>00782                  <span class="keywordtype">float</span>* dest, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incd)
<a name="l00783"></a>00783 {
<a name="l00784"></a>00784   scopy_(&amp;n, orig, &amp;inco, dest, &amp;incd);
<a name="l00785"></a>00785 }
<a name="l00786"></a>00786 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* orig, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> inco,
<a name="l00787"></a>00787                  scomp* dest, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incd)
<a name="l00788"></a>00788 {
<a name="l00789"></a>00789   ccopy_(&amp;n, orig, &amp;inco, dest, &amp;incd);
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* orig, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> inco,
<a name="l00792"></a>00792                  dcomp* dest, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> incd)
<a name="l00793"></a>00793 {
<a name="l00794"></a>00794   zcopy_(&amp;n, orig, &amp;inco, dest, &amp;incd);
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="comment">// Conv.Copy double2float</span>
<a name="l00798"></a>00798 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* orig, <span class="keywordtype">float</span>* dest)
<a name="l00799"></a>00799 {
<a name="l00800"></a>00800   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++) dest[i] = (<span class="keywordtype">float</span>) orig[i];
<a name="l00801"></a>00801 }
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 <span class="comment">// Conv.Copy float2double</span>
<a name="l00804"></a>00804 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* orig, <span class="keywordtype">double</span>* dest)
<a name="l00805"></a>00805 {
<a name="l00806"></a>00806   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++) dest[i] = (<span class="keywordtype">double</span>) orig[i];
<a name="l00807"></a>00807 }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 <span class="comment">// Conv.Copy dcomp2scomp</span>
<a name="l00810"></a>00810 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* orig, scomp* dest)
<a name="l00811"></a>00811 {
<a name="l00812"></a>00812   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++)
<a name="l00813"></a>00813     dest[i] = orig[i];
<a name="l00814"></a>00814   <span class="comment">//dest[i].re = (float) orig[i].re, dest[i].im = (float) orig[i].im;</span>
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 <span class="comment">// Conv.Copy scomp2dcomp</span>
<a name="l00818"></a>00818 <span class="keyword">inline</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* orig, dcomp* dest)
<a name="l00819"></a>00819 {
<a name="l00820"></a>00820   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++)
<a name="l00821"></a>00821     dest[i] = orig[i];
<a name="l00822"></a>00822   <span class="comment">//dest[i].re = (double) orig[i].re, dest[i].im = (double) orig[i].im;</span>
<a name="l00823"></a>00823 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 <span class="comment">// Scalar product conj(x)*y</span>
<a name="l00826"></a>00826 <span class="keyword">inline</span> <span class="keywordtype">double</span> scpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v1,
<a name="l00827"></a>00827                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v2)
<a name="l00828"></a>00828 {
<a name="l00829"></a>00829   <span class="keywordflow">return</span> ddot_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00830"></a>00830 }
<a name="l00831"></a>00831 <span class="keyword">inline</span> <span class="keywordtype">float</span> scpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v1,
<a name="l00832"></a>00832                   <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v2)
<a name="l00833"></a>00833 {
<a name="l00834"></a>00834   <span class="keywordflow">return</span> sdot_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00835"></a>00835 }
<a name="l00836"></a>00836 <span class="keyword">inline</span> scomp scpr(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* v1,
<a name="l00837"></a>00837                   <span class="keyword">const</span> scomp* v2)
<a name="l00838"></a>00838 {
<a name="l00839"></a>00839 <span class="preprocessor">#ifdef G77CONVENTION  </span>
<a name="l00840"></a>00840 <span class="preprocessor"></span>  scomp val;
<a name="l00841"></a>00841   cdotc_(&amp;val,&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00842"></a>00842   <span class="keywordflow">return</span> val;
<a name="l00843"></a>00843 <span class="preprocessor">#else</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span>  <span class="keywordflow">return</span> cdotc_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00845"></a>00845 <span class="preprocessor">#endif</span>
<a name="l00846"></a>00846 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00847"></a>00847 <span class="comment">  scomp tmp(0., 0.);</span>
<a name="l00848"></a>00848 <span class="comment">  while(n--)</span>
<a name="l00849"></a>00849 <span class="comment">    tmp += conj(*v1++) * *v2++;</span>
<a name="l00850"></a>00850 <span class="comment">  return tmp;*/</span>
<a name="l00851"></a>00851 }
<a name="l00852"></a>00852 <span class="keyword">inline</span> dcomp scpr(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* v1,
<a name="l00853"></a>00853                   <span class="keyword">const</span> dcomp* v2)
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00856"></a>00856 <span class="preprocessor"></span>  dcomp val;
<a name="l00857"></a>00857   zdotc_(&amp;val,&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00858"></a>00858   <span class="keywordflow">return</span> val;
<a name="l00859"></a>00859 <span class="preprocessor">#else</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>  <span class="keywordflow">return</span> zdotc_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00861"></a>00861 <span class="preprocessor">#endif</span>
<a name="l00862"></a>00862 <span class="preprocessor"></span>}
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="comment">// Scalar product conj(x)*y</span>
<a name="l00865"></a>00865 <span class="keyword">inline</span> <span class="keywordtype">double</span> scpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v1,
<a name="l00866"></a>00866                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v2,
<a name="l00867"></a>00867                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00868"></a>00868 {
<a name="l00869"></a>00869   <span class="keywordflow">return</span> ddot_(&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 <span class="keyword">inline</span> <span class="keywordtype">float</span> scpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v1,
<a name="l00872"></a>00872                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v2,
<a name="l00873"></a>00873                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00874"></a>00874 {
<a name="l00875"></a>00875   <span class="keywordflow">return</span> sdot_(&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00876"></a>00876 }
<a name="l00877"></a>00877 <span class="keyword">inline</span> scomp scpr(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* v1,
<a name="l00878"></a>00878                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> scomp* v2,
<a name="l00879"></a>00879                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00880"></a>00880 {
<a name="l00881"></a>00881 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00882"></a>00882 <span class="preprocessor"></span>  scomp val;
<a name="l00883"></a>00883   cdotc_(&amp;val,&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00884"></a>00884   <span class="keywordflow">return</span> val;
<a name="l00885"></a>00885 <span class="preprocessor">#else</span>
<a name="l00886"></a>00886 <span class="preprocessor"></span>  <span class="keywordflow">return</span> cdotc_(&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00887"></a>00887 <span class="preprocessor">#endif  </span>
<a name="l00888"></a>00888 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00889"></a>00889 <span class="comment">  scomp tmp(0., 0.);</span>
<a name="l00890"></a>00890 <span class="comment">  while(n--)</span>
<a name="l00891"></a>00891 <span class="comment">    tmp += conj(*v1) * *v2, v1 += ld1, v2 += ld2;</span>
<a name="l00892"></a>00892 <span class="comment">  return tmp;*/</span>
<a name="l00893"></a>00893 }
<a name="l00894"></a>00894 <span class="keyword">inline</span> dcomp scpr(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* v1,
<a name="l00895"></a>00895                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> dcomp* v2,
<a name="l00896"></a>00896                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00897"></a>00897 {
<a name="l00898"></a>00898 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00899"></a>00899 <span class="preprocessor"></span>  dcomp val;
<a name="l00900"></a>00900   zdotc_(&amp;val,&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00901"></a>00901   <span class="keywordflow">return</span> val;
<a name="l00902"></a>00902 <span class="preprocessor">#else</span>
<a name="l00903"></a>00903 <span class="preprocessor"></span>  <span class="keywordflow">return</span> zdotc_(&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00904"></a>00904 <span class="preprocessor">#endif</span>
<a name="l00905"></a>00905 <span class="preprocessor"></span>}
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="comment">//computes v1^T* v2 (without conjugation) </span>
<a name="l00908"></a>00908 <span class="keyword">inline</span> <span class="keywordtype">double</span> vecpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v1,
<a name="l00909"></a>00909                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v2)
<a name="l00910"></a>00910 {
<a name="l00911"></a>00911   <span class="keywordflow">return</span> ddot_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE); <span class="comment">//same as scpr</span>
<a name="l00912"></a>00912 }
<a name="l00913"></a>00913 <span class="keyword">inline</span> <span class="keywordtype">float</span> vecpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v1,
<a name="l00914"></a>00914                   <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v2)
<a name="l00915"></a>00915 {
<a name="l00916"></a>00916   <span class="keywordflow">return</span> sdot_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE); <span class="comment">//same as scpr</span>
<a name="l00917"></a>00917 }
<a name="l00918"></a>00918 <span class="keyword">inline</span> scomp vecpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* <span class="keyword">const</span> v1,
<a name="l00919"></a>00919                   <span class="keyword">const</span> scomp* <span class="keyword">const</span> v2)
<a name="l00920"></a>00920 {
<a name="l00921"></a>00921 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00922"></a>00922 <span class="preprocessor"></span>  scomp val;
<a name="l00923"></a>00923   cdotu_(&amp;val,&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00924"></a>00924   <span class="keywordflow">return</span> val;
<a name="l00925"></a>00925 <span class="preprocessor">#else</span>
<a name="l00926"></a>00926 <span class="preprocessor"></span>  <span class="keywordflow">return</span> cdotu_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00927"></a>00927 <span class="preprocessor">#endif</span>
<a name="l00928"></a>00928 <span class="preprocessor"></span>}
<a name="l00929"></a>00929 <span class="keyword">inline</span> dcomp vecpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> v1,
<a name="l00930"></a>00930                   <span class="keyword">const</span> dcomp* <span class="keyword">const</span> v2)
<a name="l00931"></a>00931 {
<a name="l00932"></a>00932 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00933"></a>00933 <span class="preprocessor"></span>  dcomp val;
<a name="l00934"></a>00934   zdotu_(&amp;val,&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00935"></a>00935   <span class="keywordflow">return</span> val;
<a name="l00936"></a>00936 <span class="preprocessor">#else</span>
<a name="l00937"></a>00937 <span class="preprocessor"></span>  <span class="keywordflow">return</span> zdotu_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00938"></a>00938 <span class="preprocessor">#endif</span>
<a name="l00939"></a>00939 <span class="preprocessor"></span>}
<a name="l00940"></a>00940 <span class="comment">// Scalar product conj(x)*y</span>
<a name="l00941"></a>00941 <span class="keyword">inline</span> <span class="keywordtype">double</span> vecpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v1,
<a name="l00942"></a>00942                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v2,
<a name="l00943"></a>00943                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00944"></a>00944 {
<a name="l00945"></a>00945   <span class="keywordflow">return</span> ddot_(&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00946"></a>00946 }
<a name="l00947"></a>00947 <span class="keyword">inline</span> <span class="keywordtype">float</span> vecpr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v1,
<a name="l00948"></a>00948                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v2,
<a name="l00949"></a>00949                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00950"></a>00950 {
<a name="l00951"></a>00951   <span class="keywordflow">return</span> sdot_(&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00952"></a>00952 }
<a name="l00953"></a>00953 <span class="keyword">inline</span> scomp vecpr(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* v1,
<a name="l00954"></a>00954                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> scomp* v2,
<a name="l00955"></a>00955                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00956"></a>00956 {
<a name="l00957"></a>00957 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00958"></a>00958 <span class="preprocessor"></span>  scomp val;
<a name="l00959"></a>00959   cdotu_(&amp;val,&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00960"></a>00960   <span class="keywordflow">return</span> val;
<a name="l00961"></a>00961 <span class="preprocessor">#else</span>
<a name="l00962"></a>00962 <span class="preprocessor"></span>  <span class="keywordflow">return</span> cdotu_(&amp;n, v1, &amp;N_ONE, v2, &amp;N_ONE);
<a name="l00963"></a>00963 <span class="preprocessor">#endif</span>
<a name="l00964"></a>00964 <span class="preprocessor"></span>  <span class="comment">/*scomp tmp(0., 0.);</span>
<a name="l00965"></a>00965 <span class="comment">  while(n--)</span>
<a name="l00966"></a>00966 <span class="comment">    tmp += *v1 * *v2, v1 += ld1, v2 += ld2;</span>
<a name="l00967"></a>00967 <span class="comment">  return tmp;*/</span>
<a name="l00968"></a>00968 }
<a name="l00969"></a>00969 <span class="keyword">inline</span> dcomp vecpr(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* v1,
<a name="l00970"></a>00970                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld1, <span class="keyword">const</span> dcomp* v2,
<a name="l00971"></a>00971                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ld2)
<a name="l00972"></a>00972 {
<a name="l00973"></a>00973 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00974"></a>00974 <span class="preprocessor"></span>  dcomp val;
<a name="l00975"></a>00975   zdotu_(&amp;val,&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00976"></a>00976   <span class="keywordflow">return</span> val;
<a name="l00977"></a>00977 <span class="preprocessor">#else</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span>  <span class="keywordflow">return</span> zdotu_(&amp;n, v1, &amp;ld1, v2, &amp;ld2);
<a name="l00979"></a>00979 <span class="preprocessor">#endif</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span>}
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 <span class="keyword">inline</span> <span class="keywordtype">double</span> sqrsum(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> v)
<a name="l00984"></a>00984 {
<a name="l00985"></a>00985   <span class="keywordflow">return</span> ddot_(&amp;n, v, &amp;N_ONE, v, &amp;N_ONE);
<a name="l00986"></a>00986 }
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 <span class="keyword">inline</span> <span class="keywordtype">float</span> sqrsum(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> v)
<a name="l00989"></a>00989 {
<a name="l00990"></a>00990   <span class="keywordflow">return</span> sdot_(&amp;n, v, &amp;N_ONE, v, &amp;N_ONE);
<a name="l00991"></a>00991 }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 <span class="keyword">inline</span> <span class="keywordtype">double</span> sqrsum(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> v)
<a name="l00994"></a>00994 {
<a name="l00995"></a>00995 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span>  dcomp z;
<a name="l00997"></a>00997   zdotc_(&amp;z,&amp;n, v, &amp;N_ONE, v, &amp;N_ONE);
<a name="l00998"></a>00998 <span class="preprocessor">#else</span>
<a name="l00999"></a>00999 <span class="preprocessor"></span>  dcomp z = zdotc_(&amp;n, v, &amp;N_ONE, v, &amp;N_ONE);
<a name="l01000"></a>01000 <span class="preprocessor">#endif</span>
<a name="l01001"></a>01001 <span class="preprocessor"></span>  <span class="keywordflow">return</span> Re(z);
<a name="l01002"></a>01002 }
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 <span class="keyword">inline</span> <span class="keywordtype">float</span> sqrsum(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* <span class="keyword">const</span> v)
<a name="l01005"></a>01005 {
<a name="l01006"></a>01006 <span class="preprocessor">#ifdef G77CONVENTION</span>
<a name="l01007"></a>01007 <span class="preprocessor"></span>  scomp z;
<a name="l01008"></a>01008   cdotc_(&amp;z,&amp;n, v, &amp;N_ONE, v, &amp;N_ONE);
<a name="l01009"></a>01009 <span class="preprocessor">#else</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span>  scomp z = cdotc_(&amp;n, v, &amp;N_ONE, v, &amp;N_ONE);
<a name="l01011"></a>01011 <span class="preprocessor">#endif</span>
<a name="l01012"></a>01012 <span class="preprocessor"></span>  <span class="keywordflow">return</span> Re(z);
<a name="l01013"></a>01013 }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 <span class="keyword">inline</span> <span class="keywordtype">void</span> add(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* <span class="keyword">const</span> x, <span class="keywordtype">double</span>* <span class="keyword">const</span> y)
<a name="l01016"></a>01016 {
<a name="l01017"></a>01017   daxpy_(&amp;n, &amp;D_ONE, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 <span class="keyword">inline</span> <span class="keywordtype">void</span> add(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* <span class="keyword">const</span> x, <span class="keywordtype">float</span>* <span class="keyword">const</span> y)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021   saxpy_(&amp;n, &amp;S_ONE, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 <span class="keyword">inline</span> <span class="keywordtype">void</span> add(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* <span class="keyword">const</span> x, scomp* <span class="keyword">const</span> y)
<a name="l01024"></a>01024 {
<a name="l01025"></a>01025   caxpy_(&amp;n, &amp;C_ONE, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01026"></a>01026 }
<a name="l01027"></a>01027 <span class="keyword">inline</span> <span class="keywordtype">void</span> add(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* <span class="keyword">const</span> x,dcomp* <span class="keyword">const</span> y)
<a name="l01028"></a>01028 {
<a name="l01029"></a>01029   zaxpy_(&amp;n, &amp;Z_ONE, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01030"></a>01030 }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="keyword">inline</span> <span class="keywordtype">void</span> axpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> x,
<a name="l01033"></a>01033                  <span class="keywordtype">double</span>* <span class="keyword">const</span> y)
<a name="l01034"></a>01034 {
<a name="l01035"></a>01035   daxpy_(&amp;n, &amp;d, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01036"></a>01036 }
<a name="l01037"></a>01037 <span class="keyword">inline</span> <span class="keywordtype">void</span> axpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> x,
<a name="l01038"></a>01038                  <span class="keywordtype">float</span>* <span class="keyword">const</span> y)
<a name="l01039"></a>01039 {
<a name="l01040"></a>01040   saxpy_(&amp;n, &amp;d, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 <span class="keyword">inline</span> <span class="keywordtype">void</span> axpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> x,
<a name="l01043"></a>01043                  scomp* <span class="keyword">const</span> y)
<a name="l01044"></a>01044 {
<a name="l01045"></a>01045   caxpy_(&amp;n, &amp;d, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01046"></a>01046 }
<a name="l01047"></a>01047 <span class="keyword">inline</span> <span class="keywordtype">void</span> axpy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> x,
<a name="l01048"></a>01048                  dcomp* <span class="keyword">const</span> y)
<a name="l01049"></a>01049 {
<a name="l01050"></a>01050   zaxpy_(&amp;n, &amp;d, x, &amp;N_ONE, y, &amp;N_ONE);
<a name="l01051"></a>01051 }
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keywordtype">double</span>* <span class="keyword">const</span> x, <span class="keywordtype">unsigned</span> incx)
<a name="l01054"></a>01054 {
<a name="l01055"></a>01055   dscal_(&amp;n, &amp;d, x, &amp;incx);
<a name="l01056"></a>01056 }
<a name="l01057"></a>01057 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keywordtype">float</span>* <span class="keyword">const</span> x, <span class="keywordtype">unsigned</span> incx)
<a name="l01058"></a>01058 {
<a name="l01059"></a>01059   sscal_(&amp;n, &amp;d, x, &amp;incx);
<a name="l01060"></a>01060 }
<a name="l01061"></a>01061 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp d, scomp* <span class="keyword">const</span> x, <span class="keywordtype">unsigned</span> incx)
<a name="l01062"></a>01062 {
<a name="l01063"></a>01063   cscal_(&amp;n, &amp;d, x, &amp;incx);
<a name="l01064"></a>01064 }
<a name="l01065"></a>01065 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp d, dcomp* <span class="keyword">const</span> x, <span class="keywordtype">unsigned</span> incx)
<a name="l01066"></a>01066 {
<a name="l01067"></a>01067   zscal_(&amp;n, &amp;d, x, &amp;incx);
<a name="l01068"></a>01068 }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l01071"></a>01071 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> T d, T* <span class="keyword">const</span> x)
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073   scal(n, d, x, N_ONE);
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span> d, scomp* <span class="keyword">const</span> x)
<a name="l01077"></a>01077 {
<a name="l01078"></a>01078   scal(n, (scomp) d, x, N_ONE);
<a name="l01079"></a>01079 }
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> d, dcomp* <span class="keyword">const</span> x)
<a name="l01082"></a>01082 {
<a name="l01083"></a>01083   scal(n, (dcomp) d, x, N_ONE);
<a name="l01084"></a>01084 }
<a name="l01085"></a>01085 
<a name="l01086"></a>01086 
<a name="l01087"></a>01087 
<a name="l01088"></a>01088 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> normalize(<span class="keywordtype">unsigned</span> n, T* x)
<a name="l01089"></a>01089 {
<a name="l01090"></a>01090   T s = 1.0/blas::nrm2(n, x);
<a name="l01091"></a>01091   blas::scal(n, s, x);
<a name="l01092"></a>01092 }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> mkOrth(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> T* v1, T* v2)
<a name="l01095"></a>01095 {
<a name="l01096"></a>01096   T s = -blas::scpr(n, v1, v2);
<a name="l01097"></a>01097   blas::axpy(n, s, v1, v2);
<a name="l01098"></a>01098 }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l01101"></a>01101 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> T d, T* <span class="keyword">const</span> x, T* <span class="keyword">const</span> y)
<a name="l01102"></a>01102 {
<a name="l01103"></a>01103   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) y[i] = d * x[i];
<a name="l01104"></a>01104 }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l01107"></a>01107 <span class="keyword">inline</span> <span class="keywordtype">void</span> scal(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, T* <span class="keyword">const</span> x, T* <span class="keyword">const</span> d)
<a name="l01108"></a>01108 {
<a name="l01109"></a>01109   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) x[i] *= d[i];
<a name="l01110"></a>01110 }
<a name="l01111"></a>01111 
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 <span class="comment">// y = d Ax</span>
<a name="l01117"></a>01117 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d,
<a name="l01118"></a>01118                  <span class="keyword">const</span> <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01119"></a>01119 {
<a name="l01120"></a>01120   dgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;D_ZERO, y, &amp;N_ONE);
<a name="l01121"></a>01121 }
<a name="l01122"></a>01122 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01123"></a>01123                  <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01124"></a>01124 {
<a name="l01125"></a>01125   sgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;S_ZERO, y, &amp;N_ONE);
<a name="l01126"></a>01126 }
<a name="l01127"></a>01127 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01128"></a>01128                  scomp *x, scomp *y)
<a name="l01129"></a>01129 {
<a name="l01130"></a>01130   cgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;C_ZERO, y, &amp;N_ONE);
<a name="l01131"></a>01131 }
<a name="l01132"></a>01132 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01133"></a>01133                  dcomp *x, dcomp *y)
<a name="l01134"></a>01134 {
<a name="l01135"></a>01135   zgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;Z_ZERO, y, &amp;N_ONE);
<a name="l01136"></a>01136 }
<a name="l01137"></a>01137 
<a name="l01138"></a>01138 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d,
<a name="l01139"></a>01139                  <span class="keyword">const</span> <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01140"></a>01140 {
<a name="l01141"></a>01141   dgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;N_ONE, &amp;D_ZERO, y, &amp;N_ONE);
<a name="l01142"></a>01142 }
<a name="l01143"></a>01143 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01144"></a>01144                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01145"></a>01145 {
<a name="l01146"></a>01146   sgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;N_ONE, &amp;S_ZERO, y, &amp;N_ONE);
<a name="l01147"></a>01147 }
<a name="l01148"></a>01148 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01149"></a>01149                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp *x, scomp *y)
<a name="l01150"></a>01150 {
<a name="l01151"></a>01151   cgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;N_ONE, &amp;C_ZERO, y, &amp;N_ONE);
<a name="l01152"></a>01152 }
<a name="l01153"></a>01153 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01154"></a>01154                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp *x, dcomp *y)
<a name="l01155"></a>01155 {
<a name="l01156"></a>01156   zgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;N_ONE, &amp;Z_ZERO, y, &amp;N_ONE);
<a name="l01157"></a>01157 }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 
<a name="l01160"></a>01160 <span class="comment">// y += d Ax</span>
<a name="l01161"></a>01161 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* A,
<a name="l01162"></a>01162                   <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01163"></a>01163 {
<a name="l01164"></a>01164   dgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;D_ONE, y, &amp;N_ONE);
<a name="l01165"></a>01165 }
<a name="l01166"></a>01166 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01167"></a>01167                   <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01168"></a>01168 {
<a name="l01169"></a>01169   sgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;S_ONE, y, &amp;N_ONE);
<a name="l01170"></a>01170 }
<a name="l01171"></a>01171 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01172"></a>01172                   <span class="keyword">const</span> scomp *x, scomp *y)
<a name="l01173"></a>01173 {
<a name="l01174"></a>01174   cgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;C_ONE, y, &amp;N_ONE);
<a name="l01175"></a>01175 }
<a name="l01176"></a>01176 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01177"></a>01177                   <span class="keyword">const</span> dcomp *x, dcomp *y)
<a name="l01178"></a>01178 {
<a name="l01179"></a>01179   zgemv_(JOB_STR, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;Z_ONE, y, &amp;N_ONE);
<a name="l01180"></a>01180 }
<a name="l01181"></a>01181 
<a name="l01182"></a>01182 <span class="comment">// y = d A^H x</span>
<a name="l01183"></a>01183 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* A,
<a name="l01184"></a>01184                   <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01185"></a>01185 {
<a name="l01186"></a>01186   dgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;D_ZERO, y, &amp;N_ONE);
<a name="l01187"></a>01187 }
<a name="l01188"></a>01188 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01189"></a>01189                   <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01190"></a>01190 {
<a name="l01191"></a>01191   sgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;S_ZERO, y, &amp;N_ONE);
<a name="l01192"></a>01192 }
<a name="l01193"></a>01193 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01194"></a>01194                   <span class="keyword">const</span> scomp *x, scomp *y)
<a name="l01195"></a>01195 {
<a name="l01196"></a>01196   cgemv_(JOB_STR+7, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;C_ZERO, y, &amp;N_ONE);
<a name="l01197"></a>01197 }
<a name="l01198"></a>01198 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01199"></a>01199                   <span class="keyword">const</span> dcomp *x, dcomp *y)
<a name="l01200"></a>01200 {
<a name="l01201"></a>01201   zgemv_(JOB_STR+7, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;Z_ZERO, y, &amp;N_ONE);
<a name="l01202"></a>01202 }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="comment">// y += d A^H x</span>
<a name="l01205"></a>01205 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d,
<a name="l01206"></a>01206                    <span class="keyword">const</span> <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">unsigned</span> incx,
<a name="l01207"></a>01207                    <span class="keywordtype">double</span> *y, <span class="keywordtype">unsigned</span> incy)
<a name="l01208"></a>01208 {
<a name="l01209"></a>01209   dgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;incx, &amp;D_ONE, y, &amp;incy);
<a name="l01210"></a>01210 }
<a name="l01211"></a>01211 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d,
<a name="l01212"></a>01212                    <span class="keyword">const</span> <span class="keywordtype">float</span>* A, <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">unsigned</span> incx,
<a name="l01213"></a>01213                    <span class="keywordtype">float</span> *y, <span class="keywordtype">unsigned</span> incy)
<a name="l01214"></a>01214 {
<a name="l01215"></a>01215   sgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;incx, &amp;S_ONE, y, &amp;incy);
<a name="l01216"></a>01216 }
<a name="l01217"></a>01217 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d,
<a name="l01218"></a>01218                    <span class="keyword">const</span> scomp* A, <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> scomp *x, <span class="keywordtype">unsigned</span> incx,
<a name="l01219"></a>01219                    scomp *y, <span class="keywordtype">unsigned</span> incy)
<a name="l01220"></a>01220 {
<a name="l01221"></a>01221   cgemv_(JOB_STR+7, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;incx, &amp;C_ONE, y, &amp;incy);
<a name="l01222"></a>01222 }
<a name="l01223"></a>01223 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d,
<a name="l01224"></a>01224                    <span class="keyword">const</span> dcomp* A, <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> dcomp *x, <span class="keywordtype">unsigned</span> incx,
<a name="l01225"></a>01225                    dcomp *y, <span class="keywordtype">unsigned</span> incy)
<a name="l01226"></a>01226 {
<a name="l01227"></a>01227   zgemv_(JOB_STR+7, &amp;m, &amp;n, &amp;d, A, &amp;ldA, x, &amp;incx, &amp;Z_ONE, y, &amp;incy);
<a name="l01228"></a>01228 }
<a name="l01229"></a>01229 
<a name="l01230"></a>01230 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* A,
<a name="l01231"></a>01231                    <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01232"></a>01232 {
<a name="l01233"></a>01233   gemhva(m, n, d, A, m, x, N_ONE, y, N_ONE);
<a name="l01234"></a>01234 }
<a name="l01235"></a>01235 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01236"></a>01236                    <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238   gemhva(m, n, d, A, m, x, N_ONE, y, N_ONE);
<a name="l01239"></a>01239 }
<a name="l01240"></a>01240 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01241"></a>01241                    <span class="keyword">const</span> scomp *x, scomp *y)
<a name="l01242"></a>01242 {
<a name="l01243"></a>01243   gemhva(m, n, d, A, m, x, N_ONE, y, N_ONE);
<a name="l01244"></a>01244 }
<a name="l01245"></a>01245 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01246"></a>01246                    <span class="keyword">const</span> dcomp *x, dcomp *y)
<a name="l01247"></a>01247 {
<a name="l01248"></a>01248   gemhva(m, n, d, A, m, x, N_ONE, y, N_ONE);
<a name="l01249"></a>01249 }
<a name="l01250"></a>01250 
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 <span class="comment">// y += d A^T x</span>
<a name="l01253"></a>01253 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> d, 
<a name="l01254"></a>01254                    <span class="keyword">const</span> <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01255"></a>01255 {
<a name="l01256"></a>01256   dgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;D_ONE, y, &amp;N_ONE);
<a name="l01257"></a>01257 }
<a name="l01258"></a>01258 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span> d, 
<a name="l01259"></a>01259                    <span class="keyword">const</span> <span class="keywordtype">float</span>* A, <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01260"></a>01260 {
<a name="l01261"></a>01261   sgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;S_ONE, y, &amp;N_ONE);
<a name="l01262"></a>01262 }
<a name="l01263"></a>01263 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp d, 
<a name="l01264"></a>01264                    <span class="keyword">const</span> scomp* A, <span class="keyword">const</span> scomp *x, scomp *y)
<a name="l01265"></a>01265 {
<a name="l01266"></a>01266   cgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;C_ONE, y, &amp;N_ONE);
<a name="l01267"></a>01267 }
<a name="l01268"></a>01268 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp d, 
<a name="l01269"></a>01269                    <span class="keyword">const</span> dcomp* A, <span class="keyword">const</span> dcomp *x, dcomp *y)
<a name="l01270"></a>01270 {
<a name="l01271"></a>01271   zgemv_(JOB_STR+1, &amp;m, &amp;n, &amp;d, A, &amp;m, x, &amp;N_ONE, &amp;Z_ONE, y, &amp;N_ONE);
<a name="l01272"></a>01272 }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 <span class="comment">// y += d A x (A symm. dense in packed format)</span>
<a name="l01277"></a>01277 <span class="keyword">inline</span> <span class="keywordtype">void</span> symva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* A,
<a name="l01278"></a>01278                    <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01279"></a>01279 {
<a name="l01280"></a>01280   dspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;D_ONE, y, &amp;N_ONE);
<a name="l01281"></a>01281 }
<a name="l01282"></a>01282 <span class="keyword">inline</span> <span class="keywordtype">void</span> symva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01283"></a>01283                    <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01284"></a>01284 {
<a name="l01285"></a>01285   sspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;S_ONE, y, &amp;N_ONE);
<a name="l01286"></a>01286 }
<a name="l01287"></a>01287 <span class="keyword">inline</span> <span class="keywordtype">void</span> symva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01288"></a>01288                    <span class="keyword">const</span> scomp *x, scomp *y)
<a name="l01289"></a>01289 {
<a name="l01290"></a>01290   cspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;C_ONE, y, &amp;N_ONE);
<a name="l01291"></a>01291 }
<a name="l01292"></a>01292 <span class="keyword">inline</span> <span class="keywordtype">void</span> symva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01293"></a>01293                    <span class="keyword">const</span> dcomp *x, dcomp *y)
<a name="l01294"></a>01294 {
<a name="l01295"></a>01295   zspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;Z_ONE, y, &amp;N_ONE);
<a name="l01296"></a>01296 }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298 
<a name="l01299"></a>01299 <span class="comment">// y += d A x (A herm. dense in packed format)</span>
<a name="l01300"></a>01300 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* A,
<a name="l01301"></a>01301                    <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01302"></a>01302 {
<a name="l01303"></a>01303   dspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;D_ONE, y, &amp;N_ONE);
<a name="l01304"></a>01304 }
<a name="l01305"></a>01305 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01306"></a>01306                    <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01307"></a>01307 {
<a name="l01308"></a>01308   sspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;S_ONE, y, &amp;N_ONE);
<a name="l01309"></a>01309 }
<a name="l01310"></a>01310 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01311"></a>01311                    <span class="keyword">const</span> scomp *x, scomp *y)
<a name="l01312"></a>01312 {
<a name="l01313"></a>01313   chpmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;C_ONE, y, &amp;N_ONE);
<a name="l01314"></a>01314 }
<a name="l01315"></a>01315 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01316"></a>01316                    <span class="keyword">const</span> dcomp *x, dcomp *y)
<a name="l01317"></a>01317 {
<a name="l01318"></a>01318   zhpmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;Z_ONE, y, &amp;N_ONE);
<a name="l01319"></a>01319 }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 
<a name="l01323"></a>01323 
<a name="l01324"></a>01324 <span class="comment">// y += d A^T x (A herm. dense in packed format)</span>
<a name="l01325"></a>01325 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* A,
<a name="l01326"></a>01326                     <span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y)
<a name="l01327"></a>01327 {
<a name="l01328"></a>01328   dspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;D_ONE, y, &amp;N_ONE);
<a name="l01329"></a>01329 }
<a name="l01330"></a>01330 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l01331"></a>01331                     <span class="keyword">const</span> <span class="keywordtype">float</span> *x, <span class="keywordtype">float</span> *y)
<a name="l01332"></a>01332 {
<a name="l01333"></a>01333   
<a name="l01334"></a>01334   sspmv_(JOB_STR+5, &amp;n, &amp;d, A, x, &amp;N_ONE, &amp;S_ONE, y, &amp;N_ONE);
<a name="l01335"></a>01335 }
<a name="l01336"></a>01336 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp d, <span class="keyword">const</span> scomp* A,
<a name="l01337"></a>01337                     <span class="keyword">const</span> scomp *x, scomp *y)
<a name="l01338"></a>01338 {
<a name="l01339"></a>01339   scomp tmp;
<a name="l01340"></a>01340   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) {
<a name="l01341"></a>01341     y[i] += d * A[i+i*(i+1)/2] * x[i];
<a name="l01342"></a>01342     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=i+1; j&lt;n; ++j) {
<a name="l01343"></a>01343       tmp = A[i+j*(j+1)/2];
<a name="l01344"></a>01344       y[i] += d * conj(tmp) * x[j];
<a name="l01345"></a>01345       y[j] += d* conj(tmp) * x[i];
<a name="l01346"></a>01346     }
<a name="l01347"></a>01347   }
<a name="l01348"></a>01348 }
<a name="l01349"></a>01349 <span class="keyword">inline</span> <span class="keywordtype">void</span> hemtva(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp d, <span class="keyword">const</span> dcomp* A,
<a name="l01350"></a>01350                     <span class="keyword">const</span> dcomp *x, dcomp *y)
<a name="l01351"></a>01351 {
<a name="l01352"></a>01352   dcomp tmp;
<a name="l01353"></a>01353   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) {
<a name="l01354"></a>01354     y[i] += d * A[i+i*(i+1)/2] * x[i];
<a name="l01355"></a>01355     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=i+1; j&lt;n; ++j) {
<a name="l01356"></a>01356       tmp = A[i+j*(j+1)/2];
<a name="l01357"></a>01357       y[i] += d * conj(tmp) * x[j];
<a name="l01358"></a>01358       y[j] += d* conj(tmp) * x[i];
<a name="l01359"></a>01359     }
<a name="l01360"></a>01360   }
<a name="l01361"></a>01361 }
<a name="l01362"></a>01362 
<a name="l01363"></a>01363 
<a name="l01364"></a>01364 <span class="comment">// sovles Ax=B, A is a triangluar Matrix</span>
<a name="l01365"></a>01365 <span class="keyword">inline</span> <span class="keywordtype">void</span> gtsv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* n, <span class="keyword">const</span> <span class="keywordtype">double</span>* DiagLower,
<a name="l01366"></a>01366                  <span class="keyword">const</span> <span class="keywordtype">double</span>* Diag, <span class="keyword">const</span> <span class="keywordtype">double</span>* DiagUpper,
<a name="l01367"></a>01367                  <span class="keyword">const</span> <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">int</span>* INFO)
<a name="l01368"></a>01368 {
<a name="l01369"></a>01369   dgtsv_(n, &amp;N_ONE, DiagLower, Diag, DiagUpper, B, n, INFO);
<a name="l01370"></a>01370 }
<a name="l01371"></a>01371 <span class="keyword">inline</span> <span class="keywordtype">void</span> gtsv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* n, <span class="keyword">const</span> <span class="keywordtype">float</span>* DiagLower,
<a name="l01372"></a>01372                  <span class="keyword">const</span> <span class="keywordtype">float</span>* Diag, <span class="keyword">const</span> <span class="keywordtype">float</span>* DiagUpper,
<a name="l01373"></a>01373                  <span class="keyword">const</span> <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">int</span>* INFO)
<a name="l01374"></a>01374 {
<a name="l01375"></a>01375   sgtsv_(n, &amp;N_ONE, DiagLower, Diag, DiagUpper, B, n, INFO);
<a name="l01376"></a>01376 }
<a name="l01377"></a>01377 <span class="keyword">inline</span> <span class="keywordtype">void</span> gtsv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* n, <span class="keyword">const</span> scomp* DiagLower,
<a name="l01378"></a>01378                  <span class="keyword">const</span> scomp* Diag, <span class="keyword">const</span> scomp* DiagUpper,
<a name="l01379"></a>01379                  <span class="keyword">const</span> scomp* B, <span class="keyword">const</span> <span class="keywordtype">int</span>* INFO)
<a name="l01380"></a>01380 {
<a name="l01381"></a>01381   cgtsv_(n, &amp;N_ONE, DiagLower, Diag, DiagUpper, B, n, INFO);
<a name="l01382"></a>01382 }
<a name="l01383"></a>01383 <span class="keyword">inline</span> <span class="keywordtype">void</span> gtsv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* n, <span class="keyword">const</span> dcomp* DiagLower,
<a name="l01384"></a>01384                  <span class="keyword">const</span> dcomp* Diag, <span class="keyword">const</span> dcomp* DiagUpper,
<a name="l01385"></a>01385                  <span class="keyword">const</span> dcomp* B, <span class="keyword">const</span> <span class="keywordtype">int</span>* INFO)
<a name="l01386"></a>01386 {
<a name="l01387"></a>01387   zgtsv_(n, &amp;N_ONE, DiagLower, Diag, DiagUpper, B, n, INFO);
<a name="l01388"></a>01388 }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390 
<a name="l01391"></a>01391 
<a name="l01392"></a>01392 <span class="comment">// C = d A B, A is m x p, B is p x n</span>
<a name="l01393"></a>01393 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01394"></a>01394                  <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01395"></a>01395                  <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01396"></a>01396                  <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01397"></a>01397 {
<a name="l01398"></a>01398   dgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01399"></a>01399          &amp;D_ZERO, C, &amp;ldC);
<a name="l01400"></a>01400 }
<a name="l01401"></a>01401 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01402"></a>01402                  <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01403"></a>01403                  <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01404"></a>01404                  <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01405"></a>01405 {
<a name="l01406"></a>01406   sgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01407"></a>01407          &amp;S_ZERO, C, &amp;ldC);
<a name="l01408"></a>01408 }
<a name="l01409"></a>01409 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01410"></a>01410                  <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01411"></a>01411                  <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01412"></a>01412                  scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01413"></a>01413 {
<a name="l01414"></a>01414   cgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01415"></a>01415          &amp;C_ZERO, C, &amp;ldC);
<a name="l01416"></a>01416 }
<a name="l01417"></a>01417 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01418"></a>01418                  <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01419"></a>01419                  <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01420"></a>01420                  dcomp* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01421"></a>01421 {
<a name="l01422"></a>01422   zgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01423"></a>01423          &amp;Z_ZERO, C, &amp;ldC);
<a name="l01424"></a>01424 }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="comment">// C += d A B, A is m x p, B is p x n</span>
<a name="l01428"></a>01428 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01429"></a>01429                   <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01430"></a>01430                   <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01431"></a>01431                   <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01432"></a>01432 {
<a name="l01433"></a>01433   dgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01434"></a>01434          &amp;D_ONE, C, &amp;ldC);
<a name="l01435"></a>01435 }
<a name="l01436"></a>01436 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01437"></a>01437                   <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01438"></a>01438                   <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01439"></a>01439                   <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01440"></a>01440 {
<a name="l01441"></a>01441   sgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01442"></a>01442          &amp;S_ONE, C, &amp;ldC);
<a name="l01443"></a>01443 }
<a name="l01444"></a>01444 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01445"></a>01445                   <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01446"></a>01446                   <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01447"></a>01447                   scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01448"></a>01448 {
<a name="l01449"></a>01449   cgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01450"></a>01450          &amp;C_ONE, C, &amp;ldC);
<a name="l01451"></a>01451 }
<a name="l01452"></a>01452 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01453"></a>01453                   <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01454"></a>01454                   <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01455"></a>01455                   dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01456"></a>01456 {
<a name="l01457"></a>01457   zgemm_(JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01458"></a>01458          &amp;Z_ONE, C, &amp;ldC);
<a name="l01459"></a>01459 }
<a name="l01460"></a>01460 
<a name="l01461"></a>01461 <span class="comment">// C = d A^H B, A is m x p, B is m x n</span>
<a name="l01462"></a>01462 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01463"></a>01463                   <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01464"></a>01464                   <span class="keyword">const</span> <span class="keywordtype">double</span> *B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01465"></a>01465                   <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01466"></a>01466 {
<a name="l01467"></a>01467   dgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01468"></a>01468          &amp;D_ZERO, C, &amp;ldC);
<a name="l01469"></a>01469 }
<a name="l01470"></a>01470 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01471"></a>01471                   <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01472"></a>01472                   <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01473"></a>01473                   <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01474"></a>01474 {
<a name="l01475"></a>01475   sgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01476"></a>01476          &amp;S_ZERO, C, &amp;ldC);
<a name="l01477"></a>01477 }
<a name="l01478"></a>01478 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01479"></a>01479                   <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01480"></a>01480                   <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01481"></a>01481                   scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01482"></a>01482 {
<a name="l01483"></a>01483   cgemm_(JOB_STR+7, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01484"></a>01484          &amp;C_ZERO, C, &amp;ldC);
<a name="l01485"></a>01485 }
<a name="l01486"></a>01486 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01487"></a>01487                   <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01488"></a>01488                   <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01489"></a>01489                   dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01490"></a>01490 {
<a name="l01491"></a>01491   zgemm_(JOB_STR+7, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01492"></a>01492          &amp;Z_ZERO, C, &amp;ldC);
<a name="l01493"></a>01493 }
<a name="l01494"></a>01494 
<a name="l01495"></a>01495 <span class="comment">// C += d A^H B, A is m x p, B is m x n</span>
<a name="l01496"></a>01496 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d,
<a name="l01497"></a>01497                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B,
<a name="l01498"></a>01498                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB, <span class="keywordtype">double</span>* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01499"></a>01499 {
<a name="l01500"></a>01500   dgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01501"></a>01501          &amp;D_ONE, C, &amp;ldC);
<a name="l01502"></a>01502 }
<a name="l01503"></a>01503 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d,
<a name="l01504"></a>01504                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B,
<a name="l01505"></a>01505                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB, <span class="keywordtype">float</span>* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01506"></a>01506 {
<a name="l01507"></a>01507   sgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01508"></a>01508          &amp;S_ONE, C, &amp;ldC);
<a name="l01509"></a>01509 }
<a name="l01510"></a>01510 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, scomp d,
<a name="l01511"></a>01511                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01512"></a>01512                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01513"></a>01513                    scomp* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01514"></a>01514 {
<a name="l01515"></a>01515   cgemm_(JOB_STR+7, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01516"></a>01516          &amp;C_ONE, C, &amp;ldC);
<a name="l01517"></a>01517 }
<a name="l01518"></a>01518 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, dcomp d,
<a name="l01519"></a>01519                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01520"></a>01520                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01521"></a>01521                    dcomp* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01522"></a>01522 {
<a name="l01523"></a>01523   zgemm_(JOB_STR+7, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01524"></a>01524          &amp;Z_ONE, C, &amp;ldC);
<a name="l01525"></a>01525 }
<a name="l01526"></a>01526 
<a name="l01527"></a>01527 
<a name="l01528"></a>01528 <span class="comment">// C += d A^T B, A is m x p, B is m x n</span>
<a name="l01529"></a>01529 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> d,
<a name="l01530"></a>01530                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B,
<a name="l01531"></a>01531                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB, <span class="keywordtype">double</span>* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01532"></a>01532 {
<a name="l01533"></a>01533   dgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01534"></a>01534          &amp;D_ONE, C, &amp;ldC);
<a name="l01535"></a>01535 }
<a name="l01536"></a>01536 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> d,
<a name="l01537"></a>01537                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B,
<a name="l01538"></a>01538                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB, <span class="keywordtype">float</span>* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01539"></a>01539 {
<a name="l01540"></a>01540   sgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01541"></a>01541          &amp;S_ONE, C, &amp;ldC);
<a name="l01542"></a>01542 }
<a name="l01543"></a>01543 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, scomp d,
<a name="l01544"></a>01544                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01545"></a>01545                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01546"></a>01546                    scomp* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01547"></a>01547 {
<a name="l01548"></a>01548   cgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01549"></a>01549          &amp;C_ONE, C, &amp;ldC);
<a name="l01550"></a>01550 }
<a name="l01551"></a>01551 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemtma(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, dcomp d,
<a name="l01552"></a>01552                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01553"></a>01553                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01554"></a>01554                    dcomp* C, <span class="keywordtype">unsigned</span> ldC)
<a name="l01555"></a>01555 {
<a name="l01556"></a>01556   zgemm_(JOB_STR+1, JOB_STR, &amp;p, &amp;n, &amp;m, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01557"></a>01557          &amp;Z_ONE, C, &amp;ldC);
<a name="l01558"></a>01558 }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 
<a name="l01561"></a>01561 <span class="comment">// C = d A B^H, A is m x p, B is n x p</span>
<a name="l01562"></a>01562 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01563"></a>01563                   <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01564"></a>01564                   <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01565"></a>01565                   <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01566"></a>01566 {
<a name="l01567"></a>01567   dgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01568"></a>01568          &amp;D_ZERO, C, &amp;ldC);
<a name="l01569"></a>01569 }
<a name="l01570"></a>01570 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01571"></a>01571                   <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01572"></a>01572                   <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01573"></a>01573                   <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01574"></a>01574 {
<a name="l01575"></a>01575   sgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01576"></a>01576          &amp;S_ZERO, C, &amp;ldC);
<a name="l01577"></a>01577 }
<a name="l01578"></a>01578 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01579"></a>01579                   <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01580"></a>01580                   <span class="keyword">const</span> scomp *B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01581"></a>01581                   scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01582"></a>01582 {
<a name="l01583"></a>01583   cgemm_(JOB_STR, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01584"></a>01584          &amp;C_ZERO, C, &amp;ldC);
<a name="l01585"></a>01585 }
<a name="l01586"></a>01586 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01587"></a>01587                   <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01588"></a>01588                   <span class="keyword">const</span> dcomp *B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01589"></a>01589                   dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01590"></a>01590 {
<a name="l01591"></a>01591   zgemm_(JOB_STR, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01592"></a>01592          &amp;Z_ZERO, C, &amp;ldC);
<a name="l01593"></a>01593 }
<a name="l01594"></a>01594 
<a name="l01595"></a>01595 <span class="comment">// C = d A B^T, A is m x p, B is n x p</span>
<a name="l01596"></a>01596 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmt(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01597"></a>01597                   <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01598"></a>01598                   <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01599"></a>01599                   <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01600"></a>01600 {
<a name="l01601"></a>01601   dgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01602"></a>01602          &amp;D_ZERO, C, &amp;ldC);
<a name="l01603"></a>01603 }
<a name="l01604"></a>01604 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmt(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01605"></a>01605                   <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01606"></a>01606                   <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01607"></a>01607                   <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01608"></a>01608 {
<a name="l01609"></a>01609   sgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01610"></a>01610          &amp;S_ZERO, C, &amp;ldC);
<a name="l01611"></a>01611 }
<a name="l01612"></a>01612 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmt(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01613"></a>01613                   <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01614"></a>01614                   <span class="keyword">const</span> scomp *B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01615"></a>01615                   scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01616"></a>01616 {
<a name="l01617"></a>01617   cgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01618"></a>01618          &amp;C_ZERO, C, &amp;ldC);
<a name="l01619"></a>01619 }
<a name="l01620"></a>01620 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmt(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01621"></a>01621                   <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01622"></a>01622                   <span class="keyword">const</span> dcomp *B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01623"></a>01623                   dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01624"></a>01624 {
<a name="l01625"></a>01625   zgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01626"></a>01626          &amp;Z_ZERO, C, &amp;ldC);
<a name="l01627"></a>01627 }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 <span class="comment">// C += d A B^H, A is m x p, B is n x p</span>
<a name="l01631"></a>01631 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01632"></a>01632                    <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01633"></a>01633                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01634"></a>01634                    <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01635"></a>01635 {
<a name="l01636"></a>01636   dgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01637"></a>01637          &amp;D_ONE, C, &amp;ldC);
<a name="l01638"></a>01638 }
<a name="l01639"></a>01639 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01640"></a>01640                    <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01641"></a>01641                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01642"></a>01642                    <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01643"></a>01643 {
<a name="l01644"></a>01644   sgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01645"></a>01645          &amp;S_ONE, C, &amp;ldC);
<a name="l01646"></a>01646 }
<a name="l01647"></a>01647 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01648"></a>01648                    <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01649"></a>01649                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01650"></a>01650                    scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01651"></a>01651 {
<a name="l01652"></a>01652   cgemm_(JOB_STR, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01653"></a>01653          &amp;C_ONE, C, &amp;ldC);
<a name="l01654"></a>01654 }
<a name="l01655"></a>01655 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01656"></a>01656                    <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01657"></a>01657                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01658"></a>01658                    dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01659"></a>01659 {
<a name="l01660"></a>01660   zgemm_(JOB_STR, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01661"></a>01661          &amp;Z_ONE, C, &amp;ldC);
<a name="l01662"></a>01662 }
<a name="l01663"></a>01663 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01664"></a>01664                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01665"></a>01665                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01666"></a>01666                    <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01667"></a>01667 {
<a name="l01668"></a>01668   dgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;D_ONE, A, &amp;ldA, B, &amp;ldB,
<a name="l01669"></a>01669          &amp;D_ONE, C, &amp;ldC);
<a name="l01670"></a>01670 }
<a name="l01671"></a>01671 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01672"></a>01672                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01673"></a>01673                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01674"></a>01674                    <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01675"></a>01675 {
<a name="l01676"></a>01676   sgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;S_ONE, A, &amp;ldA, B, &amp;ldB,
<a name="l01677"></a>01677          &amp;S_ONE, C, &amp;ldC);
<a name="l01678"></a>01678 }
<a name="l01679"></a>01679 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01680"></a>01680                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01681"></a>01681                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01682"></a>01682                    scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01683"></a>01683 {
<a name="l01684"></a>01684   cgemm_(JOB_STR, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;C_ONE, A, &amp;ldA, B, &amp;ldB,
<a name="l01685"></a>01685          &amp;C_ONE, C, &amp;ldC);
<a name="l01686"></a>01686 }
<a name="l01687"></a>01687 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01688"></a>01688                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01689"></a>01689                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01690"></a>01690                    dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01691"></a>01691 {
<a name="l01692"></a>01692   zgemm_(JOB_STR, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;Z_ONE, A, &amp;ldA, B, &amp;ldB,
<a name="l01693"></a>01693          &amp;Z_ONE, C, &amp;ldC);
<a name="l01694"></a>01694 }
<a name="l01695"></a>01695 
<a name="l01696"></a>01696 
<a name="l01697"></a>01697 <span class="comment">// C += d A B^T, A is m x p, B is n x p</span>
<a name="l01698"></a>01698 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmta(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01699"></a>01699                    <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01700"></a>01700                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01701"></a>01701                    <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01702"></a>01702 {
<a name="l01703"></a>01703   dgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01704"></a>01704          &amp;D_ONE, C, &amp;ldC);
<a name="l01705"></a>01705 }
<a name="l01706"></a>01706 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmta(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01707"></a>01707                    <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01708"></a>01708                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01709"></a>01709                    <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01710"></a>01710 {
<a name="l01711"></a>01711   sgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01712"></a>01712          &amp;S_ONE, C, &amp;ldC);
<a name="l01713"></a>01713 }
<a name="l01714"></a>01714 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmta(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01715"></a>01715                    <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01716"></a>01716                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01717"></a>01717                    scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01718"></a>01718 {
<a name="l01719"></a>01719   cgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01720"></a>01720          &amp;C_ONE, C, &amp;ldC);
<a name="l01721"></a>01721 }
<a name="l01722"></a>01722 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemmta(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01723"></a>01723                    <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01724"></a>01724                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01725"></a>01725                    dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01726"></a>01726 {
<a name="l01727"></a>01727   zgemm_(JOB_STR, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01728"></a>01728          &amp;Z_ONE, C, &amp;ldC);
<a name="l01729"></a>01729 }
<a name="l01730"></a>01730 
<a name="l01731"></a>01731 
<a name="l01732"></a>01732 <span class="comment">// C = d A^H B^H, A is p x m, B is n x p</span>
<a name="l01733"></a>01733 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01734"></a>01734                    <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01735"></a>01735                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01736"></a>01736                    <span class="keywordtype">double</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01737"></a>01737 {
<a name="l01738"></a>01738   dgemm_(JOB_STR+1, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01739"></a>01739          &amp;D_ZERO, C, &amp;ldC);
<a name="l01740"></a>01740 }
<a name="l01741"></a>01741 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01742"></a>01742                    <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01743"></a>01743                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01744"></a>01744                    <span class="keywordtype">float</span>* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01745"></a>01745 {
<a name="l01746"></a>01746   sgemm_(JOB_STR+1, JOB_STR+1, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01747"></a>01747          &amp;S_ZERO, C, &amp;ldC);
<a name="l01748"></a>01748 }
<a name="l01749"></a>01749 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01750"></a>01750                    <span class="keyword">const</span> scomp d, <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01751"></a>01751                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01752"></a>01752                    scomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01753"></a>01753 {
<a name="l01754"></a>01754   cgemm_(JOB_STR+7, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01755"></a>01755          &amp;C_ZERO, C, &amp;ldC);
<a name="l01756"></a>01756 }
<a name="l01757"></a>01757 <span class="keyword">inline</span> <span class="keywordtype">void</span> gemhmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01758"></a>01758                    <span class="keyword">const</span> dcomp d, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l01759"></a>01759                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB,
<a name="l01760"></a>01760                    dcomp* C, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC)
<a name="l01761"></a>01761 {
<a name="l01762"></a>01762   zgemm_(JOB_STR+7, JOB_STR+7, &amp;m, &amp;n, &amp;p, &amp;d, A, &amp;ldA, B, &amp;ldB,
<a name="l01763"></a>01763          &amp;Z_ZERO, C, &amp;ldC);
<a name="l01764"></a>01764 }
<a name="l01765"></a>01765 
<a name="l01766"></a>01766 <span class="comment">//C += d*AB, A is mxm (packed upper half is stored), B is mxn and regular matrix</span>
<a name="l01767"></a>01767 <span class="keyword">inline</span> <span class="keywordtype">void</span> sygemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01768"></a>01768                     <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B,
<a name="l01769"></a>01769                     <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keywordtype">double</span>* <span class="keyword">const</span> C)
<a name="l01770"></a>01770 {
<a name="l01771"></a>01771   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01772"></a>01772     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01773"></a>01773       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=i; k&lt;m; k++) {
<a name="l01774"></a>01774         <span class="keywordflow">if</span> (i==k) {
<a name="l01775"></a>01775           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01776"></a>01776         } <span class="keywordflow">else</span> {
<a name="l01777"></a>01777           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01778"></a>01778           C[j*m+k] += d*A[i+k*(k+1)/2]*B[i+j*m];
<a name="l01779"></a>01779         }
<a name="l01780"></a>01780       }
<a name="l01781"></a>01781     }
<a name="l01782"></a>01782   }
<a name="l01783"></a>01783 }
<a name="l01784"></a>01784 <span class="keyword">inline</span> <span class="keywordtype">void</span> sygemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01785"></a>01785                     <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B,
<a name="l01786"></a>01786                     <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keywordtype">float</span>* <span class="keyword">const</span> C)
<a name="l01787"></a>01787 {
<a name="l01788"></a>01788   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01789"></a>01789     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01790"></a>01790       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=i; k&lt;m; k++) {
<a name="l01791"></a>01791         <span class="keywordflow">if</span> (i==k) {
<a name="l01792"></a>01792           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01793"></a>01793         } <span class="keywordflow">else</span> {
<a name="l01794"></a>01794           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01795"></a>01795           C[j*m+k] += d*A[i+k*(k+1)/2]*B[i+j*m];
<a name="l01796"></a>01796         }
<a name="l01797"></a>01797       }
<a name="l01798"></a>01798     }
<a name="l01799"></a>01799   }
<a name="l01800"></a>01800 }
<a name="l01801"></a>01801 <span class="keyword">inline</span> <span class="keywordtype">void</span> sygemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01802"></a>01802                     <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B,
<a name="l01803"></a>01803                     <span class="keyword">const</span> dcomp d, dcomp* <span class="keyword">const</span> C)
<a name="l01804"></a>01804 {
<a name="l01805"></a>01805   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01806"></a>01806     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01807"></a>01807       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=i; k&lt;m; k++) {
<a name="l01808"></a>01808         <span class="keywordflow">if</span> (i==k) {
<a name="l01809"></a>01809           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01810"></a>01810         } <span class="keywordflow">else</span> {
<a name="l01811"></a>01811           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01812"></a>01812           C[j*m+k] += d*A[i+k*(k+1)/2]*B[i+j*m];
<a name="l01813"></a>01813         }
<a name="l01814"></a>01814       }
<a name="l01815"></a>01815     }
<a name="l01816"></a>01816   }
<a name="l01817"></a>01817 }
<a name="l01818"></a>01818 <span class="keyword">inline</span> <span class="keywordtype">void</span> sygemma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01819"></a>01819                     <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> scomp* <span class="keyword">const</span> B,
<a name="l01820"></a>01820                     <span class="keyword">const</span> scomp d, scomp* <span class="keyword">const</span> C)
<a name="l01821"></a>01821 {
<a name="l01822"></a>01822   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01823"></a>01823     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01824"></a>01824       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=i; k&lt;m; k++) {
<a name="l01825"></a>01825         <span class="keywordflow">if</span> (i==k) {
<a name="l01826"></a>01826           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01827"></a>01827         } <span class="keywordflow">else</span> {
<a name="l01828"></a>01828           C[j*m+i] += d*A[i+k*(k+1)/2]*B[k+j*m];
<a name="l01829"></a>01829           C[j*m+k] += d*A[i+k*(k+1)/2]*B[i+j*m];
<a name="l01830"></a>01830         }
<a name="l01831"></a>01831       }
<a name="l01832"></a>01832     }
<a name="l01833"></a>01833   }
<a name="l01834"></a>01834 }
<a name="l01835"></a>01835 
<a name="l01836"></a>01836 <span class="comment">//C += d*AB, A is mxn and regular matrix, B is nxn (packed upper half is stored)</span>
<a name="l01837"></a>01837 <span class="keyword">inline</span> <span class="keywordtype">void</span> gesymma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01838"></a>01838                     <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> B,
<a name="l01839"></a>01839                     <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keywordtype">double</span>* <span class="keyword">const</span> C)
<a name="l01840"></a>01840 {
<a name="l01841"></a>01841   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01842"></a>01842     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01843"></a>01843       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j; k&lt;n; k++) {
<a name="l01844"></a>01844         <span class="keywordflow">if</span> (j==k)
<a name="l01845"></a>01845           C[j*m+i] += d*A[i+k*m]*B[k+j*(j+1)/2];
<a name="l01846"></a>01846         <span class="keywordflow">else</span> {
<a name="l01847"></a>01847           C[j*m+i] += d*A[i+k*m]*B[j+k*(k+1)/2];
<a name="l01848"></a>01848           C[k*m+i] += d*A[i+j*m]*B[j+k*(k+1)/2];
<a name="l01849"></a>01849         }
<a name="l01850"></a>01850       }
<a name="l01851"></a>01851     }
<a name="l01852"></a>01852   }
<a name="l01853"></a>01853 }
<a name="l01854"></a>01854 <span class="keyword">inline</span> <span class="keywordtype">void</span> gesymma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01855"></a>01855                     <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> B,
<a name="l01856"></a>01856                     <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keywordtype">float</span>* <span class="keyword">const</span> C)
<a name="l01857"></a>01857 {
<a name="l01858"></a>01858   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01859"></a>01859     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01860"></a>01860       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j; k&lt;n; k++) {
<a name="l01861"></a>01861         <span class="keywordflow">if</span> (j==k)
<a name="l01862"></a>01862           C[j*m+i] += d*A[i+k*m]*B[k+j*(j+1)/2];
<a name="l01863"></a>01863         <span class="keywordflow">else</span> {
<a name="l01864"></a>01864           C[j*m+i] += d*A[i+k*m]*B[j+k*(k+1)/2];
<a name="l01865"></a>01865           C[k*m+i] += d*A[i+j*m]*B[j+k*(k+1)/2];
<a name="l01866"></a>01866         }
<a name="l01867"></a>01867       }
<a name="l01868"></a>01868     }
<a name="l01869"></a>01869   }
<a name="l01870"></a>01870 }
<a name="l01871"></a>01871 <span class="keyword">inline</span> <span class="keywordtype">void</span> gesymma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01872"></a>01872                     <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> scomp* <span class="keyword">const</span> B,
<a name="l01873"></a>01873                     <span class="keyword">const</span> scomp d, scomp* <span class="keyword">const</span> C)
<a name="l01874"></a>01874 {
<a name="l01875"></a>01875   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01876"></a>01876     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01877"></a>01877       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j; k&lt;n; k++) {
<a name="l01878"></a>01878         <span class="keywordflow">if</span> (j==k)
<a name="l01879"></a>01879           C[j*m+i] += d*A[i+k*m]*B[k+j*(j+1)/2];
<a name="l01880"></a>01880         <span class="keywordflow">else</span> {
<a name="l01881"></a>01881           C[j*m+i] += d*A[i+k*m]*B[j+k*(k+1)/2];
<a name="l01882"></a>01882           C[k*m+i] += d*A[i+j*m]*B[j+k*(k+1)/2];
<a name="l01883"></a>01883         }
<a name="l01884"></a>01884       }
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886   }
<a name="l01887"></a>01887 }
<a name="l01888"></a>01888 <span class="keyword">inline</span> <span class="keywordtype">void</span> gesymma(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l01889"></a>01889                     <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> dcomp* <span class="keyword">const</span> B,
<a name="l01890"></a>01890                     <span class="keyword">const</span> dcomp d, dcomp* <span class="keyword">const</span> C)
<a name="l01891"></a>01891 {
<a name="l01892"></a>01892   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++) {
<a name="l01893"></a>01893     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l01894"></a>01894       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j; k&lt;n; k++) {
<a name="l01895"></a>01895         <span class="keywordflow">if</span> (j==k)
<a name="l01896"></a>01896           C[j*m+i] += d*A[i+k*m]*B[k+j*(j+1)/2];
<a name="l01897"></a>01897         <span class="keywordflow">else</span> {
<a name="l01898"></a>01898           C[j*m+i] += d*A[i+k*m]*B[j+k*(k+1)/2];
<a name="l01899"></a>01899           C[k*m+i] += d*A[i+j*m]*B[j+k*(k+1)/2];
<a name="l01900"></a>01900         }
<a name="l01901"></a>01901       }
<a name="l01902"></a>01902     }
<a name="l01903"></a>01903   }
<a name="l01904"></a>01904 }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906 
<a name="l01907"></a>01907 <span class="comment">// C += d A^H A, C is a symm. matrix (packed upper half is stored), A is mxn</span>
<a name="l01908"></a>01908 <span class="keyword">inline</span> <span class="keywordtype">void</span> symhm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A,
<a name="l01909"></a>01909                   <span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keywordtype">double</span>* C)
<a name="l01910"></a>01910 {
<a name="l01911"></a>01911   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l01912"></a>01912     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) {
<a name="l01913"></a>01913       <span class="keywordtype">double</span> sum = 0.0;
<a name="l01914"></a>01914       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;m; ++k) sum += A[k+i*m] * A[k+j*m];
<a name="l01915"></a>01915       C[i+j*(j+1)/2] += d * sum;
<a name="l01916"></a>01916     }
<a name="l01917"></a>01917   }
<a name="l01918"></a>01918 }
<a name="l01919"></a>01919 <span class="keyword">inline</span> <span class="keywordtype">void</span> symhm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A,
<a name="l01920"></a>01920                   <span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keywordtype">float</span>* C)
<a name="l01921"></a>01921 {
<a name="l01922"></a>01922   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l01923"></a>01923     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) {
<a name="l01924"></a>01924       <span class="keywordtype">float</span> sum = 0.0;
<a name="l01925"></a>01925       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;m; ++k) sum += A[k+i*m] * A[k+j*m];
<a name="l01926"></a>01926       C[i+j*(j+1)/2] += d * sum;
<a name="l01927"></a>01927     }
<a name="l01928"></a>01928   }
<a name="l01929"></a>01929 }
<a name="l01930"></a>01930 <span class="keyword">inline</span> <span class="keywordtype">void</span> symhm(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, scomp* A, scomp d, scomp* C)
<a name="l01931"></a>01931 {
<a name="l01932"></a>01932   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l01933"></a>01933     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) {
<a name="l01934"></a>01934       scomp sum = C_ZERO;
<a name="l01935"></a>01935       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;m; ++k) sum += conj(A[k+i*m]) * A[k+j*m];
<a name="l01936"></a>01936       C[i+j*(j+1)/2] += d * sum;
<a name="l01937"></a>01937     }
<a name="l01938"></a>01938   }
<a name="l01939"></a>01939 }
<a name="l01940"></a>01940 <span class="keyword">inline</span> <span class="keywordtype">void</span> symhm(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, dcomp* A, dcomp d, dcomp* C)
<a name="l01941"></a>01941 {
<a name="l01942"></a>01942   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l01943"></a>01943     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) {
<a name="l01944"></a>01944       dcomp sum = Z_ZERO;
<a name="l01945"></a>01945       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;m; ++k) sum += conj(A[k+i*m]) * A[k+j*m];
<a name="l01946"></a>01946       C[i+j*(j+1)/2] += d * sum;
<a name="l01947"></a>01947     }
<a name="l01948"></a>01948   }
<a name="l01949"></a>01949 }
<a name="l01950"></a>01950 
<a name="l01951"></a>01951 <span class="comment">// C += d A A^H, C is a symm. matrix (packed upper half is stored), A is mxn</span>
<a name="l01952"></a>01952 <span class="keyword">inline</span> <span class="keywordtype">void</span> symmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span> d, <span class="keywordtype">double</span>* C)
<a name="l01953"></a>01953 {
<a name="l01954"></a>01954   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;n; ++k) {
<a name="l01955"></a>01955     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;=n; ++j) {
<a name="l01956"></a>01956       <span class="keywordtype">double</span> e = d * A[j+k*m];
<a name="l01957"></a>01957       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;j; ++i) C[i+j*(j+1)/2] += e * A[i+k*m];
<a name="l01958"></a>01958     }
<a name="l01959"></a>01959   }
<a name="l01960"></a>01960 }
<a name="l01961"></a>01961 <span class="keyword">inline</span> <span class="keywordtype">void</span> symmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span> d, <span class="keywordtype">float</span>* C)
<a name="l01962"></a>01962 {
<a name="l01963"></a>01963   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;n; ++k) {
<a name="l01964"></a>01964     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l01965"></a>01965       <span class="keywordtype">float</span> e = d * A[j+k*m];
<a name="l01966"></a>01966       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) C[i+j*(j+1)/2] += e * A[i+k*m];
<a name="l01967"></a>01967     }
<a name="l01968"></a>01968   }
<a name="l01969"></a>01969 }
<a name="l01970"></a>01970 <span class="keyword">inline</span> <span class="keywordtype">void</span> symmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, scomp* A, scomp d, scomp* C)
<a name="l01971"></a>01971 {
<a name="l01972"></a>01972   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;n; ++k) {
<a name="l01973"></a>01973     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l01974"></a>01974       scomp e = d * conj(A[j+k*m]);
<a name="l01975"></a>01975       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) C[i+j*(j+1)/2] += e * A[i+k*m];
<a name="l01976"></a>01976     }
<a name="l01977"></a>01977   }
<a name="l01978"></a>01978 }
<a name="l01979"></a>01979 <span class="keyword">inline</span> <span class="keywordtype">void</span> symmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, dcomp* A, dcomp d, dcomp* C)
<a name="l01980"></a>01980 {
<a name="l01981"></a>01981   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;n; ++k) {
<a name="l01982"></a>01982     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l01983"></a>01983       dcomp e = d * conj(A[j+k*m]);
<a name="l01984"></a>01984       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) C[i+j*(j+1)/2] += e * A[i+k*m];
<a name="l01985"></a>01985     }
<a name="l01986"></a>01986   }
<a name="l01987"></a>01987 }
<a name="l01988"></a>01988 <span class="comment">// Singular Value Decomposition</span>
<a name="l01989"></a>01989 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvdS(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* S,
<a name="l01990"></a>01990                   <span class="keywordtype">double</span>* U, <span class="keywordtype">unsigned</span> ldU, <span class="keywordtype">double</span>* VT, <span class="keywordtype">unsigned</span> ldVT,
<a name="l01991"></a>01991                   <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l01992"></a>01992 {
<a name="l01993"></a>01993   <span class="keywordtype">int</span> INF;
<a name="l01994"></a>01994   dgesvd_(JOB_STR+3, JOB_STR+3, &amp;m, &amp;n, A, &amp;m, S, U, &amp;ldU, VT, &amp;ldVT,
<a name="l01995"></a>01995           wk, &amp;nwk, &amp;INF);
<a name="l01996"></a>01996   <span class="keywordflow">return</span> INF;
<a name="l01997"></a>01997 }
<a name="l01998"></a>01998 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* S,
<a name="l01999"></a>01999                  <span class="keywordtype">double</span>* VT, <span class="keywordtype">unsigned</span> ldVT, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02000"></a>02000 {
<a name="l02001"></a>02001   <span class="keywordtype">int</span> INF;
<a name="l02002"></a>02002   dgesvd_(JOB_STR+2, JOB_STR+3, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, VT, &amp;ldVT,
<a name="l02003"></a>02003           wk, &amp;nwk, &amp;INF);
<a name="l02004"></a>02004   <span class="keywordflow">return</span> INF;
<a name="l02005"></a>02005 }
<a name="l02006"></a>02006 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* S,
<a name="l02007"></a>02007                  <span class="keywordtype">float</span>* VT, <span class="keywordtype">unsigned</span> ldVT, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02008"></a>02008 {
<a name="l02009"></a>02009   <span class="keywordtype">int</span> INF;
<a name="l02010"></a>02010   sgesvd_(JOB_STR+2, JOB_STR+3, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, VT, &amp;ldVT,
<a name="l02011"></a>02011           wk, &amp;nwk, &amp;INF);
<a name="l02012"></a>02012   <span class="keywordflow">return</span> INF;
<a name="l02013"></a>02013 }
<a name="l02014"></a>02014 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">double</span>* S,
<a name="l02015"></a>02015                  <span class="keywordtype">float</span>* VT, <span class="keywordtype">unsigned</span> ldVT, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02016"></a>02016 {
<a name="l02017"></a>02017   <span class="keywordtype">int</span> INF;
<a name="l02018"></a>02018   <span class="comment">// workaround (needs to be improved)</span>
<a name="l02019"></a>02019   <span class="keywordtype">float</span>* Sf = <span class="keyword">new</span> <span class="keywordtype">float</span>[MIN(m,n)];
<a name="l02020"></a>02020   sgesvd_(JOB_STR+2, JOB_STR+3, &amp;m, &amp;n, A, &amp;m, Sf, A, &amp;m, VT, &amp;ldVT,
<a name="l02021"></a>02021           wk, &amp;nwk, &amp;INF);
<a name="l02022"></a>02022   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;MIN(m,n); i++)
<a name="l02023"></a>02023     S[i] = (<span class="keywordtype">double</span>)Sf[i];
<a name="l02024"></a>02024   <span class="keyword">delete</span> [] Sf;
<a name="l02025"></a>02025   <span class="keywordflow">return</span> INF;
<a name="l02026"></a>02026 }
<a name="l02027"></a>02027 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">float</span>* S,
<a name="l02028"></a>02028                  scomp* VT, <span class="keywordtype">unsigned</span> ldVT, <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02029"></a>02029 {
<a name="l02030"></a>02030   <span class="keywordtype">int</span> INF;
<a name="l02031"></a>02031   <span class="keywordtype">float</span>* rwk = <span class="keyword">new</span> <span class="keywordtype">float</span>[5*MIN(m,n)];
<a name="l02032"></a>02032   cgesvd_(JOB_STR+2, JOB_STR+3, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, VT, &amp;ldVT,
<a name="l02033"></a>02033           wk, &amp;nwk, rwk, &amp;INF);
<a name="l02034"></a>02034   <span class="keyword">delete</span> [] rwk;
<a name="l02035"></a>02035   <span class="keywordflow">return</span> INF;
<a name="l02036"></a>02036 }
<a name="l02037"></a>02037 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">double</span>* S,
<a name="l02038"></a>02038                  scomp* VT, <span class="keywordtype">unsigned</span> ldVT, <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02039"></a>02039 {
<a name="l02040"></a>02040   <span class="keywordtype">int</span> INF;
<a name="l02041"></a>02041   <span class="keywordtype">float</span>* rwk = <span class="keyword">new</span> <span class="keywordtype">float</span>[nwk];
<a name="l02042"></a>02042   <span class="comment">// workaround (needs to be improved)</span>
<a name="l02043"></a>02043   <span class="keywordtype">float</span>* Sf = <span class="keyword">new</span> <span class="keywordtype">float</span>[MIN(m,n)];
<a name="l02044"></a>02044   cgesvd_(JOB_STR+2, JOB_STR+3, &amp;m, &amp;n, A, &amp;m, Sf, A, &amp;m, VT, &amp;ldVT,
<a name="l02045"></a>02045           wk, &amp;nwk, rwk, &amp;INF);
<a name="l02046"></a>02046   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;MIN(m,n); i++)
<a name="l02047"></a>02047     S[i] = Sf[i];
<a name="l02048"></a>02048   <span class="keyword">delete</span> [] Sf;
<a name="l02049"></a>02049   <span class="keyword">delete</span> [] rwk;
<a name="l02050"></a>02050   <span class="keywordflow">return</span> INF;
<a name="l02051"></a>02051 }
<a name="l02052"></a>02052 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keywordtype">double</span>* S,
<a name="l02053"></a>02053                  dcomp* VT, <span class="keywordtype">unsigned</span> ldVT, <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02054"></a>02054 {
<a name="l02055"></a>02055   <span class="keywordtype">int</span> INF;
<a name="l02056"></a>02056   <span class="keywordtype">double</span>* rwk = <span class="keyword">new</span> <span class="keywordtype">double</span>[5*MIN(m,n)];
<a name="l02057"></a>02057   zgesvd_(JOB_STR+2, JOB_STR+3, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, VT, &amp;ldVT,
<a name="l02058"></a>02058           wk, &amp;nwk, rwk, &amp;INF);
<a name="l02059"></a>02059   <span class="keyword">delete</span> [] rwk;
<a name="l02060"></a>02060   <span class="keywordflow">return</span> INF;
<a name="l02061"></a>02061 }
<a name="l02062"></a>02062 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* S,
<a name="l02063"></a>02063                  <span class="keywordtype">double</span>* U, <span class="keywordtype">unsigned</span> ldU, <span class="keywordtype">double</span>* VT, <span class="keywordtype">unsigned</span> ldVT,
<a name="l02064"></a>02064                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02065"></a>02065 {
<a name="l02066"></a>02066   <span class="keywordtype">int</span> INF;
<a name="l02067"></a>02067   dgesvd_(JOB_STR+9, JOB_STR+9, &amp;m, &amp;n, A, &amp;m, S, U, &amp;ldU, VT, &amp;ldVT,
<a name="l02068"></a>02068           wk, &amp;nwk, &amp;INF);
<a name="l02069"></a>02069   <span class="keywordflow">return</span> INF;
<a name="l02070"></a>02070 }
<a name="l02071"></a>02071 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">double</span>* S,
<a name="l02072"></a>02072                  <span class="keywordtype">float</span>* U, <span class="keywordtype">unsigned</span> ldU, <span class="keywordtype">float</span>* VT, <span class="keywordtype">unsigned</span> ldVT,
<a name="l02073"></a>02073                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02074"></a>02074 {
<a name="l02075"></a>02075   <span class="keywordtype">int</span> INF;
<a name="l02076"></a>02076   <span class="comment">// workaround (needs to be improved)</span>
<a name="l02077"></a>02077   <span class="keywordtype">float</span>* Sf = <span class="keyword">new</span> <span class="keywordtype">float</span>[MIN(m,n)];
<a name="l02078"></a>02078   sgesvd_(JOB_STR+9, JOB_STR+9, &amp;m, &amp;n, A, &amp;m, Sf, U, &amp;ldU, VT, &amp;ldVT,
<a name="l02079"></a>02079           wk, &amp;nwk, &amp;INF);
<a name="l02080"></a>02080   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;MIN(m,n); i++)
<a name="l02081"></a>02081     S[i] = Sf[i];
<a name="l02082"></a>02082   <span class="keyword">delete</span> [] Sf;
<a name="l02083"></a>02083   <span class="keywordflow">return</span> INF;
<a name="l02084"></a>02084 }
<a name="l02085"></a>02085 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">double</span>* S,
<a name="l02086"></a>02086                  scomp* U, <span class="keywordtype">unsigned</span> ldU, scomp* VT, <span class="keywordtype">unsigned</span> ldVT,
<a name="l02087"></a>02087                  <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02088"></a>02088 {
<a name="l02089"></a>02089   <span class="keywordtype">int</span> INF;
<a name="l02090"></a>02090   <span class="keywordtype">float</span>* rwk = <span class="keyword">new</span> <span class="keywordtype">float</span>[nwk];
<a name="l02091"></a>02091   <span class="comment">// workaround (needs to be improved)</span>
<a name="l02092"></a>02092   <span class="keywordtype">float</span>* Sf = <span class="keyword">new</span> <span class="keywordtype">float</span>[MIN(m,n)];
<a name="l02093"></a>02093   cgesvd_(JOB_STR+9, JOB_STR+9, &amp;m, &amp;n, A, &amp;m, Sf, U, &amp;ldU, VT, &amp;ldVT,
<a name="l02094"></a>02094           wk, &amp;nwk, rwk, &amp;INF);
<a name="l02095"></a>02095   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;MIN(m,n); i++)
<a name="l02096"></a>02096     S[i] = Sf[i];
<a name="l02097"></a>02097   <span class="keyword">delete</span> [] Sf;
<a name="l02098"></a>02098   <span class="keyword">delete</span> [] rwk;
<a name="l02099"></a>02099   <span class="keywordflow">return</span> INF;
<a name="l02100"></a>02100 }
<a name="l02101"></a>02101 <span class="keyword">inline</span> <span class="keywordtype">int</span> gesvd(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keywordtype">double</span>* S,
<a name="l02102"></a>02102                  dcomp* U, <span class="keywordtype">unsigned</span> ldU, dcomp* VT, <span class="keywordtype">unsigned</span> ldVT,
<a name="l02103"></a>02103                  <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02104"></a>02104 {
<a name="l02105"></a>02105   <span class="keywordtype">int</span> INF;
<a name="l02106"></a>02106   <span class="keywordtype">double</span>* rwk = <span class="keyword">new</span> <span class="keywordtype">double</span>[5*MIN(n,m)];
<a name="l02107"></a>02107   zgesvd_(JOB_STR+9, JOB_STR+9, &amp;m, &amp;n, A, &amp;m, S, U, &amp;ldU, VT, &amp;ldVT,
<a name="l02108"></a>02108           wk, &amp;nwk, rwk, &amp;INF);
<a name="l02109"></a>02109   <span class="keyword">delete</span> [] rwk;
<a name="l02110"></a>02110   <span class="keywordflow">return</span> INF;
<a name="l02111"></a>02111 }
<a name="l02112"></a>02112 
<a name="l02113"></a>02113 <span class="comment">// compute singular values</span>
<a name="l02114"></a>02114 <span class="keyword">inline</span> <span class="keywordtype">int</span> svals(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* S,
<a name="l02115"></a>02115                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02116"></a>02116 {
<a name="l02117"></a>02117   <span class="keywordtype">int</span> INF;
<a name="l02118"></a>02118   dgesvd_(JOB_STR, JOB_STR, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, A, &amp;n, wk, &amp;nwk, &amp;INF);
<a name="l02119"></a>02119   <span class="keywordflow">return</span> INF;
<a name="l02120"></a>02120 }
<a name="l02121"></a>02121 <span class="keyword">inline</span> <span class="keywordtype">int</span> svals(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* S,
<a name="l02122"></a>02122                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02123"></a>02123 {
<a name="l02124"></a>02124   <span class="keywordtype">int</span> INF;
<a name="l02125"></a>02125   sgesvd_(JOB_STR, JOB_STR, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, A, &amp;n, wk, &amp;nwk, &amp;INF);
<a name="l02126"></a>02126   <span class="keywordflow">return</span> INF;
<a name="l02127"></a>02127 }
<a name="l02128"></a>02128 <span class="keyword">inline</span> <span class="keywordtype">int</span> svals(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">float</span>* S,
<a name="l02129"></a>02129                  <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02130"></a>02130 {
<a name="l02131"></a>02131   <span class="keywordtype">int</span> INF;
<a name="l02132"></a>02132   <span class="keywordtype">float</span> *rwk = <span class="keyword">new</span> <span class="keywordtype">float</span>[5*MIN(m,n)];
<a name="l02133"></a>02133   cgesvd_(JOB_STR, JOB_STR, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, A, &amp;n,
<a name="l02134"></a>02134           wk, &amp;nwk, rwk, &amp;INF);
<a name="l02135"></a>02135   <span class="keyword">delete</span> [] rwk;
<a name="l02136"></a>02136   <span class="keywordflow">return</span> INF;
<a name="l02137"></a>02137 }
<a name="l02138"></a>02138 <span class="keyword">inline</span> <span class="keywordtype">int</span> svals(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keywordtype">double</span>* S,
<a name="l02139"></a>02139                  <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02140"></a>02140 {
<a name="l02141"></a>02141   <span class="keywordtype">int</span> INF;
<a name="l02142"></a>02142   <span class="keywordtype">double</span> *rwk = <span class="keyword">new</span> <span class="keywordtype">double</span>[5*MIN(m,n)];
<a name="l02143"></a>02143   zgesvd_(JOB_STR, JOB_STR, &amp;m, &amp;n, A, &amp;m, S, A, &amp;m, A, &amp;n,
<a name="l02144"></a>02144           wk, &amp;nwk, rwk, &amp;INF);
<a name="l02145"></a>02145   <span class="keyword">delete</span> [] rwk;
<a name="l02146"></a>02146   <span class="keywordflow">return</span> INF;
<a name="l02147"></a>02147 }
<a name="l02148"></a>02148 
<a name="l02149"></a>02149 
<a name="l02150"></a>02150 <span class="comment">// triangular factorisation</span>
<a name="l02151"></a>02151 <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02152"></a>02152 {
<a name="l02153"></a>02153   <span class="keywordtype">int</span> INF;
<a name="l02154"></a>02154   dgetrf_(&amp;n, &amp;n, A, &amp;n, ipiv, &amp;INF);
<a name="l02155"></a>02155   <span class="keywordflow">return</span> INF;
<a name="l02156"></a>02156 }
<a name="l02157"></a>02157 <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02158"></a>02158 {
<a name="l02159"></a>02159   <span class="keywordtype">int</span> INF;
<a name="l02160"></a>02160   sgetrf_(&amp;n, &amp;n, A, &amp;n, ipiv, &amp;INF);
<a name="l02161"></a>02161   <span class="keywordflow">return</span> INF;
<a name="l02162"></a>02162 }
<a name="l02163"></a>02163 <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02164"></a>02164 {
<a name="l02165"></a>02165   <span class="keywordtype">int</span> INF;
<a name="l02166"></a>02166   cgetrf_(&amp;n, &amp;n, A, &amp;n, ipiv, &amp;INF);
<a name="l02167"></a>02167   <span class="keywordflow">return</span> INF;
<a name="l02168"></a>02168 }
<a name="l02169"></a>02169 <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02170"></a>02170 {
<a name="l02171"></a>02171   <span class="keywordtype">int</span> INF;
<a name="l02172"></a>02172   zgetrf_(&amp;n, &amp;n, A, &amp;n, ipiv, &amp;INF);
<a name="l02173"></a>02173   <span class="keywordflow">return</span> INF;
<a name="l02174"></a>02174 }
<a name="l02175"></a>02175 <span class="comment">// triangular factorisation A is m by n</span>
<a name="l02176"></a>02176   <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02177"></a>02177   {
<a name="l02178"></a>02178     <span class="keywordtype">int</span> INF;
<a name="l02179"></a>02179     dgetrf_(&amp;m, &amp;n, A, &amp;m, ipiv, &amp;INF); 
<a name="l02180"></a>02180     <span class="keywordflow">return</span> INF;
<a name="l02181"></a>02181   }
<a name="l02182"></a>02182   <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02183"></a>02183   {
<a name="l02184"></a>02184     <span class="keywordtype">int</span> INF;
<a name="l02185"></a>02185     sgetrf_(&amp;m, &amp;n, A, &amp;m, ipiv, &amp;INF);
<a name="l02186"></a>02186     <span class="keywordflow">return</span> INF;
<a name="l02187"></a>02187   }
<a name="l02188"></a>02188   <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02189"></a>02189   {
<a name="l02190"></a>02190     <span class="keywordtype">int</span> INF;
<a name="l02191"></a>02191     cgetrf_(&amp;m, &amp;n, A, &amp;m, ipiv, &amp;INF);
<a name="l02192"></a>02192     <span class="keywordflow">return</span> INF;
<a name="l02193"></a>02193   }
<a name="l02194"></a>02194   <span class="keyword">inline</span> <span class="keywordtype">int</span> getrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keywordtype">unsigned</span>* ipiv)
<a name="l02195"></a>02195   {
<a name="l02196"></a>02196     <span class="keywordtype">int</span> INF;
<a name="l02197"></a>02197     zgetrf_(&amp;m, &amp;n, A, &amp;m, ipiv, &amp;INF);
<a name="l02198"></a>02198     <span class="keywordflow">return</span> INF;
<a name="l02199"></a>02199   }
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 <span class="comment">// upper triangular packed MV</span>
<a name="l02202"></a>02202 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrpv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* x)
<a name="l02203"></a>02203 {
<a name="l02204"></a>02204   dtpmv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, x, &amp;N_ONE);
<a name="l02205"></a>02205 }
<a name="l02206"></a>02206 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrpv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* x)
<a name="l02207"></a>02207 {
<a name="l02208"></a>02208   stpmv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, x, &amp;N_ONE);
<a name="l02209"></a>02209 }
<a name="l02210"></a>02210 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrpv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, scomp* x)
<a name="l02211"></a>02211 {
<a name="l02212"></a>02212   ctpmv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, x, &amp;N_ONE);
<a name="l02213"></a>02213 }
<a name="l02214"></a>02214 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrpv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, dcomp* x)
<a name="l02215"></a>02215 {
<a name="l02216"></a>02216   ztpmv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, x, &amp;N_ONE);
<a name="l02217"></a>02217 }
<a name="l02218"></a>02218 
<a name="l02219"></a>02219 <span class="comment">// lower triangular packed transpose MV</span>
<a name="l02220"></a>02220 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrphv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* x)
<a name="l02221"></a>02221 {
<a name="l02222"></a>02222   dtpmv_(JOB_STR+6, JOB_STR+1, JOB_STR+5, &amp;n, A, x, &amp;N_ONE);
<a name="l02223"></a>02223 }
<a name="l02224"></a>02224 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrphv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* x)
<a name="l02225"></a>02225 {
<a name="l02226"></a>02226   stpmv_(JOB_STR+6, JOB_STR+1, JOB_STR+5, &amp;n, A, x, &amp;N_ONE);
<a name="l02227"></a>02227 }
<a name="l02228"></a>02228 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrphv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, scomp* x)
<a name="l02229"></a>02229 {
<a name="l02230"></a>02230   ctpmv_(JOB_STR+6, JOB_STR+7, JOB_STR+5, &amp;n, A, x, &amp;N_ONE);
<a name="l02231"></a>02231 }
<a name="l02232"></a>02232 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrphv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, dcomp* x)
<a name="l02233"></a>02233 {
<a name="l02234"></a>02234   ztpmv_(JOB_STR+6, JOB_STR+7, JOB_STR+5, &amp;n, A, x, &amp;N_ONE);
<a name="l02235"></a>02235 }
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 <span class="comment">// QR factorisation</span>
<a name="l02238"></a>02238 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l02239"></a>02239                  <span class="keywordtype">double</span>* tau, <span class="keywordtype">int</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02240"></a>02240 {
<a name="l02241"></a>02241   <span class="keywordtype">int</span> INF;
<a name="l02242"></a>02242   dgeqrf_(&amp;m, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02243"></a>02243   <span class="keywordflow">return</span> INF;
<a name="l02244"></a>02244 }
<a name="l02245"></a>02245 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l02246"></a>02246                  <span class="keywordtype">float</span>* tau, <span class="keywordtype">int</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02247"></a>02247 {
<a name="l02248"></a>02248   <span class="keywordtype">int</span> INF;
<a name="l02249"></a>02249   sgeqrf_(&amp;m, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02250"></a>02250   <span class="keywordflow">return</span> INF;
<a name="l02251"></a>02251 }
<a name="l02252"></a>02252 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l02253"></a>02253                  scomp* tau, <span class="keywordtype">int</span> nwk, scomp* wk)
<a name="l02254"></a>02254 {
<a name="l02255"></a>02255   <span class="keywordtype">int</span> INF;
<a name="l02256"></a>02256   cgeqrf_(&amp;m, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02257"></a>02257   <span class="keywordflow">return</span> INF;
<a name="l02258"></a>02258 }
<a name="l02259"></a>02259 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l02260"></a>02260                  dcomp* tau, <span class="keywordtype">int</span> nwk, dcomp* wk)
<a name="l02261"></a>02261 {
<a name="l02262"></a>02262   <span class="keywordtype">int</span> INF;
<a name="l02263"></a>02263   zgeqrf_(&amp;m, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02264"></a>02264   <span class="keywordflow">return</span> INF;
<a name="l02265"></a>02265 }
<a name="l02266"></a>02266 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l02267"></a>02267                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* tau, <span class="keywordtype">int</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02268"></a>02268 {
<a name="l02269"></a>02269   <span class="keywordtype">int</span> INF;
<a name="l02270"></a>02270   dgeqrf_(&amp;m, &amp;n, A, &amp;ldA, tau, wk, &amp;nwk, &amp;INF);
<a name="l02271"></a>02271   <span class="keywordflow">return</span> INF;
<a name="l02272"></a>02272 }
<a name="l02273"></a>02273 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l02274"></a>02274                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* tau, <span class="keywordtype">int</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02275"></a>02275 {
<a name="l02276"></a>02276   <span class="keywordtype">int</span> INF;
<a name="l02277"></a>02277   sgeqrf_(&amp;m, &amp;n, A, &amp;ldA, tau, wk, &amp;nwk, &amp;INF);
<a name="l02278"></a>02278   <span class="keywordflow">return</span> INF;
<a name="l02279"></a>02279 }
<a name="l02280"></a>02280 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l02281"></a>02281                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp* tau, <span class="keywordtype">int</span> nwk, scomp* wk)
<a name="l02282"></a>02282 {
<a name="l02283"></a>02283   <span class="keywordtype">int</span> INF;
<a name="l02284"></a>02284   cgeqrf_(&amp;m, &amp;n, A, &amp;ldA, tau, wk, &amp;nwk, &amp;INF);
<a name="l02285"></a>02285   <span class="keywordflow">return</span> INF;
<a name="l02286"></a>02286 }
<a name="l02287"></a>02287 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l02288"></a>02288                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp* tau, <span class="keywordtype">int</span> nwk, dcomp* wk)
<a name="l02289"></a>02289 {
<a name="l02290"></a>02290   <span class="keywordtype">int</span> INF;
<a name="l02291"></a>02291   zgeqrf_(&amp;m, &amp;n, A, &amp;ldA, tau, wk, &amp;nwk, &amp;INF);
<a name="l02292"></a>02292   <span class="keywordflow">return</span> INF;
<a name="l02293"></a>02293 }
<a name="l02294"></a>02294 
<a name="l02295"></a>02295 <span class="comment">// QR factorisation (single vector)</span>
<a name="l02296"></a>02296 <span class="keyword">inline</span> <span class="keywordtype">void</span> geqrfs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* x, <span class="keyword">const</span> <span class="keywordtype">double</span>* tau)
<a name="l02297"></a>02297 { 
<a name="l02298"></a>02298   dlarfg_(&amp;n, x, x+1, &amp;N_ONE, tau);
<a name="l02299"></a>02299 }
<a name="l02300"></a>02300 
<a name="l02301"></a>02301 <span class="keyword">inline</span> <span class="keywordtype">void</span> geqrfs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* x, <span class="keyword">const</span> <span class="keywordtype">float</span>* tau)
<a name="l02302"></a>02302 { 
<a name="l02303"></a>02303   slarfg_(&amp;n, x, x+1, &amp;N_ONE, tau);
<a name="l02304"></a>02304 }
<a name="l02305"></a>02305 
<a name="l02306"></a>02306 <span class="keyword">inline</span> <span class="keywordtype">void</span> geqrfs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* x, <span class="keyword">const</span> scomp* tau)
<a name="l02307"></a>02307 { 
<a name="l02308"></a>02308   clarfg_(&amp;n, x, x+1, &amp;N_ONE, tau);
<a name="l02309"></a>02309 }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311 <span class="keyword">inline</span> <span class="keywordtype">void</span> geqrfs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* x, <span class="keyword">const</span> dcomp* tau)
<a name="l02312"></a>02312 { 
<a name="l02313"></a>02313   zlarfg_(&amp;n, x, x+1, &amp;N_ONE, tau);
<a name="l02314"></a>02314 }
<a name="l02315"></a>02315 
<a name="l02316"></a>02316 
<a name="l02317"></a>02317 <span class="comment">//truncated QR-factorisation(RRQR) - truncated version of dgeqp3(...)</span>
<a name="l02318"></a>02318 <span class="comment">//with absolute/relative accuracy atrunc and rtrunc</span>
<a name="l02319"></a>02319 <span class="comment">//column permutation stored in perm</span>
<a name="l02320"></a>02320 <span class="comment">//set perm[i] = 0 at the beginnnig for all i, if columns are not permutated</span>
<a name="l02321"></a>02321 <span class="keyword">inline</span> <span class="keywordtype">int</span> geqp3trunc(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l02322"></a>02322                       <span class="keywordtype">unsigned</span>* perm, <span class="keywordtype">double</span>* tau, <span class="keywordtype">unsigned</span>&amp; ntrunc,
<a name="l02323"></a>02323                       <span class="keywordtype">double</span> atrunc, <span class="keywordtype">double</span> rtrunc, <span class="keywordtype">unsigned</span> nwk, 
<a name="l02324"></a>02324                       <span class="keywordtype">double</span>* wk)
<a name="l02325"></a>02325 {
<a name="l02326"></a>02326   <span class="keywordtype">int</span> INF;
<a name="l02327"></a>02327   dgeqp3trunc_(&amp;m, &amp;n, A, &amp;m, perm, tau, &amp;ntrunc, &amp;atrunc, &amp;rtrunc,
<a name="l02328"></a>02328                wk, &amp;nwk, &amp;INF);
<a name="l02329"></a>02329   <span class="keywordflow">return</span> INF;
<a name="l02330"></a>02330 }
<a name="l02331"></a>02331 
<a name="l02332"></a>02332 
<a name="l02333"></a>02333 <span class="comment">// Multiply a general Matrix with the Q-Matrix (QR factorization), Q C</span>
<a name="l02334"></a>02334 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02335"></a>02335                  <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C,
<a name="l02336"></a>02336                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02337"></a>02337 {
<a name="l02338"></a>02338   <span class="keywordtype">int</span> INF;
<a name="l02339"></a>02339   dormqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02340"></a>02340   <span class="keywordflow">return</span> INF;
<a name="l02341"></a>02341 }
<a name="l02342"></a>02342 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02343"></a>02343                  <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02344"></a>02344                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02345"></a>02345 {
<a name="l02346"></a>02346   <span class="keywordtype">int</span> INF;
<a name="l02347"></a>02347   sormqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02348"></a>02348   <span class="keywordflow">return</span> INF;
<a name="l02349"></a>02349 }
<a name="l02350"></a>02350 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02351"></a>02351                  scomp* A, scomp* tau, scomp* C,
<a name="l02352"></a>02352                  <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02353"></a>02353 {
<a name="l02354"></a>02354   <span class="keywordtype">int</span> INF;
<a name="l02355"></a>02355   cunmqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02356"></a>02356   <span class="keywordflow">return</span> INF;
<a name="l02357"></a>02357 }
<a name="l02358"></a>02358 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02359"></a>02359                  dcomp* A, dcomp* tau, dcomp* C,
<a name="l02360"></a>02360                  <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02361"></a>02361 {
<a name="l02362"></a>02362   <span class="keywordtype">int</span> INF;
<a name="l02363"></a>02363   zunmqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02364"></a>02364   <span class="keywordflow">return</span> INF;
<a name="l02365"></a>02365 }
<a name="l02366"></a>02366 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02367"></a>02367                  <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C,
<a name="l02368"></a>02368                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02369"></a>02369 {
<a name="l02370"></a>02370   <span class="keywordtype">int</span> INF;
<a name="l02371"></a>02371   dormqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02372"></a>02372           &amp;INF);
<a name="l02373"></a>02373   <span class="keywordflow">return</span> INF;
<a name="l02374"></a>02374 }
<a name="l02375"></a>02375 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02376"></a>02376                  <span class="keywordtype">float</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02377"></a>02377                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02378"></a>02378 {
<a name="l02379"></a>02379   <span class="keywordtype">int</span> INF;
<a name="l02380"></a>02380   sormqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02381"></a>02381           &amp;INF);
<a name="l02382"></a>02382   <span class="keywordflow">return</span> INF;
<a name="l02383"></a>02383 }
<a name="l02384"></a>02384 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02385"></a>02385                  scomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp* tau, scomp* C,
<a name="l02386"></a>02386                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02387"></a>02387 {
<a name="l02388"></a>02388   <span class="keywordtype">int</span> INF;
<a name="l02389"></a>02389   cunmqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02390"></a>02390           &amp;INF);
<a name="l02391"></a>02391   <span class="keywordflow">return</span> INF;
<a name="l02392"></a>02392 }
<a name="l02393"></a>02393 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02394"></a>02394                  dcomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp* tau, dcomp* C,
<a name="l02395"></a>02395                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02396"></a>02396 {
<a name="l02397"></a>02397   <span class="keywordtype">int</span> INF;
<a name="l02398"></a>02398   zunmqr_(JOB_STR+6, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02399"></a>02399           &amp;INF);
<a name="l02400"></a>02400   <span class="keywordflow">return</span> INF;
<a name="l02401"></a>02401 }
<a name="l02402"></a>02402 
<a name="l02403"></a>02403 <span class="comment">// Multiply a general Matrix with the Q-Matrix (QR factorization), Q C</span>
<a name="l02404"></a>02404 <span class="comment">// just a single householder reflector</span>
<a name="l02405"></a>02405 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02406"></a>02406                   <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C, 
<a name="l02407"></a>02407                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02408"></a>02408 {
<a name="l02409"></a>02409   dlarfb_(JOB_STR+6, JOB_STR, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02410"></a>02410           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02411"></a>02411 }
<a name="l02412"></a>02412 
<a name="l02413"></a>02413 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02414"></a>02414                    <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02415"></a>02415                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02416"></a>02416 {
<a name="l02417"></a>02417   slarfb_(JOB_STR+6, JOB_STR, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02418"></a>02418           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02419"></a>02419 }
<a name="l02420"></a>02420 
<a name="l02421"></a>02421 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02422"></a>02422                   scomp* A, scomp* tau, scomp* C, 
<a name="l02423"></a>02423                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02424"></a>02424 {
<a name="l02425"></a>02425   clarfb_(JOB_STR+6, JOB_STR, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02426"></a>02426           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02427"></a>02427 }
<a name="l02428"></a>02428 
<a name="l02429"></a>02429 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02430"></a>02430                    dcomp* A, dcomp* tau, dcomp* C,
<a name="l02431"></a>02431                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02432"></a>02432 {
<a name="l02433"></a>02433   zlarfb_(JOB_STR+6, JOB_STR, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02434"></a>02434           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02435"></a>02435 }
<a name="l02436"></a>02436 
<a name="l02437"></a>02437 
<a name="l02438"></a>02438 <span class="comment">// Q^H C</span>
<a name="l02439"></a>02439 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02440"></a>02440                   <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C,
<a name="l02441"></a>02441                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02442"></a>02442 {
<a name="l02443"></a>02443   <span class="keywordtype">int</span> INF;
<a name="l02444"></a>02444   dormqr_(JOB_STR+6, JOB_STR+1, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02445"></a>02445           &amp;INF);
<a name="l02446"></a>02446   <span class="keywordflow">return</span> INF;
<a name="l02447"></a>02447 }
<a name="l02448"></a>02448 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02449"></a>02449                   <span class="keywordtype">float</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02450"></a>02450                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02451"></a>02451 {
<a name="l02452"></a>02452   <span class="keywordtype">int</span> INF;
<a name="l02453"></a>02453   sormqr_(JOB_STR+6, JOB_STR+1, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02454"></a>02454           &amp;INF);
<a name="l02455"></a>02455   <span class="keywordflow">return</span> INF;
<a name="l02456"></a>02456 }
<a name="l02457"></a>02457 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02458"></a>02458                   scomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp* tau, scomp* C,
<a name="l02459"></a>02459                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02460"></a>02460 {
<a name="l02461"></a>02461   <span class="keywordtype">int</span> INF;
<a name="l02462"></a>02462   cunmqr_(JOB_STR+6, JOB_STR+7, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02463"></a>02463           &amp;INF);
<a name="l02464"></a>02464   <span class="keywordflow">return</span> INF;
<a name="l02465"></a>02465 }
<a name="l02466"></a>02466 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02467"></a>02467                   dcomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp* tau, dcomp* C,
<a name="l02468"></a>02468                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02469"></a>02469 {
<a name="l02470"></a>02470   <span class="keywordtype">int</span> INF;
<a name="l02471"></a>02471   zunmqr_(JOB_STR+6, JOB_STR+7, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02472"></a>02472           &amp;INF);
<a name="l02473"></a>02473   <span class="keywordflow">return</span> INF;
<a name="l02474"></a>02474 }
<a name="l02475"></a>02475 
<a name="l02476"></a>02476 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02477"></a>02477                   <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C,
<a name="l02478"></a>02478                   <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02479"></a>02479 {
<a name="l02480"></a>02480   <span class="keywordtype">int</span> INF;
<a name="l02481"></a>02481   dormqr_(JOB_STR+6, JOB_STR+1, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;m, wk, &amp;nwk,
<a name="l02482"></a>02482           &amp;INF);
<a name="l02483"></a>02483   <span class="keywordflow">return</span> INF;
<a name="l02484"></a>02484 }
<a name="l02485"></a>02485 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02486"></a>02486                   <span class="keywordtype">float</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02487"></a>02487                   <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02488"></a>02488 {
<a name="l02489"></a>02489   <span class="keywordtype">int</span> INF;
<a name="l02490"></a>02490   sormqr_(JOB_STR+6, JOB_STR+1, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;m, wk, &amp;nwk,
<a name="l02491"></a>02491           &amp;INF);
<a name="l02492"></a>02492   <span class="keywordflow">return</span> INF;
<a name="l02493"></a>02493 }
<a name="l02494"></a>02494 
<a name="l02495"></a>02495 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02496"></a>02496                   <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C,
<a name="l02497"></a>02497                   <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02498"></a>02498 {
<a name="l02499"></a>02499   <span class="keywordtype">int</span> INF;
<a name="l02500"></a>02500   dormqr_(JOB_STR+6, JOB_STR+1, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02501"></a>02501   <span class="keywordflow">return</span> INF;
<a name="l02502"></a>02502 }
<a name="l02503"></a>02503 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02504"></a>02504                   <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02505"></a>02505                   <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02506"></a>02506 {
<a name="l02507"></a>02507   <span class="keywordtype">int</span> INF;
<a name="l02508"></a>02508   sormqr_(JOB_STR+6, JOB_STR+1, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02509"></a>02509   <span class="keywordflow">return</span> INF;
<a name="l02510"></a>02510 }
<a name="l02511"></a>02511 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02512"></a>02512                   scomp* A, scomp* tau, scomp* C,
<a name="l02513"></a>02513                   <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02514"></a>02514 {
<a name="l02515"></a>02515   <span class="keywordtype">int</span> INF;
<a name="l02516"></a>02516   cunmqr_(JOB_STR+6, JOB_STR+7, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02517"></a>02517   <span class="keywordflow">return</span> INF;
<a name="l02518"></a>02518 }
<a name="l02519"></a>02519 <span class="keyword">inline</span> <span class="keywordtype">int</span> ormqrh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02520"></a>02520                   dcomp* A, dcomp* tau, dcomp* C,
<a name="l02521"></a>02521                   <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02522"></a>02522 {
<a name="l02523"></a>02523   <span class="keywordtype">int</span> INF;
<a name="l02524"></a>02524   zunmqr_(JOB_STR+6, JOB_STR+7, &amp;m, &amp;n, &amp;p, A, &amp;m, tau, C, &amp;m, wk, &amp;nwk, &amp;INF);
<a name="l02525"></a>02525   <span class="keywordflow">return</span> INF;
<a name="l02526"></a>02526 }
<a name="l02527"></a>02527 
<a name="l02528"></a>02528 <span class="comment">// Multiply a general Matrix with the Q-Matrix (QR factorization), Q^H C</span>
<a name="l02529"></a>02529 <span class="comment">// just a single householder reflector</span>
<a name="l02530"></a>02530 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrsh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02531"></a>02531                     <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C, 
<a name="l02532"></a>02532                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02533"></a>02533 {
<a name="l02534"></a>02534   dlarfb_(JOB_STR+6, JOB_STR+1, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02535"></a>02535           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02536"></a>02536 }
<a name="l02537"></a>02537 
<a name="l02538"></a>02538 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrsh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02539"></a>02539                     <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02540"></a>02540                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02541"></a>02541 {
<a name="l02542"></a>02542   slarfb_(JOB_STR+6, JOB_STR+1, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02543"></a>02543           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02544"></a>02544 }
<a name="l02545"></a>02545 
<a name="l02546"></a>02546 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrsh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02547"></a>02547                     scomp* A, scomp* tau, scomp* C, 
<a name="l02548"></a>02548                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02549"></a>02549 {
<a name="l02550"></a>02550   clarfb_(JOB_STR+6, JOB_STR+1, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02551"></a>02551           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02552"></a>02552 }
<a name="l02553"></a>02553 
<a name="l02554"></a>02554 <span class="keyword">inline</span> <span class="keywordtype">void</span> ormqrsh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l02555"></a>02555                     dcomp* A, dcomp* tau, dcomp* C,
<a name="l02556"></a>02556                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02557"></a>02557 {
<a name="l02558"></a>02558   zlarfb_(JOB_STR+6, JOB_STR+1, JOB_STR+10, JOB_STR+7, &amp;m, &amp;n, 
<a name="l02559"></a>02559           &amp;N_ONE, A, &amp;m, tau, &amp;N_ONE, C, &amp;ldC, wk, &amp;nwk);
<a name="l02560"></a>02560 }
<a name="l02561"></a>02561 
<a name="l02562"></a>02562 <span class="keyword">inline</span> <span class="keywordtype">int</span> morqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02563"></a>02563                  <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* tau, <span class="keywordtype">double</span>* C,
<a name="l02564"></a>02564                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02565"></a>02565 {
<a name="l02566"></a>02566   <span class="keywordtype">int</span> INF;
<a name="l02567"></a>02567   dormqr_(JOB_STR+8, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02568"></a>02568           &amp;INF);
<a name="l02569"></a>02569   <span class="keywordflow">return</span> INF;
<a name="l02570"></a>02570 }
<a name="l02571"></a>02571 <span class="keyword">inline</span> <span class="keywordtype">int</span> morqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02572"></a>02572                  <span class="keywordtype">float</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* tau, <span class="keywordtype">float</span>* C,
<a name="l02573"></a>02573                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02574"></a>02574 {
<a name="l02575"></a>02575   <span class="keywordtype">int</span> INF;
<a name="l02576"></a>02576   sormqr_(JOB_STR+8, JOB_STR, &amp;m, &amp;n, &amp;p, A, &amp;ldA, tau, C, &amp;ldC, wk, &amp;nwk,
<a name="l02577"></a>02577           &amp;INF);
<a name="l02578"></a>02578   <span class="keywordflow">return</span> INF;
<a name="l02579"></a>02579 }
<a name="l02580"></a>02580 <span class="keyword">inline</span> <span class="keywordtype">int</span> morqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02581"></a>02581                  scomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp* tau, scomp* C,
<a name="l02582"></a>02582                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02583"></a>02583 {
<a name="l02584"></a>02584   exit(1);
<a name="l02585"></a>02585   <span class="keywordflow">return</span> 0;
<a name="l02586"></a>02586 }
<a name="l02587"></a>02587 <span class="keyword">inline</span> <span class="keywordtype">int</span> morqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p,
<a name="l02588"></a>02588                  dcomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp* tau, dcomp* C,
<a name="l02589"></a>02589                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldC, <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02590"></a>02590 {
<a name="l02591"></a>02591   exit(1);
<a name="l02592"></a>02592   <span class="keywordflow">return</span> 0;
<a name="l02593"></a>02593 }
<a name="l02594"></a>02594 
<a name="l02595"></a>02595 <span class="keyword">inline</span> <span class="keywordtype">void</span> ger(<span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N, <span class="keywordtype">double</span> d, <span class="keywordtype">double</span>* X, <span class="keywordtype">unsigned</span> INCX,
<a name="l02596"></a>02596                 <span class="keywordtype">double</span>* y, <span class="keywordtype">unsigned</span> INCY, <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> LDA)
<a name="l02597"></a>02597 {
<a name="l02598"></a>02598   dger_(&amp;M, &amp;N, &amp;d, X, &amp;INCX, y, &amp;INCY, A, &amp;LDA);
<a name="l02599"></a>02599 }
<a name="l02600"></a>02600 
<a name="l02601"></a>02601 <span class="keyword">inline</span> <span class="keywordtype">void</span> ger(<span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N, <span class="keywordtype">float</span> d, <span class="keywordtype">float</span>* X, <span class="keywordtype">unsigned</span> INCX,
<a name="l02602"></a>02602                 <span class="keywordtype">float</span>* y, <span class="keywordtype">unsigned</span> INCY, <span class="keywordtype">float</span>* A, <span class="keywordtype">unsigned</span> LDA)
<a name="l02603"></a>02603 {
<a name="l02604"></a>02604   sger_(&amp;M, &amp;N, &amp;d, X, &amp;INCX, y, &amp;INCY, A, &amp;LDA);
<a name="l02605"></a>02605 }
<a name="l02606"></a>02606 
<a name="l02607"></a>02607 <span class="keyword">inline</span> <span class="keywordtype">void</span> ger(<span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N, scomp d, scomp* X, <span class="keywordtype">unsigned</span> INCX,
<a name="l02608"></a>02608                 scomp* y, <span class="keywordtype">unsigned</span> INCY, scomp* A, <span class="keywordtype">unsigned</span> LDA)
<a name="l02609"></a>02609 {
<a name="l02610"></a>02610   cgerc_(&amp;M, &amp;N, &amp;d, X, &amp;INCX, y, &amp;INCY, A, &amp;LDA);
<a name="l02611"></a>02611 }
<a name="l02612"></a>02612 
<a name="l02613"></a>02613 <span class="keyword">inline</span> <span class="keywordtype">void</span> ger(<span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> N, dcomp d, dcomp* X, <span class="keywordtype">unsigned</span> INCX,
<a name="l02614"></a>02614                 dcomp* y, <span class="keywordtype">unsigned</span> INCY, dcomp* A, <span class="keywordtype">unsigned</span> LDA)
<a name="l02615"></a>02615 {
<a name="l02616"></a>02616   zgerc_(&amp;M, &amp;N, &amp;d, X, &amp;INCX, y, &amp;INCY, A, &amp;LDA);
<a name="l02617"></a>02617 }
<a name="l02618"></a>02618 
<a name="l02619"></a>02619 <span class="comment">// return Q-Matrix (QR factorization) in A</span>
<a name="l02620"></a>02620 <span class="keyword">inline</span> <span class="keywordtype">int</span> orgqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">double</span>* tau,
<a name="l02621"></a>02621                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l02622"></a>02622 {
<a name="l02623"></a>02623   <span class="keywordtype">int</span> INF;
<a name="l02624"></a>02624   dorgqr_(&amp;m, &amp;n, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02625"></a>02625   <span class="keywordflow">return</span> INF;
<a name="l02626"></a>02626 }
<a name="l02627"></a>02627 <span class="keyword">inline</span> <span class="keywordtype">int</span> orgqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">float</span>* tau,
<a name="l02628"></a>02628                  <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l02629"></a>02629 {
<a name="l02630"></a>02630   <span class="keywordtype">int</span> INF;
<a name="l02631"></a>02631   sorgqr_(&amp;m, &amp;n, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02632"></a>02632   <span class="keywordflow">return</span> INF;
<a name="l02633"></a>02633 }
<a name="l02634"></a>02634 <span class="keyword">inline</span> <span class="keywordtype">int</span> orgqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, scomp* tau,
<a name="l02635"></a>02635                  <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l02636"></a>02636 {
<a name="l02637"></a>02637   <span class="keywordtype">int</span> INF;
<a name="l02638"></a>02638   cungqr_(&amp;m, &amp;n, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02639"></a>02639   <span class="keywordflow">return</span> INF;
<a name="l02640"></a>02640 }
<a name="l02641"></a>02641 <span class="keyword">inline</span> <span class="keywordtype">int</span> orgqr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, dcomp* tau,
<a name="l02642"></a>02642                  <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l02643"></a>02643 {
<a name="l02644"></a>02644   <span class="keywordtype">int</span> INF;
<a name="l02645"></a>02645   zungqr_(&amp;m, &amp;n, &amp;n, A, &amp;m, tau, wk, &amp;nwk, &amp;INF);
<a name="l02646"></a>02646   <span class="keywordflow">return</span> INF;
<a name="l02647"></a>02647 }
<a name="l02648"></a>02648 
<a name="l02649"></a>02649 <span class="comment">// B=A^H, A in R^(m,n)</span>
<a name="l02650"></a>02650 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* A, 
<a name="l02651"></a>02651                       <span class="keywordtype">double</span>* B)
<a name="l02652"></a>02652 {
<a name="l02653"></a>02653   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) dcopy_(&amp;n, A+i, &amp;m, B+i*n, &amp;N_ONE);
<a name="l02654"></a>02654 }
<a name="l02655"></a>02655 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* A, 
<a name="l02656"></a>02656                       <span class="keywordtype">float</span>* B)
<a name="l02657"></a>02657 {
<a name="l02658"></a>02658   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) scopy_(&amp;n, A+i, &amp;m, B+i*n, &amp;N_ONE);
<a name="l02659"></a>02659 }
<a name="l02660"></a>02660 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* A, 
<a name="l02661"></a>02661                       scomp* B)
<a name="l02662"></a>02662 {
<a name="l02663"></a>02663   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++)
<a name="l02664"></a>02664     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) B[j+i*n] = conj(A[i+j*m]);
<a name="l02665"></a>02665 }
<a name="l02666"></a>02666 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* A, 
<a name="l02667"></a>02667                       dcomp* B)
<a name="l02668"></a>02668 {
<a name="l02669"></a>02669   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++)
<a name="l02670"></a>02670     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) B[j+i*n] = conj(A[i+j*m]);
<a name="l02671"></a>02671 }
<a name="l02672"></a>02672 
<a name="l02673"></a>02673 <span class="comment">//same as above with leading dimension</span>
<a name="l02674"></a>02674 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* A, 
<a name="l02675"></a>02675                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l02676"></a>02676 {
<a name="l02677"></a>02677   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) dcopy_(&amp;n, A+i, &amp;ldA, B+i*ldB, &amp;N_ONE);
<a name="l02678"></a>02678 }
<a name="l02679"></a>02679 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* A, 
<a name="l02680"></a>02680                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l02681"></a>02681 {
<a name="l02682"></a>02682   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) scopy_(&amp;n, A+i, &amp;ldA, B+i*ldB, &amp;N_ONE);
<a name="l02683"></a>02683 }
<a name="l02684"></a>02684 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* A, 
<a name="l02685"></a>02685                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l02686"></a>02686 {
<a name="l02687"></a>02687   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++)
<a name="l02688"></a>02688     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) B[j+i*ldB] = conj(A[i+j*ldA]);
<a name="l02689"></a>02689 }
<a name="l02690"></a>02690 <span class="keyword">inline</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* A, 
<a name="l02691"></a>02691                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l02692"></a>02692 {
<a name="l02693"></a>02693   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; i++)
<a name="l02694"></a>02694     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) B[j+i*ldB] = conj(A[i+j*ldA]);
<a name="l02695"></a>02695 }
<a name="l02696"></a>02696 
<a name="l02697"></a>02697 <span class="comment">// product of upper triangular and regular Matrix  M = R A, R mxp, A nxp</span>
<a name="l02698"></a>02698 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrgemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02699"></a>02699                      <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> R, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR,
<a name="l02700"></a>02700                      <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l02701"></a>02701                      <span class="keywordtype">double</span>* <span class="keyword">const</span> M, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldM)
<a name="l02702"></a>02702 {
<a name="l02703"></a>02703   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02704"></a>02704     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02705"></a>02705       <span class="keywordtype">double</span> d = D_ZERO;
<a name="l02706"></a>02706       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=i; l&lt;p; ++l)
<a name="l02707"></a>02707         d += R[i+l*ldR]*A[j+l*ldA];
<a name="l02708"></a>02708       M[i+j*ldM] = d;
<a name="l02709"></a>02709     }
<a name="l02710"></a>02710   }
<a name="l02711"></a>02711 }
<a name="l02712"></a>02712 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrgemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02713"></a>02713                      <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> R, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR,
<a name="l02714"></a>02714                      <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l02715"></a>02715                      <span class="keywordtype">float</span>* <span class="keyword">const</span> M, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldM)
<a name="l02716"></a>02716 {
<a name="l02717"></a>02717   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02718"></a>02718     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02719"></a>02719       <span class="keywordtype">float</span> d = S_ZERO;
<a name="l02720"></a>02720       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=i; l&lt;p; ++l)
<a name="l02721"></a>02721         d += R[i+l*ldR]*A[j+l*ldA];
<a name="l02722"></a>02722       M[i+j*ldM] = d;
<a name="l02723"></a>02723     }
<a name="l02724"></a>02724   }
<a name="l02725"></a>02725 }
<a name="l02726"></a>02726 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrgemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02727"></a>02727                      <span class="keyword">const</span> scomp* <span class="keyword">const</span> R, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR,
<a name="l02728"></a>02728                      <span class="keyword">const</span> scomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l02729"></a>02729                      scomp* <span class="keyword">const</span> M, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldM)
<a name="l02730"></a>02730 {
<a name="l02731"></a>02731   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02732"></a>02732     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02733"></a>02733       scomp d = C_ZERO;
<a name="l02734"></a>02734       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=i; l&lt;p; ++l)
<a name="l02735"></a>02735         d += R[i+l*ldR]*A[j+l*ldA];
<a name="l02736"></a>02736       M[i+j*ldM] = d;
<a name="l02737"></a>02737     }
<a name="l02738"></a>02738   }
<a name="l02739"></a>02739 }
<a name="l02740"></a>02740 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrgemmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02741"></a>02741                      <span class="keyword">const</span> dcomp* <span class="keyword">const</span> R, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR,
<a name="l02742"></a>02742                      <span class="keyword">const</span> dcomp* <span class="keyword">const</span> A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA,
<a name="l02743"></a>02743                      dcomp* <span class="keyword">const</span> M, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldM)
<a name="l02744"></a>02744 {
<a name="l02745"></a>02745   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02746"></a>02746     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02747"></a>02747       dcomp d = Z_ZERO;
<a name="l02748"></a>02748       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=i; l&lt;p; ++l)
<a name="l02749"></a>02749         d += R[i+l*ldR]*A[j+l*ldA];
<a name="l02750"></a>02750       M[i+j*ldM] = d;
<a name="l02751"></a>02751     }
<a name="l02752"></a>02752   }
<a name="l02753"></a>02753 }
<a name="l02754"></a>02754 
<a name="l02755"></a>02755 <span class="comment">// product of two upper triangular matrices M = R1 R2^H, R1 mxp, R2 nxp</span>
<a name="l02756"></a>02756 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02757"></a>02757                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02758"></a>02758                    <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02759"></a>02759                    <span class="keywordtype">double</span>* <span class="keyword">const</span> M)
<a name="l02760"></a>02760 {
<a name="l02761"></a>02761   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02762"></a>02762     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02763"></a>02763       <span class="keywordtype">double</span> d = D_ZERO;
<a name="l02764"></a>02764       <span class="keywordtype">unsigned</span> ij = MAX(i,j);
<a name="l02765"></a>02765       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=ij; l&lt;p; ++l)
<a name="l02766"></a>02766         d += R1[i+l*ldR1]*R2[j+l*ldR2];
<a name="l02767"></a>02767       M[i+j*m] = d;
<a name="l02768"></a>02768     }
<a name="l02769"></a>02769   }
<a name="l02770"></a>02770 }
<a name="l02771"></a>02771 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02772"></a>02772                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02773"></a>02773                    <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02774"></a>02774                    <span class="keywordtype">float</span>* <span class="keyword">const</span> M)
<a name="l02775"></a>02775 {
<a name="l02776"></a>02776   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02777"></a>02777     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02778"></a>02778       <span class="keywordtype">float</span> d = S_ZERO;
<a name="l02779"></a>02779       <span class="keywordtype">unsigned</span> ij = MAX(i,j);
<a name="l02780"></a>02780       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=ij; l&lt;p; ++l)
<a name="l02781"></a>02781         d += R1[i+l*ldR1]*R2[j+l*ldR2];
<a name="l02782"></a>02782       M[i+j*m] = d;
<a name="l02783"></a>02783     }
<a name="l02784"></a>02784   }
<a name="l02785"></a>02785 }
<a name="l02786"></a>02786 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02787"></a>02787                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02788"></a>02788                    <span class="keyword">const</span> scomp* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02789"></a>02789                    scomp* <span class="keyword">const</span> M)
<a name="l02790"></a>02790 {
<a name="l02791"></a>02791   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02792"></a>02792     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02793"></a>02793       scomp d = C_ZERO;
<a name="l02794"></a>02794       <span class="keywordtype">unsigned</span> ij = MAX(i,j);
<a name="l02795"></a>02795       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=ij; l&lt;p; ++l)
<a name="l02796"></a>02796         d += R1[i+l*ldR1]*conj(R2[j+l*ldR2]);
<a name="l02797"></a>02797       M[i+j*m] = d;
<a name="l02798"></a>02798     }
<a name="l02799"></a>02799   }
<a name="l02800"></a>02800 }
<a name="l02801"></a>02801 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02802"></a>02802                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02803"></a>02803                    <span class="keyword">const</span> dcomp* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02804"></a>02804                    dcomp* <span class="keyword">const</span> M)
<a name="l02805"></a>02805 {
<a name="l02806"></a>02806   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02807"></a>02807     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02808"></a>02808       dcomp d = Z_ZERO;
<a name="l02809"></a>02809       <span class="keywordtype">unsigned</span> ij = MAX(i,j);
<a name="l02810"></a>02810       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=ij; l&lt;p; ++l)
<a name="l02811"></a>02811         d += R1[i+l*ldR1]*conj(R2[j+l*ldR2]);
<a name="l02812"></a>02812       M[i+j*m] = d;
<a name="l02813"></a>02813     }
<a name="l02814"></a>02814   }
<a name="l02815"></a>02815 }
<a name="l02816"></a>02816 <span class="comment">// product of two upper triangular matrices M += R1 R2^T, R1 mxp, R2 nxp</span>
<a name="l02817"></a>02817 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02818"></a>02818                     <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02819"></a>02819                     <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02820"></a>02820                     <span class="keywordtype">double</span>* <span class="keyword">const</span> M)
<a name="l02821"></a>02821 {
<a name="l02822"></a>02822   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; l++) {
<a name="l02823"></a>02823     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=p; j&lt;n; j++) {
<a name="l02824"></a>02824       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=p; i&lt;m; i++) {
<a name="l02825"></a>02825         M[i+j*m] += R1[i+l*ldR1]*R2[j+l*ldR2];
<a name="l02826"></a>02826       }
<a name="l02827"></a>02827     }
<a name="l02828"></a>02828   }
<a name="l02829"></a>02829 }
<a name="l02830"></a>02830 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02831"></a>02831                     <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02832"></a>02832                     <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02833"></a>02833                     <span class="keywordtype">float</span>* <span class="keyword">const</span> M)
<a name="l02834"></a>02834 {
<a name="l02835"></a>02835   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; l++) {
<a name="l02836"></a>02836     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=p; j&lt;n; j++) {
<a name="l02837"></a>02837       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=p; i&lt;m; i++) {
<a name="l02838"></a>02838         M[i+j*m] += R1[i+l*ldR1]*R2[j+l*ldR2];
<a name="l02839"></a>02839       }
<a name="l02840"></a>02840     }
<a name="l02841"></a>02841   }
<a name="l02842"></a>02842 }
<a name="l02843"></a>02843 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02844"></a>02844                     <span class="keyword">const</span> scomp* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02845"></a>02845                     <span class="keyword">const</span> scomp* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02846"></a>02846                     scomp* <span class="keyword">const</span> M)
<a name="l02847"></a>02847 {
<a name="l02848"></a>02848   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; l++) {
<a name="l02849"></a>02849     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=p; j&lt;n; j++) {
<a name="l02850"></a>02850       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=p; i&lt;m; i++) {
<a name="l02851"></a>02851         M[i+j*m] += R1[i+l*ldR1]*conj(R2[j+l*ldR2]);
<a name="l02852"></a>02852       }
<a name="l02853"></a>02853     }
<a name="l02854"></a>02854   }
<a name="l02855"></a>02855 }
<a name="l02856"></a>02856 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmha(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> m, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n,
<a name="l02857"></a>02857                     <span class="keyword">const</span> dcomp* <span class="keyword">const</span> R1, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR1,
<a name="l02858"></a>02858                     <span class="keyword">const</span> dcomp* <span class="keyword">const</span> R2, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldR2,
<a name="l02859"></a>02859                     dcomp* <span class="keyword">const</span> M)
<a name="l02860"></a>02860 {
<a name="l02861"></a>02861   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;p; l++) {
<a name="l02862"></a>02862     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=p; j&lt;n; j++) {
<a name="l02863"></a>02863       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=p; i&lt;m; i++) {
<a name="l02864"></a>02864         M[i+j*m] += R1[i+l*ldR1]*conj(R2[j+l*ldR2]);
<a name="l02865"></a>02865       }
<a name="l02866"></a>02866     }
<a name="l02867"></a>02867   }
<a name="l02868"></a>02868 }
<a name="l02869"></a>02869 
<a name="l02870"></a>02870 <span class="comment">// product of an upper triangular matrix U and a matrix A, A:=U A</span>
<a name="l02871"></a>02871 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrgemm(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* U, <span class="keywordtype">unsigned</span> ldU,
<a name="l02872"></a>02872                     <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> ldA)
<a name="l02873"></a>02873 {
<a name="l02874"></a>02874   dtrmm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR, &amp;m, &amp;n, &amp;D_ONE, U, &amp;ldU,
<a name="l02875"></a>02875          A, &amp;ldA);
<a name="l02876"></a>02876 }
<a name="l02877"></a>02877 
<a name="l02878"></a>02878 <span class="comment">// A:=A U^H</span>
<a name="l02879"></a>02879 <span class="keyword">inline</span> <span class="keywordtype">void</span> geutrmm(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> ldA,
<a name="l02880"></a>02880                     <span class="keywordtype">double</span>* U, <span class="keywordtype">unsigned</span> ldU)
<a name="l02881"></a>02881 {
<a name="l02882"></a>02882   dtrmm_(JOB_STR+8, JOB_STR+5, JOB_STR+1, JOB_STR, &amp;m, &amp;n, &amp;D_ONE, U, &amp;ldU,
<a name="l02883"></a>02883          A, &amp;ldA);
<a name="l02884"></a>02884 }
<a name="l02885"></a>02885 
<a name="l02886"></a>02886 <span class="comment">// C += d A U^T, U upper triangular matrix in packed storage</span>
<a name="l02887"></a>02887 <span class="keyword">inline</span> <span class="keywordtype">void</span> geputrmmh(<span class="keywordtype">double</span> d, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l02888"></a>02888                       <span class="keywordtype">double</span>* U, <span class="keywordtype">double</span>* C)
<a name="l02889"></a>02889 {
<a name="l02890"></a>02890   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j)
<a name="l02891"></a>02891     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l02892"></a>02892       <span class="keywordtype">double</span> e = d*U[j+l*(l+1)/2];
<a name="l02893"></a>02893       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) C[i+j*m] += e*A[i+l*m];
<a name="l02894"></a>02894     }
<a name="l02895"></a>02895 }
<a name="l02896"></a>02896 
<a name="l02897"></a>02897 <span class="keyword">inline</span> <span class="keywordtype">void</span> geputrmmh(<span class="keywordtype">float</span> d, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l02898"></a>02898                       <span class="keywordtype">float</span>* U, <span class="keywordtype">float</span>* C)
<a name="l02899"></a>02899 {
<a name="l02900"></a>02900   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j)
<a name="l02901"></a>02901     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l02902"></a>02902       <span class="keywordtype">float</span> e = d*U[j+l*(l+1)/2];
<a name="l02903"></a>02903       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) C[i+j*m] += e*A[i+l*m];
<a name="l02904"></a>02904     }
<a name="l02905"></a>02905 }
<a name="l02906"></a>02906 
<a name="l02907"></a>02907 <span class="keyword">inline</span> <span class="keywordtype">void</span> geputrmmh(dcomp d, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l02908"></a>02908                       dcomp* U, dcomp* C)
<a name="l02909"></a>02909 {
<a name="l02910"></a>02910   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j)
<a name="l02911"></a>02911     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l02912"></a>02912       dcomp e = d*conj(U[j+l*(l+1)/2]);
<a name="l02913"></a>02913       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) C[i+j*m] += e*A[i+l*m];
<a name="l02914"></a>02914     }
<a name="l02915"></a>02915 }
<a name="l02916"></a>02916 
<a name="l02917"></a>02917 <span class="keyword">inline</span> <span class="keywordtype">void</span> geputrmmh(scomp d, <span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l02918"></a>02918                       scomp* U, scomp* C)
<a name="l02919"></a>02919 {
<a name="l02920"></a>02920   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j)
<a name="l02921"></a>02921     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l02922"></a>02922       scomp e = d*conj(U[j+l*(l+1)/2]);
<a name="l02923"></a>02923       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) C[i+j*m] += e*A[i+l*m];
<a name="l02924"></a>02924     }
<a name="l02925"></a>02925 }
<a name="l02926"></a>02926 
<a name="l02927"></a>02927 <span class="comment">// C += A U^T, U upper triangular matrix</span>
<a name="l02928"></a>02928 <span class="keyword">inline</span> <span class="keywordtype">void</span> geutrTmm(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* U, <span class="keywordtype">unsigned</span> ldU,
<a name="l02929"></a>02929                      <span class="keywordtype">double</span>* A, <span class="keywordtype">unsigned</span> ldA)
<a name="l02930"></a>02930 {
<a name="l02931"></a>02931   dtrmm_(JOB_STR+8, JOB_STR+5, JOB_STR+1, JOB_STR, &amp;m, &amp;n, &amp;D_ONE, U, &amp;ldU,
<a name="l02932"></a>02932          A, &amp;ldA);
<a name="l02933"></a>02933 }
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 <span class="comment">// product of two upper triangular matrices M = R1 R2^T, R1 mxp, R2 nxp</span>
<a name="l02936"></a>02936 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* R1,
<a name="l02937"></a>02937                    <span class="keywordtype">unsigned</span> ldR1, <span class="keywordtype">double</span>* R2, <span class="keywordtype">unsigned</span> ldR2, <span class="keywordtype">double</span>* M)
<a name="l02938"></a>02938 {
<a name="l02939"></a>02939   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02940"></a>02940     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02941"></a>02941       <span class="keywordtype">double</span> d = D_ZERO;
<a name="l02942"></a>02942       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=MAX(i,j); l&lt;p; ++l) d += R1[i+l*ldR1] * R2[j+l*ldR2];
<a name="l02943"></a>02943       M[i+j*m] = d;
<a name="l02944"></a>02944     }
<a name="l02945"></a>02945   }
<a name="l02946"></a>02946 }
<a name="l02947"></a>02947 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* R1,
<a name="l02948"></a>02948                    <span class="keywordtype">unsigned</span> ldR1, <span class="keywordtype">float</span>* R2, <span class="keywordtype">unsigned</span> ldR2, <span class="keywordtype">float</span>* M)
<a name="l02949"></a>02949 {
<a name="l02950"></a>02950   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02951"></a>02951     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02952"></a>02952       <span class="keywordtype">float</span> d = S_ZERO;
<a name="l02953"></a>02953       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=MAX(i,j); l&lt;p; ++l) d += R1[i+l*ldR1] * R2[j+l*ldR2];
<a name="l02954"></a>02954       M[i+j*m] = d;
<a name="l02955"></a>02955     }
<a name="l02956"></a>02956   }
<a name="l02957"></a>02957 }
<a name="l02958"></a>02958 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, scomp* R1,
<a name="l02959"></a>02959                    <span class="keywordtype">unsigned</span> ldR1, scomp* R2, <span class="keywordtype">unsigned</span> ldR2, scomp* M)
<a name="l02960"></a>02960 {
<a name="l02961"></a>02961   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02962"></a>02962     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02963"></a>02963       scomp d = C_ZERO;
<a name="l02964"></a>02964       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=MAX(i,j); l&lt;p; ++l)
<a name="l02965"></a>02965         d += R1[i+l*ldR1] * conj(R2[j+l*ldR2]);
<a name="l02966"></a>02966       M[i+j*m] = d;
<a name="l02967"></a>02967     }
<a name="l02968"></a>02968   }
<a name="l02969"></a>02969 }
<a name="l02970"></a>02970 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrmmh(<span class="keywordtype">unsigned</span> m, <span class="keywordtype">unsigned</span> p, <span class="keywordtype">unsigned</span> n, dcomp* R1,
<a name="l02971"></a>02971                    <span class="keywordtype">unsigned</span> ldR1, dcomp* R2, <span class="keywordtype">unsigned</span> ldR2, dcomp* M)
<a name="l02972"></a>02972 {
<a name="l02973"></a>02973   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l02974"></a>02974     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;m; ++i) {
<a name="l02975"></a>02975       dcomp d = Z_ZERO;
<a name="l02976"></a>02976       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=MAX(i,j); l&lt;p; ++l)
<a name="l02977"></a>02977         d += R1[i+l*ldR1] * conj(R2[j+l*ldR2]);
<a name="l02978"></a>02978       M[i+j*m] = d;
<a name="l02979"></a>02979     }
<a name="l02980"></a>02980   }
<a name="l02981"></a>02981 }
<a name="l02982"></a>02982 
<a name="l02983"></a>02983 <span class="comment">// C += d U A, where U is upper triangular in packed storage</span>
<a name="l02984"></a>02984 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l02985"></a>02985 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrgemm(T d, <span class="keywordtype">unsigned</span> n, T* U, <span class="keywordtype">unsigned</span> p, T* A, T* C)
<a name="l02986"></a>02986 {
<a name="l02987"></a>02987   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;p; ++j) {
<a name="l02988"></a>02988     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;n; ++l) {
<a name="l02989"></a>02989       T e = d * A[l+j*n];
<a name="l02990"></a>02990       <span class="keywordtype">unsigned</span> idl = l*(l+1)/2;
<a name="l02991"></a>02991       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=l; ++i) C[i+j*n] += e * U[i+idl];
<a name="l02992"></a>02992     }
<a name="l02993"></a>02993   }
<a name="l02994"></a>02994 }
<a name="l02995"></a>02995 
<a name="l02996"></a>02996 <span class="comment">// A += d U L, where U is upper triangular in packed storage</span>
<a name="l02997"></a>02997 <span class="comment">// and L is lower triangular in packed storage</span>
<a name="l02998"></a>02998 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrltrmm(<span class="keywordtype">double</span> d, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* U, <span class="keywordtype">double</span>* L, <span class="keywordtype">double</span>* A)
<a name="l02999"></a>02999 {
<a name="l03000"></a>03000   <span class="keywordtype">unsigned</span>* ip = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03001"></a>03001   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++) ip[i] = (<span class="keywordtype">unsigned</span>) L[((2*n-i+1)*i)/2];
<a name="l03002"></a>03002 
<a name="l03003"></a>03003   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l03004"></a>03004     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipj = ip[j];
<a name="l03005"></a>03005     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUj = (ipj*(ipj+1))/2;
<a name="l03006"></a>03006     <span class="keywordtype">unsigned</span> idL = ((2*n-j+1)*j)/2;
<a name="l03007"></a>03007     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipj; i++) A[i]+=d*U[idUj+i];
<a name="l03008"></a>03008     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j+1; k&lt;n; k++) {
<a name="l03009"></a>03009       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipk = ip[k];
<a name="l03010"></a>03010       <span class="keyword">const</span> <span class="keywordtype">double</span> t = d*L[++idL];
<a name="l03011"></a>03011       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUk = (ipk*(ipk+1))/2;
<a name="l03012"></a>03012       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipk; i++) A[i]+=U[idUk+i]*t;
<a name="l03013"></a>03013     }
<a name="l03014"></a>03014     A+=n;
<a name="l03015"></a>03015   }
<a name="l03016"></a>03016   <span class="keyword">delete</span> [] ip;
<a name="l03017"></a>03017 }
<a name="l03018"></a>03018 
<a name="l03019"></a>03019 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrltrmm(<span class="keywordtype">float</span> d, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* U, <span class="keywordtype">float</span>* L, <span class="keywordtype">float</span>* A)
<a name="l03020"></a>03020 {
<a name="l03021"></a>03021   <span class="keywordtype">unsigned</span>* ip = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03022"></a>03022   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++) ip[i] = (<span class="keywordtype">unsigned</span>) L[((2*n-i+1)*i)/2];
<a name="l03023"></a>03023 
<a name="l03024"></a>03024   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l03025"></a>03025     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipj = ip[j];
<a name="l03026"></a>03026     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUj = (ipj*(ipj+1))/2;
<a name="l03027"></a>03027     <span class="keywordtype">unsigned</span> idL = ((2*n-j+1)*j)/2;
<a name="l03028"></a>03028     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipj; i++)
<a name="l03029"></a>03029       A[i]+=d*U[idUj+i];
<a name="l03030"></a>03030     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j+1; k&lt;n; k++) {
<a name="l03031"></a>03031       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipk = ip[k];
<a name="l03032"></a>03032       <span class="keyword">const</span> <span class="keywordtype">float</span> t = d*L[++idL];
<a name="l03033"></a>03033       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUk = (ipk*(ipk+1))/2;
<a name="l03034"></a>03034       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipk; i++)
<a name="l03035"></a>03035         A[i]+=U[idUk+i]*t;
<a name="l03036"></a>03036     }
<a name="l03037"></a>03037     A+=n;
<a name="l03038"></a>03038   }
<a name="l03039"></a>03039   <span class="keyword">delete</span> [] ip;
<a name="l03040"></a>03040 }
<a name="l03041"></a>03041 
<a name="l03042"></a>03042 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrltrmm(dcomp d, <span class="keywordtype">unsigned</span> n, dcomp* U, dcomp* L, dcomp* A)
<a name="l03043"></a>03043 {
<a name="l03044"></a>03044   <span class="keywordtype">unsigned</span>* ip = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03045"></a>03045   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++) ip[i]= (<span class="keywordtype">unsigned</span>) abs(L[((2*n-i+1)*i)/2]);
<a name="l03046"></a>03046 
<a name="l03047"></a>03047   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l03048"></a>03048     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipj = ip[j];
<a name="l03049"></a>03049     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUj = (ipj*(ipj+1))/2;
<a name="l03050"></a>03050     <span class="keywordtype">unsigned</span> idL = ((2*n-j+1)*j)/2;
<a name="l03051"></a>03051     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipj; i++) A[i]+=d*U[idUj+i];
<a name="l03052"></a>03052     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j+1; k&lt;n; k++) {
<a name="l03053"></a>03053       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipk = ip[k];
<a name="l03054"></a>03054       <span class="keyword">const</span> dcomp t = d*L[++idL];
<a name="l03055"></a>03055       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUk = (ipk*(ipk+1))/2;
<a name="l03056"></a>03056       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipk; i++) A[i]+=U[idUk+i]*t;
<a name="l03057"></a>03057     }
<a name="l03058"></a>03058     A+=n;
<a name="l03059"></a>03059   }
<a name="l03060"></a>03060   <span class="keyword">delete</span> [] ip;
<a name="l03061"></a>03061 }
<a name="l03062"></a>03062 
<a name="l03063"></a>03063 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrltrmm(scomp d, <span class="keywordtype">unsigned</span> n, scomp* U, scomp* L, scomp* A)
<a name="l03064"></a>03064 {
<a name="l03065"></a>03065   <span class="keywordtype">unsigned</span>* ip = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03066"></a>03066   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; i++) ip[i]= (<span class="keywordtype">unsigned</span>) abs(L[((2*n-i+1)*i)/2]);
<a name="l03067"></a>03067 
<a name="l03068"></a>03068   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; j++) {
<a name="l03069"></a>03069     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipj = ip[j];
<a name="l03070"></a>03070     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUj = (ipj*(ipj+1))/2;
<a name="l03071"></a>03071     <span class="keywordtype">unsigned</span> idL = ((2*n-j+1)*j)/2;
<a name="l03072"></a>03072     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipj; i++) A[i]+=d*U[idUj+i];
<a name="l03073"></a>03073     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=j+1; k&lt;n; k++) {
<a name="l03074"></a>03074       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ipk = ip[k];
<a name="l03075"></a>03075       <span class="keyword">const</span> scomp t = d*L[++idL];
<a name="l03076"></a>03076       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idUk = (ipk*(ipk+1))/2;
<a name="l03077"></a>03077       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=ipk; i++) A[i]+=U[idUk+i]*t;
<a name="l03078"></a>03078     }
<a name="l03079"></a>03079     A+=n;
<a name="l03080"></a>03080   }
<a name="l03081"></a>03081   <span class="keyword">delete</span> [] ip;
<a name="l03082"></a>03082 }
<a name="l03083"></a>03083 
<a name="l03084"></a>03084 <span class="comment">// A += d U^H U, where U is upper triangular in packed storage</span>
<a name="l03085"></a>03085 <span class="comment">// only the upper triangular part of A is computed</span>
<a name="l03086"></a>03086 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmhm(<span class="keyword">const</span> <span class="keywordtype">double</span> d, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l03087"></a>03087                     <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> U, <span class="keywordtype">double</span>* A)
<a name="l03088"></a>03088 {
<a name="l03089"></a>03089   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) {
<a name="l03090"></a>03090     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idi = i*(i+1)/2;
<a name="l03091"></a>03091     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=i; j&lt;n; ++j) {
<a name="l03092"></a>03092       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idj = j*(j+1)/2;
<a name="l03093"></a>03093       <span class="keywordtype">double</span> t(0.0);
<a name="l03094"></a>03094       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> mij = MIN(i,j);
<a name="l03095"></a>03095       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;=mij; ++l) t += U[l+idi] * U[l+idj];
<a name="l03096"></a>03096       
<a name="l03097"></a>03097       A[i+idj] += d * t;
<a name="l03098"></a>03098     }
<a name="l03099"></a>03099   }
<a name="l03100"></a>03100 }
<a name="l03101"></a>03101 
<a name="l03102"></a>03102 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmhm(<span class="keyword">const</span> <span class="keywordtype">float</span> d, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l03103"></a>03103                     <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> U, <span class="keywordtype">float</span>* A)
<a name="l03104"></a>03104 {
<a name="l03105"></a>03105   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i){
<a name="l03106"></a>03106     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idi = i*(i+1)/2;
<a name="l03107"></a>03107     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=i; j&lt;n; ++j) {
<a name="l03108"></a>03108       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idj = j*(j+1)/2;
<a name="l03109"></a>03109       <span class="keywordtype">float</span> t(0.0);
<a name="l03110"></a>03110       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;=i; ++l) {
<a name="l03111"></a>03111         t += U[l+idi] * U[l+idj];
<a name="l03112"></a>03112       }
<a name="l03113"></a>03113       A[i+idj] += d * t;
<a name="l03114"></a>03114     }
<a name="l03115"></a>03115   }
<a name="l03116"></a>03116 }
<a name="l03117"></a>03117 
<a name="l03118"></a>03118 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmhm(<span class="keyword">const</span> dcomp d, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l03119"></a>03119                     <span class="keyword">const</span> dcomp* <span class="keyword">const</span> U, dcomp* A)
<a name="l03120"></a>03120 {
<a name="l03121"></a>03121   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i){
<a name="l03122"></a>03122     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idi = i*(i+1)/2;
<a name="l03123"></a>03123     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=i; j&lt;n; ++j) {
<a name="l03124"></a>03124       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idj = j*(j+1)/2;
<a name="l03125"></a>03125       dcomp t(0.0);
<a name="l03126"></a>03126       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;=i; ++l) {
<a name="l03127"></a>03127         t += conj(U[l+idi]) * U[l+idj];
<a name="l03128"></a>03128       }
<a name="l03129"></a>03129       A[i+idj] += d * t;
<a name="l03130"></a>03130     }
<a name="l03131"></a>03131   }
<a name="l03132"></a>03132 }
<a name="l03133"></a>03133 
<a name="l03134"></a>03134 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmhm(<span class="keyword">const</span> scomp d, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, 
<a name="l03135"></a>03135                     <span class="keyword">const</span> scomp* <span class="keyword">const</span> U, scomp* A)
<a name="l03136"></a>03136 {
<a name="l03137"></a>03137   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i){
<a name="l03138"></a>03138     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idi = i*(i+1)/2;
<a name="l03139"></a>03139     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=i; j&lt;n; ++j) {
<a name="l03140"></a>03140       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idj = j*(j+1)/2;
<a name="l03141"></a>03141       scomp t(0.0);
<a name="l03142"></a>03142       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0; l&lt;=i; ++l) {
<a name="l03143"></a>03143         t += conj(U[l+idi]) * U[l+idj];
<a name="l03144"></a>03144       }
<a name="l03145"></a>03145       A[i+idj] += d * t;
<a name="l03146"></a>03146     }
<a name="l03147"></a>03147   }
<a name="l03148"></a>03148 }
<a name="l03149"></a>03149 
<a name="l03150"></a>03150 <span class="comment">// A += d U U^H, where U is upper triangular in packed storage</span>
<a name="l03151"></a>03151 <span class="comment">// only the upper triangular part of A is computed</span>
<a name="l03152"></a>03152 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmmh(<span class="keywordtype">double</span> d, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* U, <span class="keywordtype">double</span>* A)
<a name="l03153"></a>03153 {
<a name="l03154"></a>03154   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03155"></a>03155     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l03156"></a>03156       <span class="keywordtype">unsigned</span> idl = l*(l+1)/2;
<a name="l03157"></a>03157       <span class="keywordtype">double</span> e = d * U[j+idl];
<a name="l03158"></a>03158       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) A[i+j*(j+1)/2] += e * U[i+idl];
<a name="l03159"></a>03159     }
<a name="l03160"></a>03160   }
<a name="l03161"></a>03161 }
<a name="l03162"></a>03162 
<a name="l03163"></a>03163 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmmh(<span class="keywordtype">float</span> d, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* U, <span class="keywordtype">float</span>* A)
<a name="l03164"></a>03164 {
<a name="l03165"></a>03165   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03166"></a>03166     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l03167"></a>03167       <span class="keywordtype">unsigned</span> idl = l*(l+1)/2;
<a name="l03168"></a>03168       <span class="keywordtype">float</span> e = d * U[j+idl];
<a name="l03169"></a>03169       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) A[i+j*(j+1)/2] += e * U[i+idl];
<a name="l03170"></a>03170     }
<a name="l03171"></a>03171   }
<a name="l03172"></a>03172 }
<a name="l03173"></a>03173 
<a name="l03174"></a>03174 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmmh(dcomp d, <span class="keywordtype">unsigned</span> n, dcomp* U, dcomp* A)
<a name="l03175"></a>03175 {
<a name="l03176"></a>03176   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03177"></a>03177     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l03178"></a>03178       <span class="keywordtype">unsigned</span> idl = l*(l+1)/2;
<a name="l03179"></a>03179       dcomp e = d * conj(U[j+idl]);
<a name="l03180"></a>03180       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) A[i+j*(j+1)/2] += e * U[i+idl];
<a name="l03181"></a>03181     }
<a name="l03182"></a>03182   }
<a name="l03183"></a>03183 }
<a name="l03184"></a>03184 
<a name="l03185"></a>03185 <span class="keyword">inline</span> <span class="keywordtype">void</span> putrmmh(scomp d, <span class="keywordtype">unsigned</span> n, scomp* U, scomp* A)
<a name="l03186"></a>03186 {
<a name="l03187"></a>03187   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03188"></a>03188     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=j; l&lt;n; ++l) {
<a name="l03189"></a>03189       <span class="keywordtype">unsigned</span> idl = l*(l+1)/2;
<a name="l03190"></a>03190       scomp e = d * conj(U[j+idl]);
<a name="l03191"></a>03191       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;=j; ++i) A[i+j*(j+1)/2] += e * U[i+idl];
<a name="l03192"></a>03192     }
<a name="l03193"></a>03193   }
<a name="l03194"></a>03194 }
<a name="l03195"></a>03195 
<a name="l03196"></a>03196 <span class="keyword">inline</span> <span class="keywordtype">void</span> fill0_ltr(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A)
<a name="l03197"></a>03197 {
<a name="l03198"></a>03198   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03199"></a>03199     *A++ = (double) j;
<a name="l03200"></a>03200     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=j+1; i&lt;n; ++i) *A++ = D_ZERO;
<a name="l03201"></a>03201   }
<a name="l03202"></a>03202 }
<a name="l03203"></a>03203 <span class="keyword">inline</span> <span class="keywordtype">void</span> fill0_ltr(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A)
<a name="l03204"></a>03204 {
<a name="l03205"></a>03205   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03206"></a>03206     *A++ = (float) j;
<a name="l03207"></a>03207     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=j+1; i&lt;n; ++i) *A++ = S_ZERO;
<a name="l03208"></a>03208   }
<a name="l03209"></a>03209 }
<a name="l03210"></a>03210 <span class="keyword">inline</span> <span class="keywordtype">void</span> fill0_ltr(<span class="keywordtype">unsigned</span> n, scomp* A)
<a name="l03211"></a>03211 {
<a name="l03212"></a>03212   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03213"></a>03213     *A++ = scomp( (<span class="keywordtype">float</span>)j, S_ZERO);
<a name="l03214"></a>03214     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=j+1; i&lt;n; ++i) *A++ = C_ZERO;
<a name="l03215"></a>03215   }
<a name="l03216"></a>03216 }
<a name="l03217"></a>03217 <span class="keyword">inline</span> <span class="keywordtype">void</span> fill0_ltr(<span class="keywordtype">unsigned</span> n, dcomp* A)
<a name="l03218"></a>03218 {
<a name="l03219"></a>03219   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03220"></a>03220     *A++ = dcomp( (<span class="keywordtype">double</span>) j, D_ZERO);
<a name="l03221"></a>03221     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=j+1; i&lt;n; ++i) *A++ = Z_ZERO;
<a name="l03222"></a>03222   }
<a name="l03223"></a>03223 }
<a name="l03224"></a>03224 
<a name="l03225"></a>03225 <span class="comment">// fill nxn matrix A with identity</span>
<a name="l03226"></a>03226 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> *A)
<a name="l03227"></a>03227 {
<a name="l03228"></a>03228   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03229"></a>03229     <span class="keywordtype">unsigned</span> i = 0;
<a name="l03230"></a>03230     <span class="keywordflow">for</span> (; i&lt;j; ++i) *A++ = D_ZERO;
<a name="l03231"></a>03231     *A++ = D_ONE;
<a name="l03232"></a>03232     ++i;
<a name="l03233"></a>03233     <span class="keywordflow">for</span> (; i&lt;n; ++i) *A++ = D_ZERO;
<a name="l03234"></a>03234   }
<a name="l03235"></a>03235 }
<a name="l03236"></a>03236 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> *A)
<a name="l03237"></a>03237 {
<a name="l03238"></a>03238   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03239"></a>03239     <span class="keywordtype">unsigned</span> i = 0;
<a name="l03240"></a>03240     <span class="keywordflow">for</span> (; i&lt;j; ++i) *A++ = S_ZERO;
<a name="l03241"></a>03241     *A++ = S_ONE;
<a name="l03242"></a>03242     ++i;
<a name="l03243"></a>03243     <span class="keywordflow">for</span> (; i&lt;n; ++i) *A++ = S_ZERO;
<a name="l03244"></a>03244   }
<a name="l03245"></a>03245 }
<a name="l03246"></a>03246 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId(<span class="keywordtype">unsigned</span> n, scomp *A)
<a name="l03247"></a>03247 {
<a name="l03248"></a>03248   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03249"></a>03249     <span class="keywordtype">unsigned</span> i = 0;
<a name="l03250"></a>03250     <span class="keywordflow">for</span> (; i&lt;j; ++i) *A++ = C_ZERO;
<a name="l03251"></a>03251     *A++ = C_ONE;
<a name="l03252"></a>03252     ++i;
<a name="l03253"></a>03253     <span class="keywordflow">for</span> (; i&lt;n; ++i) *A++ = C_ZERO;
<a name="l03254"></a>03254   }
<a name="l03255"></a>03255 }
<a name="l03256"></a>03256 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId(<span class="keywordtype">unsigned</span> n, dcomp *A)
<a name="l03257"></a>03257 {
<a name="l03258"></a>03258   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03259"></a>03259     <span class="keywordtype">unsigned</span> i = 0;
<a name="l03260"></a>03260     <span class="keywordflow">for</span> (; i&lt;j; ++i) *A++ = Z_ZERO;
<a name="l03261"></a>03261     *A++ = Z_ONE;
<a name="l03262"></a>03262     ++i;
<a name="l03263"></a>03263     <span class="keywordflow">for</span> (; i&lt;n; ++i) *A++ = Z_ZERO;
<a name="l03264"></a>03264   }
<a name="l03265"></a>03265 }
<a name="l03266"></a>03266 
<a name="l03267"></a>03267 <span class="comment">// fill nxn upper triang. matrix A with identity (packed storage)</span>
<a name="l03268"></a>03268 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_utr(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> *A)
<a name="l03269"></a>03269 {
<a name="l03270"></a>03270   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03271"></a>03271     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;j; ++i) *A++ = D_ZERO;
<a name="l03272"></a>03272     *A++ = D_ONE;
<a name="l03273"></a>03273   }
<a name="l03274"></a>03274 }
<a name="l03275"></a>03275 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_utr(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> *A)
<a name="l03276"></a>03276 {
<a name="l03277"></a>03277   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03278"></a>03278     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;j; ++i) *A++ = S_ZERO;
<a name="l03279"></a>03279     *A++ = S_ONE;
<a name="l03280"></a>03280   }
<a name="l03281"></a>03281 }
<a name="l03282"></a>03282 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_utr(<span class="keywordtype">unsigned</span> n, scomp *A)
<a name="l03283"></a>03283 {
<a name="l03284"></a>03284   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03285"></a>03285     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;j; ++i) *A++ = C_ZERO;
<a name="l03286"></a>03286     *A++ = C_ONE;
<a name="l03287"></a>03287   }
<a name="l03288"></a>03288 }
<a name="l03289"></a>03289 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_utr(<span class="keywordtype">unsigned</span> n, dcomp *A)
<a name="l03290"></a>03290 {
<a name="l03291"></a>03291   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;n; ++j) {
<a name="l03292"></a>03292     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;j; ++i) *A++ = Z_ZERO;
<a name="l03293"></a>03293     *A++ = Z_ONE;
<a name="l03294"></a>03294   }
<a name="l03295"></a>03295 }
<a name="l03296"></a>03296 
<a name="l03297"></a>03297 <span class="comment">// fill nxn normalized lower triang. matrix A with identity (packed storage)</span>
<a name="l03298"></a>03298 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_ltr(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span> *A)
<a name="l03299"></a>03299 {
<a name="l03300"></a>03300   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) {
<a name="l03301"></a>03301     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;i; ++j) *A++ = D_ZERO;
<a name="l03302"></a>03302     <span class="comment">// for pivoting, a ltr is assumed to have ones on the diagonal</span>
<a name="l03303"></a>03303     *A++ = (double) i;
<a name="l03304"></a>03304   }
<a name="l03305"></a>03305 }
<a name="l03306"></a>03306 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_ltr(<span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span> *A)
<a name="l03307"></a>03307 {
<a name="l03308"></a>03308   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) {
<a name="l03309"></a>03309     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;i; ++j) *A++ = S_ZERO;
<a name="l03310"></a>03310     <span class="comment">// for pivoting, a ltr is assumed to have ones on the diagonal</span>
<a name="l03311"></a>03311     *A++ = (float) i;
<a name="l03312"></a>03312   }
<a name="l03313"></a>03313 }
<a name="l03314"></a>03314 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_ltr(<span class="keywordtype">unsigned</span> n, scomp *A)
<a name="l03315"></a>03315 {
<a name="l03316"></a>03316   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) {
<a name="l03317"></a>03317     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;i; ++j) *A++ = C_ZERO;
<a name="l03318"></a>03318     <span class="comment">// for pivoting, a ltr is assumed to have ones on the diagonal</span>
<a name="l03319"></a>03319     *A++ = scomp( (<span class="keywordtype">float</span>) i, S_ZERO);
<a name="l03320"></a>03320   }
<a name="l03321"></a>03321 }
<a name="l03322"></a>03322 <span class="keyword">inline</span> <span class="keywordtype">void</span> fillId_ltr(<span class="keywordtype">unsigned</span> n, dcomp *A)
<a name="l03323"></a>03323 {
<a name="l03324"></a>03324   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;n; ++i) {
<a name="l03325"></a>03325     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;i; ++j) *A++ = Z_ZERO;
<a name="l03326"></a>03326     <span class="comment">// for pivoting, a ltr is assumed to have ones on the diagonal</span>
<a name="l03327"></a>03327     *A++ = dcomp( (<span class="keywordtype">double</span>)i, D_ZERO);
<a name="l03328"></a>03328   }
<a name="l03329"></a>03329 }
<a name="l03330"></a>03330 
<a name="l03331"></a>03331 
<a name="l03332"></a>03332 }
<a name="l03333"></a>03333 
<a name="l03334"></a>03334 
<a name="l03335"></a>03335 <span class="keyword">namespace </span>lapack
<a name="l03336"></a>03336 {
<a name="l03337"></a>03337 
<a name="l03338"></a>03338 <span class="comment">// general inversion</span>
<a name="l03339"></a>03339 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* <span class="keyword">const</span> A)
<a name="l03340"></a>03340 {
<a name="l03341"></a>03341   <span class="keywordtype">unsigned</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03342"></a>03342   assert(ipiv!=NULL);
<a name="l03343"></a>03343 
<a name="l03344"></a>03344   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03345"></a>03345   <span class="keywordtype">double</span>* <span class="keyword">const</span> work = <span class="keyword">new</span> <span class="keywordtype">double</span>[lwork];
<a name="l03346"></a>03346   assert(work!=NULL);
<a name="l03347"></a>03347 
<a name="l03348"></a>03348   <span class="keywordtype">int</span> INFO = blas::getrf(n, A, ipiv);
<a name="l03349"></a>03349   assert(INFO==0);
<a name="l03350"></a>03350 
<a name="l03351"></a>03351   dgetri_(&amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;INFO);
<a name="l03352"></a>03352   assert(INFO==0);
<a name="l03353"></a>03353 
<a name="l03354"></a>03354   <span class="keyword">delete</span> [] work;
<a name="l03355"></a>03355   <span class="keyword">delete</span> [] ipiv;
<a name="l03356"></a>03356 }
<a name="l03357"></a>03357 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* <span class="keyword">const</span> A)
<a name="l03358"></a>03358 {
<a name="l03359"></a>03359   <span class="keywordtype">unsigned</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03360"></a>03360   assert(ipiv!=NULL);
<a name="l03361"></a>03361 
<a name="l03362"></a>03362   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03363"></a>03363   <span class="keywordtype">float</span>* <span class="keyword">const</span> work = <span class="keyword">new</span> <span class="keywordtype">float</span>[lwork];
<a name="l03364"></a>03364   assert(work!=NULL);
<a name="l03365"></a>03365 
<a name="l03366"></a>03366   <span class="keywordtype">int</span> INFO = blas::getrf(n, A, ipiv);
<a name="l03367"></a>03367   assert(INFO==0);
<a name="l03368"></a>03368 
<a name="l03369"></a>03369   sgetri_(&amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;INFO);
<a name="l03370"></a>03370   assert(INFO==0);
<a name="l03371"></a>03371 
<a name="l03372"></a>03372   <span class="keyword">delete</span> [] work;
<a name="l03373"></a>03373   <span class="keyword">delete</span> [] ipiv;
<a name="l03374"></a>03374 }
<a name="l03375"></a>03375 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* <span class="keyword">const</span> A)
<a name="l03376"></a>03376 {
<a name="l03377"></a>03377   <span class="keywordtype">unsigned</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03378"></a>03378   assert(ipiv!=NULL);
<a name="l03379"></a>03379 
<a name="l03380"></a>03380   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03381"></a>03381   scomp* <span class="keyword">const</span> work = <span class="keyword">new</span> scomp[lwork];
<a name="l03382"></a>03382   assert(work!=NULL);
<a name="l03383"></a>03383 
<a name="l03384"></a>03384   <span class="keywordtype">int</span> INFO = blas::getrf(n, A, ipiv);
<a name="l03385"></a>03385   assert(INFO==0);
<a name="l03386"></a>03386 
<a name="l03387"></a>03387   cgetri_(&amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;INFO);
<a name="l03388"></a>03388   assert(INFO==0);
<a name="l03389"></a>03389 
<a name="l03390"></a>03390   <span class="keyword">delete</span> [] work;
<a name="l03391"></a>03391   <span class="keyword">delete</span> [] ipiv;
<a name="l03392"></a>03392 }
<a name="l03393"></a>03393 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* <span class="keyword">const</span> A)
<a name="l03394"></a>03394 {
<a name="l03395"></a>03395   <span class="keywordtype">unsigned</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n];
<a name="l03396"></a>03396   assert(ipiv!=NULL);
<a name="l03397"></a>03397 
<a name="l03398"></a>03398   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03399"></a>03399   dcomp* <span class="keyword">const</span> work = <span class="keyword">new</span> dcomp[lwork];
<a name="l03400"></a>03400   assert(work!=NULL);
<a name="l03401"></a>03401 
<a name="l03402"></a>03402   <span class="keywordtype">int</span> INFO = blas::getrf(n, A, ipiv);
<a name="l03403"></a>03403   assert(INFO==0);
<a name="l03404"></a>03404 
<a name="l03405"></a>03405   zgetri_(&amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;INFO);
<a name="l03406"></a>03406   assert(INFO==0);
<a name="l03407"></a>03407 
<a name="l03408"></a>03408   <span class="keyword">delete</span> [] work;
<a name="l03409"></a>03409   <span class="keyword">delete</span> [] ipiv;
<a name="l03410"></a>03410 }
<a name="l03411"></a>03411 
<a name="l03412"></a>03412 
<a name="l03413"></a>03413 
<a name="l03414"></a>03414 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_sym(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* <span class="keyword">const</span> A)
<a name="l03415"></a>03415 {
<a name="l03416"></a>03416   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03417"></a>03417   assert(ipiv!=NULL);
<a name="l03418"></a>03418 
<a name="l03419"></a>03419   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03420"></a>03420   <span class="keywordtype">double</span>* <span class="keyword">const</span> work = <span class="keyword">new</span> <span class="keywordtype">double</span>[lwork];
<a name="l03421"></a>03421   assert(work!=NULL);
<a name="l03422"></a>03422 
<a name="l03423"></a>03423   <span class="keywordtype">int</span> INFO;
<a name="l03424"></a>03424   dsptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03425"></a>03425   assert(INFO==0);
<a name="l03426"></a>03426 
<a name="l03427"></a>03427   dsptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03428"></a>03428   assert(INFO==0);
<a name="l03429"></a>03429 
<a name="l03430"></a>03430   <span class="keyword">delete</span> [] work;
<a name="l03431"></a>03431   <span class="keyword">delete</span> [] ipiv;
<a name="l03432"></a>03432 }
<a name="l03433"></a>03433 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_sym(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* <span class="keyword">const</span> A)
<a name="l03434"></a>03434 {
<a name="l03435"></a>03435   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03436"></a>03436   assert(ipiv!=NULL);
<a name="l03437"></a>03437 
<a name="l03438"></a>03438   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03439"></a>03439   <span class="keywordtype">float</span>* <span class="keyword">const</span> work = <span class="keyword">new</span> <span class="keywordtype">float</span>[lwork];
<a name="l03440"></a>03440   assert(work!=NULL);
<a name="l03441"></a>03441 
<a name="l03442"></a>03442   <span class="keywordtype">int</span> INFO;
<a name="l03443"></a>03443   ssptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03444"></a>03444   assert(INFO==0);
<a name="l03445"></a>03445 
<a name="l03446"></a>03446   ssptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03447"></a>03447   assert(INFO==0);
<a name="l03448"></a>03448 
<a name="l03449"></a>03449   <span class="keyword">delete</span> [] work;
<a name="l03450"></a>03450   <span class="keyword">delete</span> [] ipiv;
<a name="l03451"></a>03451 }
<a name="l03452"></a>03452 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_sym(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* <span class="keyword">const</span> A)
<a name="l03453"></a>03453 {
<a name="l03454"></a>03454   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03455"></a>03455   assert(ipiv!=NULL);
<a name="l03456"></a>03456 
<a name="l03457"></a>03457   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03458"></a>03458   scomp* <span class="keyword">const</span> work = <span class="keyword">new</span> scomp[lwork];
<a name="l03459"></a>03459   assert(work!=NULL);
<a name="l03460"></a>03460 
<a name="l03461"></a>03461   <span class="keywordtype">int</span> INFO;
<a name="l03462"></a>03462   csptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03463"></a>03463   assert(INFO==0);
<a name="l03464"></a>03464 
<a name="l03465"></a>03465   csptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03466"></a>03466   assert(INFO==0);
<a name="l03467"></a>03467 
<a name="l03468"></a>03468   <span class="keyword">delete</span> [] work;
<a name="l03469"></a>03469   <span class="keyword">delete</span> [] ipiv;
<a name="l03470"></a>03470 }
<a name="l03471"></a>03471 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_sym(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* <span class="keyword">const</span> A)
<a name="l03472"></a>03472 {
<a name="l03473"></a>03473   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03474"></a>03474   assert(ipiv!=NULL);
<a name="l03475"></a>03475 
<a name="l03476"></a>03476   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03477"></a>03477   dcomp* <span class="keyword">const</span> work = <span class="keyword">new</span> dcomp[lwork];
<a name="l03478"></a>03478   assert(work!=NULL);
<a name="l03479"></a>03479 
<a name="l03480"></a>03480   <span class="keywordtype">int</span> INFO;
<a name="l03481"></a>03481   zsptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03482"></a>03482   assert(INFO==0);
<a name="l03483"></a>03483 
<a name="l03484"></a>03484   zsptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03485"></a>03485   assert(INFO==0);
<a name="l03486"></a>03486 
<a name="l03487"></a>03487   <span class="keyword">delete</span> [] work;
<a name="l03488"></a>03488   <span class="keyword">delete</span> [] ipiv;
<a name="l03489"></a>03489 }
<a name="l03490"></a>03490 
<a name="l03491"></a>03491 
<a name="l03492"></a>03492 
<a name="l03493"></a>03493 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_herm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* <span class="keyword">const</span> A)
<a name="l03494"></a>03494 {
<a name="l03495"></a>03495   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03496"></a>03496   assert(ipiv!=NULL);
<a name="l03497"></a>03497 
<a name="l03498"></a>03498   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03499"></a>03499   <span class="keywordtype">double</span>* <span class="keyword">const</span> work = <span class="keyword">new</span> <span class="keywordtype">double</span>[lwork];
<a name="l03500"></a>03500   assert(work!=NULL);
<a name="l03501"></a>03501 
<a name="l03502"></a>03502   <span class="keywordtype">int</span> INFO;
<a name="l03503"></a>03503   dsptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03504"></a>03504   assert(INFO==0);
<a name="l03505"></a>03505 
<a name="l03506"></a>03506   dsptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03507"></a>03507   assert(INFO==0);
<a name="l03508"></a>03508 
<a name="l03509"></a>03509   <span class="keyword">delete</span> [] work;
<a name="l03510"></a>03510   <span class="keyword">delete</span> [] ipiv;
<a name="l03511"></a>03511 }
<a name="l03512"></a>03512 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_herm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* <span class="keyword">const</span> A)
<a name="l03513"></a>03513 {
<a name="l03514"></a>03514   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03515"></a>03515   assert(ipiv!=NULL);
<a name="l03516"></a>03516 
<a name="l03517"></a>03517   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03518"></a>03518   <span class="keywordtype">float</span>* <span class="keyword">const</span> work = <span class="keyword">new</span> <span class="keywordtype">float</span>[lwork];
<a name="l03519"></a>03519   assert(work!=NULL);
<a name="l03520"></a>03520 
<a name="l03521"></a>03521   <span class="keywordtype">int</span> INFO;
<a name="l03522"></a>03522   ssptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03523"></a>03523   assert(INFO==0);
<a name="l03524"></a>03524 
<a name="l03525"></a>03525   ssptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03526"></a>03526   assert(INFO==0);
<a name="l03527"></a>03527 
<a name="l03528"></a>03528   <span class="keyword">delete</span> [] work;
<a name="l03529"></a>03529   <span class="keyword">delete</span> [] ipiv;
<a name="l03530"></a>03530 }
<a name="l03531"></a>03531 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_herm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* <span class="keyword">const</span> A)
<a name="l03532"></a>03532 {
<a name="l03533"></a>03533   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03534"></a>03534   assert(ipiv!=NULL);
<a name="l03535"></a>03535 
<a name="l03536"></a>03536   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03537"></a>03537   scomp* <span class="keyword">const</span> work = <span class="keyword">new</span> scomp[lwork];
<a name="l03538"></a>03538   assert(work!=NULL);
<a name="l03539"></a>03539 
<a name="l03540"></a>03540   <span class="keywordtype">int</span> INFO;
<a name="l03541"></a>03541   chptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03542"></a>03542   assert(INFO==0);
<a name="l03543"></a>03543 
<a name="l03544"></a>03544   chptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03545"></a>03545   assert(INFO==0);
<a name="l03546"></a>03546 
<a name="l03547"></a>03547   <span class="keyword">delete</span> [] work;
<a name="l03548"></a>03548   <span class="keyword">delete</span> [] ipiv;
<a name="l03549"></a>03549 }
<a name="l03550"></a>03550 <span class="keyword">inline</span> <span class="keywordtype">void</span> geinv_herm(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* <span class="keyword">const</span> A)
<a name="l03551"></a>03551 {
<a name="l03552"></a>03552   <span class="keywordtype">int</span>* <span class="keyword">const</span> ipiv = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l03553"></a>03553   assert(ipiv!=NULL);
<a name="l03554"></a>03554 
<a name="l03555"></a>03555   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> lwork = 4*n;
<a name="l03556"></a>03556   dcomp* <span class="keyword">const</span> work = <span class="keyword">new</span> dcomp[lwork];
<a name="l03557"></a>03557   assert(work!=NULL);
<a name="l03558"></a>03558 
<a name="l03559"></a>03559   <span class="keywordtype">int</span> INFO;
<a name="l03560"></a>03560   zhptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;INFO);
<a name="l03561"></a>03561   assert(INFO==0);
<a name="l03562"></a>03562 
<a name="l03563"></a>03563   zhptri_(JOB_STR+5, &amp;n, A, ipiv, work, &amp;INFO);
<a name="l03564"></a>03564   assert(INFO==0);
<a name="l03565"></a>03565 
<a name="l03566"></a>03566   <span class="keyword">delete</span> [] work;
<a name="l03567"></a>03567   <span class="keyword">delete</span> [] ipiv;
<a name="l03568"></a>03568 }
<a name="l03569"></a>03569 
<a name="l03570"></a>03570 <span class="comment">//computation of eigenvalues and (orthonormal) eigenvectors of symmetric or</span>
<a name="l03571"></a>03571 <span class="comment">//hermitian  upper triangular matrix A, A is n by n</span>
<a name="l03572"></a>03572 <span class="comment">//the real eigenvalues are stored in diag</span>
<a name="l03573"></a>03573 <span class="keyword">inline</span> <span class="keywordtype">int</span> utreigv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">float</span> *diag,
<a name="l03574"></a>03574                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">float</span>* wk)
<a name="l03575"></a>03575 {
<a name="l03576"></a>03576   <span class="keywordtype">int</span> inf;
<a name="l03577"></a>03577   ssyev_(JOB_STR+4, JOB_STR+5, &amp;n, A, &amp;ldA, diag, wk, &amp;nwk, &amp;inf);
<a name="l03578"></a>03578   <span class="keywordflow">return</span> inf;
<a name="l03579"></a>03579 }
<a name="l03580"></a>03580 <span class="keyword">inline</span> <span class="keywordtype">int</span> utreigv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, <span class="keywordtype">double</span> *diag,
<a name="l03581"></a>03581                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, <span class="keywordtype">double</span>* wk)
<a name="l03582"></a>03582 {
<a name="l03583"></a>03583   <span class="keywordtype">int</span> inf;
<a name="l03584"></a>03584   dsyev_(JOB_STR+4, JOB_STR+5, &amp;n, A, &amp;ldA, diag, wk, &amp;nwk, &amp;inf);
<a name="l03585"></a>03585   <span class="keywordflow">return</span> inf;
<a name="l03586"></a>03586 }
<a name="l03587"></a>03587 <span class="keyword">inline</span> <span class="keywordtype">int</span> utreigv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, scomp *diag,
<a name="l03588"></a>03588                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, scomp* wk)
<a name="l03589"></a>03589 {
<a name="l03590"></a>03590   <span class="keywordtype">int</span> inf;
<a name="l03591"></a>03591   <span class="keywordtype">float</span> *float_diag = <span class="keyword">new</span> <span class="keywordtype">float</span>[n], *rwk = <span class="keyword">new</span> <span class="keywordtype">float</span>[MAX(1,3*n-2)];
<a name="l03592"></a>03592   assert(float_diag!=NULL &amp;&amp; rwk!=NULL);
<a name="l03593"></a>03593 
<a name="l03594"></a>03594   cheev_(JOB_STR+4, JOB_STR+5, &amp;n, A, &amp;ldA, float_diag, wk, &amp;nwk, rwk, &amp;inf);
<a name="l03595"></a>03595 
<a name="l03596"></a>03596   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) diag[i] = float_diag[i];
<a name="l03597"></a>03597   <span class="keyword">delete</span> [] float_diag;
<a name="l03598"></a>03598   <span class="keyword">delete</span> [] rwk;
<a name="l03599"></a>03599 
<a name="l03600"></a>03600   <span class="keywordflow">return</span> inf;
<a name="l03601"></a>03601 }
<a name="l03602"></a>03602 <span class="keyword">inline</span> <span class="keywordtype">int</span> utreigv(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldA, dcomp *diag,
<a name="l03603"></a>03603                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nwk, dcomp* wk)
<a name="l03604"></a>03604 {
<a name="l03605"></a>03605   <span class="keywordtype">int</span> inf;
<a name="l03606"></a>03606   <span class="keywordtype">double</span> *double_diag = <span class="keyword">new</span> <span class="keywordtype">double</span>[n], *rwk = <span class="keyword">new</span> <span class="keywordtype">double</span>[MAX(1,3*n-2)];
<a name="l03607"></a>03607   assert(double_diag!=NULL &amp;&amp; rwk!=NULL);
<a name="l03608"></a>03608 
<a name="l03609"></a>03609   zheev_(JOB_STR+4, JOB_STR+5, &amp;n, A, &amp;ldA, double_diag, wk, &amp;nwk, rwk, &amp;inf);
<a name="l03610"></a>03610 
<a name="l03611"></a>03611   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) diag[i] = double_diag[i];
<a name="l03612"></a>03612   <span class="keyword">delete</span> [] double_diag;
<a name="l03613"></a>03613   <span class="keyword">delete</span> [] rwk;
<a name="l03614"></a>03614 
<a name="l03615"></a>03615   <span class="keywordflow">return</span> inf;
<a name="l03616"></a>03616 }
<a name="l03617"></a>03617 
<a name="l03618"></a>03618 
<a name="l03619"></a>03619 <span class="comment">// packed triangular factorisation of positive definite matrix</span>
<a name="l03620"></a>03620 <span class="keyword">inline</span> <span class="keywordtype">int</span> pptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A)
<a name="l03621"></a>03621 {
<a name="l03622"></a>03622   <span class="keywordtype">int</span> inf;
<a name="l03623"></a>03623   dpptrf_(JOB_STR+5, &amp;n, A, &amp;inf);
<a name="l03624"></a>03624   <span class="keywordflow">return</span> inf;
<a name="l03625"></a>03625 }
<a name="l03626"></a>03626 <span class="keyword">inline</span> <span class="keywordtype">int</span> pptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A)
<a name="l03627"></a>03627 {
<a name="l03628"></a>03628   <span class="keywordtype">int</span> inf;
<a name="l03629"></a>03629   spptrf_(JOB_STR+5, &amp;n, A, &amp;inf);
<a name="l03630"></a>03630   <span class="keywordflow">return</span> inf;
<a name="l03631"></a>03631 }
<a name="l03632"></a>03632 <span class="keyword">inline</span> <span class="keywordtype">int</span> pptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A)
<a name="l03633"></a>03633 {
<a name="l03634"></a>03634   <span class="keywordtype">int</span> inf;
<a name="l03635"></a>03635   cpptrf_(JOB_STR+5, &amp;n, A, &amp;inf);
<a name="l03636"></a>03636   <span class="keywordflow">return</span> inf;
<a name="l03637"></a>03637 }
<a name="l03638"></a>03638 <span class="keyword">inline</span> <span class="keywordtype">int</span> pptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A)
<a name="l03639"></a>03639 {
<a name="l03640"></a>03640   <span class="keywordtype">int</span> inf;
<a name="l03641"></a>03641   zpptrf_(JOB_STR+5, &amp;n, A, &amp;inf);
<a name="l03642"></a>03642   <span class="keywordflow">return</span> inf;
<a name="l03643"></a>03643 }
<a name="l03644"></a>03644 
<a name="l03645"></a>03645 <span class="comment">// packed triangular factorization of symmetric(!) matrix</span>
<a name="l03646"></a>03646 <span class="keyword">inline</span> <span class="keywordtype">int</span> sptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">int</span>* ipiv)
<a name="l03647"></a>03647 {
<a name="l03648"></a>03648   <span class="keywordtype">int</span> inf;
<a name="l03649"></a>03649   dsptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;inf);
<a name="l03650"></a>03650   <span class="keywordflow">return</span> inf;
<a name="l03651"></a>03651 }
<a name="l03652"></a>03652 <span class="keyword">inline</span> <span class="keywordtype">int</span> sptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">int</span>* ipiv)
<a name="l03653"></a>03653 {
<a name="l03654"></a>03654   <span class="keywordtype">int</span> inf;
<a name="l03655"></a>03655   ssptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;inf);
<a name="l03656"></a>03656   <span class="keywordflow">return</span> inf;
<a name="l03657"></a>03657 }
<a name="l03658"></a>03658 <span class="keyword">inline</span> <span class="keywordtype">int</span> sptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">int</span>* ipiv)
<a name="l03659"></a>03659 {
<a name="l03660"></a>03660   <span class="keywordtype">int</span> inf;
<a name="l03661"></a>03661   csptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;inf);
<a name="l03662"></a>03662   <span class="keywordflow">return</span> inf;
<a name="l03663"></a>03663 }
<a name="l03664"></a>03664 <span class="keyword">inline</span> <span class="keywordtype">int</span> sptrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keywordtype">int</span>* ipiv)
<a name="l03665"></a>03665 {
<a name="l03666"></a>03666   <span class="keywordtype">int</span> inf;
<a name="l03667"></a>03667   zsptrf_(JOB_STR+5, &amp;n, A, ipiv, &amp;inf);
<a name="l03668"></a>03668   <span class="keywordflow">return</span> inf;
<a name="l03669"></a>03669 }
<a name="l03670"></a>03670 
<a name="l03671"></a>03671 
<a name="l03672"></a>03672 
<a name="l03673"></a>03673 <span class="comment">// triangular factorization of hermitian matrix</span>
<a name="l03674"></a>03674 <span class="keyword">inline</span> <span class="keywordtype">int</span> hetrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A, <span class="keywordtype">int</span>* ipiv, <span class="keywordtype">double</span>* work,
<a name="l03675"></a>03675                  <span class="keyword">const</span> <span class="keywordtype">int</span> lwork)
<a name="l03676"></a>03676 {
<a name="l03677"></a>03677   <span class="keywordtype">int</span> inf;
<a name="l03678"></a>03678   dsytrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);
<a name="l03679"></a>03679   <span class="keywordflow">return</span> inf;
<a name="l03680"></a>03680 }
<a name="l03681"></a>03681 <span class="keyword">inline</span> <span class="keywordtype">int</span> hetrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A, <span class="keywordtype">int</span>* ipiv, <span class="keywordtype">float</span>* work,
<a name="l03682"></a>03682                  <span class="keyword">const</span> <span class="keywordtype">int</span> lwork)
<a name="l03683"></a>03683 {
<a name="l03684"></a>03684   <span class="keywordtype">int</span> inf;
<a name="l03685"></a>03685   ssytrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);
<a name="l03686"></a>03686   <span class="keywordflow">return</span> inf;
<a name="l03687"></a>03687 }
<a name="l03688"></a>03688 <span class="keyword">inline</span> <span class="keywordtype">int</span> hetrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A, <span class="keywordtype">int</span>* ipiv, scomp* work,
<a name="l03689"></a>03689                  <span class="keyword">const</span> <span class="keywordtype">int</span> lwork)
<a name="l03690"></a>03690 {
<a name="l03691"></a>03691   <span class="keywordtype">int</span> inf;
<a name="l03692"></a>03692   chetrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);
<a name="l03693"></a>03693   <span class="keywordflow">return</span> inf;
<a name="l03694"></a>03694 }
<a name="l03695"></a>03695 <span class="keyword">inline</span> <span class="keywordtype">int</span> hetrf(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A, <span class="keywordtype">int</span>* ipiv, dcomp* work,
<a name="l03696"></a>03696                  <span class="keyword">const</span> <span class="keywordtype">int</span> lwork)
<a name="l03697"></a>03697 {
<a name="l03698"></a>03698   <span class="keywordtype">int</span> inf;
<a name="l03699"></a>03699   zhetrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);
<a name="l03700"></a>03700   <span class="keywordflow">return</span> inf;
<a name="l03701"></a>03701 }
<a name="l03702"></a>03702 
<a name="l03703"></a>03703 
<a name="l03704"></a>03704 
<a name="l03705"></a>03705 <span class="comment">/*</span>
<a name="l03706"></a>03706 <span class="comment">// triangular factorization of symmetric(!) matrix</span>
<a name="l03707"></a>03707 <span class="comment">inline int sytrf(const unsigned n, double* A, int* ipiv, double* work,</span>
<a name="l03708"></a>03708 <span class="comment">                 const int lwork)</span>
<a name="l03709"></a>03709 <span class="comment">{</span>
<a name="l03710"></a>03710 <span class="comment">  int inf;</span>
<a name="l03711"></a>03711 <span class="comment">  dsytrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);</span>
<a name="l03712"></a>03712 <span class="comment">  return inf;</span>
<a name="l03713"></a>03713 <span class="comment">}</span>
<a name="l03714"></a>03714 <span class="comment">inline int sytrf(const unsigned n, float* A, int* ipiv, float* work,</span>
<a name="l03715"></a>03715 <span class="comment">                 const int lwork)</span>
<a name="l03716"></a>03716 <span class="comment">{</span>
<a name="l03717"></a>03717 <span class="comment">  int inf;</span>
<a name="l03718"></a>03718 <span class="comment">  ssytrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);</span>
<a name="l03719"></a>03719 <span class="comment">  return inf;</span>
<a name="l03720"></a>03720 <span class="comment">}</span>
<a name="l03721"></a>03721 <span class="comment">inline int sytrf(const unsigned n, scomp* A, int* ipiv, scomp* work,</span>
<a name="l03722"></a>03722 <span class="comment">                 const int lwork)</span>
<a name="l03723"></a>03723 <span class="comment">{</span>
<a name="l03724"></a>03724 <span class="comment">  int inf;</span>
<a name="l03725"></a>03725 <span class="comment">  csytrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);</span>
<a name="l03726"></a>03726 <span class="comment">  return inf;</span>
<a name="l03727"></a>03727 <span class="comment">}</span>
<a name="l03728"></a>03728 <span class="comment">inline int sytrf(const unsigned n, dcomp* A, int* ipiv, dcomp* work,</span>
<a name="l03729"></a>03729 <span class="comment">                 const int lwork)</span>
<a name="l03730"></a>03730 <span class="comment">{</span>
<a name="l03731"></a>03731 <span class="comment">  int inf;</span>
<a name="l03732"></a>03732 <span class="comment">  zsytrf_(JOB_STR+6, &amp;n, A, &amp;n, ipiv, work, &amp;lwork, &amp;inf);</span>
<a name="l03733"></a>03733 <span class="comment">  return inf;</span>
<a name="l03734"></a>03734 <span class="comment">}</span>
<a name="l03735"></a>03735 <span class="comment">*/</span>
<a name="l03736"></a>03736 
<a name="l03737"></a>03737 <span class="comment">// lower triangular solve</span>
<a name="l03738"></a>03738 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l03739"></a>03739                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03740"></a>03740 {
<a name="l03741"></a>03741   <span class="comment">//  dtptrs_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03742"></a>03742   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03743"></a>03743     dtpsv_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03744"></a>03744 }
<a name="l03745"></a>03745 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l03746"></a>03746                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03747"></a>03747 {
<a name="l03748"></a>03748   <span class="comment">// stptrs_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03749"></a>03749   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03750"></a>03750     stpsv_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03751"></a>03751 }
<a name="l03752"></a>03752 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l03753"></a>03753                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, scomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03754"></a>03754 {
<a name="l03755"></a>03755   <span class="comment">//ctptrs_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03756"></a>03756   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03757"></a>03757     ctpsv_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03758"></a>03758 }
<a name="l03759"></a>03759 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l03760"></a>03760                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, dcomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03761"></a>03761 {
<a name="l03762"></a>03762   <span class="comment">//ztptrs_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03763"></a>03763   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03764"></a>03764     ztpsv_(JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03765"></a>03765 }
<a name="l03766"></a>03766 <span class="comment">// lower triangular transpose solve</span>
<a name="l03767"></a>03767 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l03768"></a>03768                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03769"></a>03769 {
<a name="l03770"></a>03770   <span class="comment">//  dtptrs_(JOB_STR+6, JOB_STR+1, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03771"></a>03771   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03772"></a>03772     dtpsv_(JOB_STR+6, JOB_STR+1, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03773"></a>03773 }
<a name="l03774"></a>03774 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l03775"></a>03775                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03776"></a>03776 {
<a name="l03777"></a>03777   <span class="comment">//  stptrs_(JOB_STR+6, JOB_STR+1, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03778"></a>03778   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03779"></a>03779     stpsv_(JOB_STR+6, JOB_STR+1, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03780"></a>03780 }
<a name="l03781"></a>03781 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l03782"></a>03782                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, scomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03783"></a>03783 {
<a name="l03784"></a>03784   <span class="comment">//ctptrs_(JOB_STR+6, JOB_STR+7, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03785"></a>03785   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03786"></a>03786     ctpsv_(JOB_STR+6, JOB_STR+7, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03787"></a>03787 }
<a name="l03788"></a>03788 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l03789"></a>03789                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, dcomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03790"></a>03790 {
<a name="l03791"></a>03791   <span class="comment">//ztptrs_(JOB_STR+6, JOB_STR+7, JOB_STR+5, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03792"></a>03792   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03793"></a>03793     ztpsv_(JOB_STR+6, JOB_STR+7, JOB_STR+5, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03794"></a>03794 }
<a name="l03795"></a>03795 
<a name="l03796"></a>03796 
<a name="l03797"></a>03797 <span class="comment">// unit upper triangular solve (with L and R stored in one matrix)</span>
<a name="l03798"></a>03798 <span class="comment">// XR=B, R is pxp, B is nxp</span>
<a name="l03799"></a>03799 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">double</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03800"></a>03800                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03801"></a>03801 {
<a name="l03802"></a>03802   dtrsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;D_ONE,
<a name="l03803"></a>03803          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03804"></a>03804 }
<a name="l03805"></a>03805 
<a name="l03806"></a>03806 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">float</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03807"></a>03807                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03808"></a>03808 {
<a name="l03809"></a>03809   strsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;S_ONE,
<a name="l03810"></a>03810          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03811"></a>03811 }
<a name="l03812"></a>03812 
<a name="l03813"></a>03813 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> scomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03814"></a>03814                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03815"></a>03815 {
<a name="l03816"></a>03816   ctrsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;C_ONE,
<a name="l03817"></a>03817          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03818"></a>03818 }
<a name="l03819"></a>03819 
<a name="l03820"></a>03820 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> dcomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03821"></a>03821                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03822"></a>03822 {
<a name="l03823"></a>03823   ztrsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;Z_ONE,
<a name="l03824"></a>03824          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03825"></a>03825 }
<a name="l03826"></a>03826 
<a name="l03827"></a>03827 <span class="comment">// unit upper triangular solve (with L and R stored in one matrix)</span>
<a name="l03828"></a>03828 <span class="comment">// RX=B, R is nxn, B is nxp</span>
<a name="l03829"></a>03829 <span class="keyword">inline</span> <span class="keywordtype">void</span> utlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03830"></a>03830                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">float</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03831"></a>03831 {
<a name="l03832"></a>03832   strsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;S_ONE,
<a name="l03833"></a>03833          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03834"></a>03834 }
<a name="l03835"></a>03835 <span class="keyword">inline</span> <span class="keywordtype">void</span> utlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03836"></a>03836                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03837"></a>03837 {
<a name="l03838"></a>03838   dtrsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;D_ONE,
<a name="l03839"></a>03839          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03840"></a>03840 }
<a name="l03841"></a>03841 <span class="keyword">inline</span> <span class="keywordtype">void</span> utlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03842"></a>03842                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, scomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03843"></a>03843 {
<a name="l03844"></a>03844   ctrsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;C_ONE,
<a name="l03845"></a>03845          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03846"></a>03846 }
<a name="l03847"></a>03847 <span class="keyword">inline</span> <span class="keywordtype">void</span> utlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03848"></a>03848                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, dcomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03849"></a>03849 {
<a name="l03850"></a>03850   ztrsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;Z_ONE,
<a name="l03851"></a>03851          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03852"></a>03852 }
<a name="l03853"></a>03853 
<a name="l03854"></a>03854 <span class="comment">// unit lower triangular solve (with L and R stored in one matrix)</span>
<a name="l03855"></a>03855 <span class="comment">// XL=B, L is pxp, B is nxp</span>
<a name="l03856"></a>03856 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">float</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03857"></a>03857                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03858"></a>03858 {
<a name="l03859"></a>03859   strsm_(JOB_STR+8, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;S_ONE,
<a name="l03860"></a>03860          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03861"></a>03861 }
<a name="l03862"></a>03862 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">double</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03863"></a>03863                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03864"></a>03864 {
<a name="l03865"></a>03865   dtrsm_(JOB_STR+8, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;D_ONE,
<a name="l03866"></a>03866          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03867"></a>03867 }
<a name="l03868"></a>03868 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> scomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03869"></a>03869                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03870"></a>03870 {
<a name="l03871"></a>03871   ctrsm_(JOB_STR+8, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;C_ONE,
<a name="l03872"></a>03872          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03873"></a>03873 }
<a name="l03874"></a>03874 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> dcomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03875"></a>03875                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03876"></a>03876 {
<a name="l03877"></a>03877   ztrsm_(JOB_STR+8, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;Z_ONE,
<a name="l03878"></a>03878          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03879"></a>03879 }
<a name="l03880"></a>03880 
<a name="l03881"></a>03881 
<a name="l03882"></a>03882 <span class="comment">// unit lower triangular transposed solve (with L and R stored in one matrix)</span>
<a name="l03883"></a>03883 <span class="comment">// XL^T=B, L is pxp, B is nxp</span>
<a name="l03884"></a>03884 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltrhcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">double</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03885"></a>03885                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03886"></a>03886 {
<a name="l03887"></a>03887   dtrsm_(JOB_STR+8, JOB_STR+6, JOB_STR+1, JOB_STR+5, &amp;n, &amp;p, &amp;D_ONE,
<a name="l03888"></a>03888          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03889"></a>03889 }
<a name="l03890"></a>03890 
<a name="l03891"></a>03891 <span class="comment">// unit lower triangular solve (with L and R stored in one matrix)</span>
<a name="l03892"></a>03892 <span class="comment">// LX=B, L is nxn, B is nxp</span>
<a name="l03893"></a>03893 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03894"></a>03894                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">float</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03895"></a>03895 {
<a name="l03896"></a>03896   strsm_(JOB_STR+6, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;S_ONE,
<a name="l03897"></a>03897          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03898"></a>03898 }
<a name="l03899"></a>03899 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03900"></a>03900                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03901"></a>03901 {
<a name="l03902"></a>03902   dtrsm_(JOB_STR+6, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;D_ONE,
<a name="l03903"></a>03903          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03904"></a>03904 }
<a name="l03905"></a>03905 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03906"></a>03906                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, scomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03907"></a>03907 {
<a name="l03908"></a>03908   ctrsm_(JOB_STR+6, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;C_ONE,
<a name="l03909"></a>03909          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03910"></a>03910 }
<a name="l03911"></a>03911 <span class="keyword">inline</span> <span class="keywordtype">void</span> ltlcs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03912"></a>03912                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, dcomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03913"></a>03913 {
<a name="l03914"></a>03914   ztrsm_(JOB_STR+6, JOB_STR+6, JOB_STR, JOB_STR+5, &amp;n, &amp;p, &amp;Z_ONE,
<a name="l03915"></a>03915          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03916"></a>03916 }
<a name="l03917"></a>03917 
<a name="l03918"></a>03918 <span class="comment">// upper triangular solve</span>
<a name="l03919"></a>03919 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* A,
<a name="l03920"></a>03920                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03921"></a>03921 {
<a name="l03922"></a>03922   <span class="comment">//  dtptrs_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03923"></a>03923   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03924"></a>03924     dtpsv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03925"></a>03925 }
<a name="l03926"></a>03926 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* A,
<a name="l03927"></a>03927                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03928"></a>03928 {
<a name="l03929"></a>03929   <span class="comment">//stptrs_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03930"></a>03930   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03931"></a>03931     stpsv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03932"></a>03932 }
<a name="l03933"></a>03933 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* A,
<a name="l03934"></a>03934                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, scomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03935"></a>03935 {
<a name="l03936"></a>03936   <span class="comment">//ctptrs_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03937"></a>03937   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03938"></a>03938     ctpsv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03939"></a>03939 }
<a name="l03940"></a>03940 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* A,
<a name="l03941"></a>03941                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, dcomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03942"></a>03942 {
<a name="l03943"></a>03943   <span class="comment">//ztptrs_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03944"></a>03944   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03945"></a>03945     ztpsv_(JOB_STR+5, JOB_STR, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03946"></a>03946 }
<a name="l03947"></a>03947 
<a name="l03948"></a>03948 
<a name="l03949"></a>03949 
<a name="l03950"></a>03950 <span class="comment">// upper triangluar transpose solve</span>
<a name="l03951"></a>03951 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* A,
<a name="l03952"></a>03952                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">double</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03953"></a>03953 {
<a name="l03954"></a>03954   <span class="comment">//dtptrs_(JOB_STR+5, JOB_STR+1, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03955"></a>03955   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03956"></a>03956     dtpsv_(JOB_STR+5, JOB_STR+1, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03957"></a>03957 }
<a name="l03958"></a>03958 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* A,
<a name="l03959"></a>03959                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">float</span>* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03960"></a>03960 {
<a name="l03961"></a>03961   <span class="comment">//stptrs_(JOB_STR+5, JOB_STR+1, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03962"></a>03962   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03963"></a>03963     stpsv_(JOB_STR+5, JOB_STR+1, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03964"></a>03964 }
<a name="l03965"></a>03965 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* A,
<a name="l03966"></a>03966                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, scomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03967"></a>03967 {
<a name="l03968"></a>03968   <span class="comment">//  ctptrs_(JOB_STR+5, JOB_STR+7, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03969"></a>03969   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03970"></a>03970     ctpsv_(JOB_STR+5, JOB_STR+7, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03971"></a>03971 }
<a name="l03972"></a>03972 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrhs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* A,
<a name="l03973"></a>03973                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, dcomp* B, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldB)
<a name="l03974"></a>03974 {
<a name="l03975"></a>03975   <span class="comment">//ztptrs_(JOB_STR+5, JOB_STR+7, JOB_STR, &amp;n, &amp;p, A, B, &amp;ldB, &amp;inf);</span>
<a name="l03976"></a>03976   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;p; ++i)
<a name="l03977"></a>03977     ztpsv_(JOB_STR+5, JOB_STR+7, JOB_STR, &amp;n, A, B+i*ldB, &amp;N_ONE);
<a name="l03978"></a>03978 }
<a name="l03979"></a>03979 
<a name="l03980"></a>03980 
<a name="l03981"></a>03981 
<a name="l03982"></a>03982 <span class="comment">// upper triangular solve (with L and R stored in one matrix)</span>
<a name="l03983"></a>03983 <span class="comment">// XR=B, R is pxp, B is nxp</span>
<a name="l03984"></a>03984 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">double</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03985"></a>03985                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03986"></a>03986 {
<a name="l03987"></a>03987   dtrsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;D_ONE,
<a name="l03988"></a>03988          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03989"></a>03989 }
<a name="l03990"></a>03990 
<a name="l03991"></a>03991 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> <span class="keywordtype">float</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03992"></a>03992                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keywordtype">float</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l03993"></a>03993 {
<a name="l03994"></a>03994   strsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;S_ONE,
<a name="l03995"></a>03995          LR, &amp;ldLR, X, &amp;ldX);
<a name="l03996"></a>03996 }
<a name="l03997"></a>03997 
<a name="l03998"></a>03998 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> scomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l03999"></a>03999                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, scomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l04000"></a>04000 {
<a name="l04001"></a>04001   ctrsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;C_ONE,
<a name="l04002"></a>04002          LR, &amp;ldLR, X, &amp;ldX);
<a name="l04003"></a>04003 }
<a name="l04004"></a>04004 
<a name="l04005"></a>04005 <span class="keyword">inline</span> <span class="keywordtype">void</span> utrs(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keyword">const</span> dcomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l04006"></a>04006                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, dcomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l04007"></a>04007 {
<a name="l04008"></a>04008   ztrsm_(JOB_STR+8, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;Z_ONE,
<a name="l04009"></a>04009          LR, &amp;ldLR, X, &amp;ldX);
<a name="l04010"></a>04010 }
<a name="l04011"></a>04011 
<a name="l04012"></a>04012 
<a name="l04013"></a>04013 <span class="comment">// upper triangular solve (with L and R stored in one matrix)</span>
<a name="l04014"></a>04014 <span class="comment">// RX=B, R is nxn, B is nxp</span>
<a name="l04015"></a>04015 <span class="keyword">inline</span> <span class="keywordtype">void</span> utls(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">float</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l04016"></a>04016                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">float</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l04017"></a>04017 {
<a name="l04018"></a>04018   strsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;S_ONE,
<a name="l04019"></a>04019          LR, &amp;ldLR, X, &amp;ldX);
<a name="l04020"></a>04020 }
<a name="l04021"></a>04021 <span class="keyword">inline</span> <span class="keywordtype">void</span> utls(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l04022"></a>04022                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, <span class="keywordtype">double</span>* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l04023"></a>04023 {
<a name="l04024"></a>04024   dtrsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;D_ONE,
<a name="l04025"></a>04025          LR, &amp;ldLR, X, &amp;ldX);
<a name="l04026"></a>04026 }
<a name="l04027"></a>04027 <span class="keyword">inline</span> <span class="keywordtype">void</span> utls(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> scomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l04028"></a>04028                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, scomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l04029"></a>04029 {
<a name="l04030"></a>04030   ctrsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;C_ONE,
<a name="l04031"></a>04031          LR, &amp;ldLR, X, &amp;ldX);
<a name="l04032"></a>04032 }
<a name="l04033"></a>04033 <span class="keyword">inline</span> <span class="keywordtype">void</span> utls(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> dcomp* LR, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldLR,
<a name="l04034"></a>04034                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> p, dcomp* X, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ldX)
<a name="l04035"></a>04035 {
<a name="l04036"></a>04036   ztrsm_(JOB_STR+6, JOB_STR+5, JOB_STR, JOB_STR, &amp;n, &amp;p, &amp;Z_ONE,
<a name="l04037"></a>04037          LR, &amp;ldLR, X, &amp;ldX);
<a name="l04038"></a>04038 }
<a name="l04039"></a>04039 }
<a name="l04040"></a>04040 
<a name="l04041"></a>04041 
<a name="l04042"></a>04042 
<a name="l04043"></a>04043 
<a name="l04044"></a>04044 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 11 2012 16:50:22 for AHMED by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
